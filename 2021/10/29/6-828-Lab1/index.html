<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>6.828-Lab1(old) - BakaFT&#039;s blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="BakaFT&#039;s blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="BakaFT&#039;s blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Lab 1: Booting a PCIntroductionThis lab is split into three parts. The first part concentrates on getting familiarized with x86 assembly language, the QEMU x86 emulator, and the PC’s power-on bootstra"><meta property="og:type" content="blog"><meta property="og:title" content="6.828-Lab1(old)"><meta property="og:url" content="https://bakaft.github.io/2021/10/29/6-828-Lab1/"><meta property="og:site_name" content="BakaFT&#039;s blog"><meta property="og:description" content="Lab 1: Booting a PCIntroductionThis lab is split into three parts. The first part concentrates on getting familiarized with x86 assembly language, the QEMU x86 emulator, and the PC’s power-on bootstra"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://i.stack.imgur.com/RMV0g.png"><meta property="article:published_time" content="2021-10-29T15:45:23.000Z"><meta property="article:modified_time" content="2023-12-28T08:42:40.251Z"><meta property="article:author" content="BakaFT"><meta property="article:tag" content="OS"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://i.stack.imgur.com/RMV0g.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://bakaft.github.io/2021/10/29/6-828-Lab1/"},"headline":"6.828-Lab1(old)","image":["https://i.stack.imgur.com/RMV0g.png"],"datePublished":"2021-10-29T15:45:23.000Z","dateModified":"2023-12-28T08:42:40.251Z","author":{"@type":"Person","name":"BakaFT"},"publisher":{"@type":"Organization","name":"BakaFT's blog","logo":{"@type":"ImageObject","url":{"text":"BakaFT's blog"}}},"description":"Lab 1: Booting a PCIntroductionThis lab is split into three parts. The first part concentrates on getting familiarized with x86 assembly language, the QEMU x86 emulator, and the PC’s power-on bootstra"}</script><link rel="canonical" href="https://bakaft.github.io/2021/10/29/6-828-Lab1/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/highlight.js@9.12.0/styles/idea.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://fastly.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 6.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">BakaFT&#039;s blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-10-29T15:45:23.000Z" title="10/29/2021, 3:45:23 PM">2021-10-29</time></span></div></div><h1 class="title is-3 is-size-4-mobile">6.828-Lab1(old)</h1><div class="content"><h1 id="Lab-1-Booting-a-PC"><a href="#Lab-1-Booting-a-PC" class="headerlink" title="Lab 1: Booting a PC"></a>Lab 1: Booting a PC</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>This lab is split into three parts. The first part concentrates on getting familiarized with x86 assembly language, the QEMU x86 emulator, and the PC’s power-on bootstrap procedure. The second part examines the boot loader for our 6.828 kernel, which resides in the <code>boot</code> directory of the <code>lab</code> tree. Finally, the third part delves into the initial template for our 6.828 kernel itself, named JOS, which resides in the <code>kernel</code> directory.</p>
<span id="more"></span>

<h2 id="Part-1-PC-Bootstrap"><a href="#Part-1-PC-Bootstrap" class="headerlink" title="Part 1: PC Bootstrap"></a>Part 1: PC Bootstrap</h2><h3 id="Getting-Started-with-x86-assembly"><a href="#Getting-Started-with-x86-assembly" class="headerlink" title="Getting Started with x86 assembly"></a>Getting Started with x86 assembly</h3><p>The <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/readings/pcasm-book.pdf">PC Assembly Language Book</a> is an excellent place to start. </p>
<p><em>Warning:</em> Unfortunately the examples in the book are written for the NASM assembler, whereas we will be using the GNU assembler. NASM uses the so-called <em>Intel</em> syntax while GNU uses the <em>AT&amp;T</em> syntax. While semantically equivalent, an assembly file will differ quite a lot, at least superficially, depending on which syntax is used. Luckily the conversion between the two is pretty simple, and is covered in <a target="_blank" rel="noopener" href="http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html">Brennan’s Guide to Inline Assembly</a>.</p>
<p>Certainly the definitive reference for x86 assembly language programming is Intel’s instruction set architecture reference, which you can find on <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/reference.html">the 6.828 reference page</a> in two flavors: an HTML edition of the old <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/toc.htm">80386 Programmer’s Reference Manual</a>, which is much shorter and easier to navigate than more recent manuals but describes all of the x86 processor features that we will make use of in 6.828; and the full, latest and greatest <a target="_blank" rel="noopener" href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">IA-32 Intel Architecture Software Developer’s Manuals</a> from Intel, covering all the features of the most recent processors that we won’t need in class but you may be interested in learning about. An equivalent (and often friendlier) set of manuals is <a target="_blank" rel="noopener" href="http://developer.amd.com/resources/developer-guides-manuals/">available from AMD</a>. Save the Intel&#x2F;AMD architecture manuals for later or use them for reference when you want to look up the definitive explanation of a particular processor feature or instruction.</p>
<h3 id="Simulating-the-x86"><a href="#Simulating-the-x86" class="headerlink" title="Simulating the x86"></a>Simulating the x86</h3><h4 id="Install-QEMU-patched-version-by-MIT"><a href="#Install-QEMU-patched-version-by-MIT" class="headerlink" title="Install QEMU patched version by MIT"></a>Install QEMU patched version by MIT</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/mit-pdos/6.828-qemu.git qemu</span><br><span class="line"><span class="built_in">cd</span> qemu</span><br><span class="line">./configure --disable-kvm --disable-werror --disable-sdl --target-list=<span class="string">&quot;i386-softmmu x86_64-softmmu&quot;</span></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h4 id="Install-i386-jos-elf-gcc-and-i386-elf-binutils"><a href="#Install-i386-jos-elf-gcc-and-i386-elf-binutils" class="headerlink" title="Install i386-jos-elf-gcc  and i386-elf-binutils"></a>Install <code>i386-jos-elf-gcc</code>  and <code>i386-elf-binutils</code></h4><p><code>jos</code> in package name is just a custom prefix, it’s said that you can use <code>gmake GCCPREFIX=&#123;prefix&#125;</code>to use your own prefix and in this Makefile it’s defined as <code>jos</code> by default.</p>
<p>but in MacOS <code>gmake</code> seems not a command when you are at the beginning, so choose the easy way.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew tap liudangyi/i386-jos-elf-gcc</span><br><span class="line">brew install i386-jos-elf-gcc i386-elf-binutils i386-jos-elf-gdb</span><br></pre></td></tr></table></figure>

<h4 id="Download-jos"><a href="#Download-jos" class="headerlink" title="Download jos"></a>Download jos</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://pdos.csail.mit.edu/6.828/2018/jos.git lab</span><br></pre></td></tr></table></figure>

<h4 id="Make-and-run-jos"><a href="#Make-and-run-jos" class="headerlink" title="Make and run jos"></a>Make and run jos</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> lab</span><br><span class="line">make</span><br><span class="line">+ as kern/entry.S</span><br><span class="line">+ cc kern/entrypgdir.c</span><br><span class="line">+ cc kern/init.c</span><br><span class="line">+ cc kern/console.c</span><br><span class="line">+ cc kern/monitor.c</span><br><span class="line">+ cc kern/printf.c</span><br><span class="line">+ cc kern/kdebug.c</span><br><span class="line">+ cc lib/printfmt.c</span><br><span class="line">+ cc lib/readline.c</span><br><span class="line">+ cc lib/string.c</span><br><span class="line">+ ld obj/kern/kernel</span><br><span class="line">+ as boot/boot.S</span><br><span class="line">+ cc -Os boot/main.c</span><br><span class="line">+ ld boot/boot</span><br><span class="line">boot block is 380 bytes (max 510)</span><br><span class="line">+ mk obj/kern/kernel.img</span><br></pre></td></tr></table></figure>

<p>Run it with QEMU</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make qemu</span><br></pre></td></tr></table></figure>

<p>or with out Virtual VGA</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make qemu-nox</span><br></pre></td></tr></table></figure>

<p>Here’s the difference :</p>
<blockquote>
<p>If you used <code>make qemu</code>, these lines printed by the kernel will appear in both the regular shell window from which you ran QEMU and the QEMU display window.</p>
<p> This is because for testing and lab grading purposes we have set up the JOS kernel to write its console output not only to the virtual VGA display (as seen in the QEMU window), but also to the simulated PC’s virtual serial port, which QEMU in turn outputs to its own standard output. Likewise, the JOS kernel will take input from both the keyboard and the serial port, so you can give it commands in either the VGA display window or the terminal running QEMU.</p>
<p>  Alternatively, you can use the serial console without the virtual VGA by running <code>make qemu-nox</code> </p>
</blockquote>
<p>Although simple, it’s important to note that this kernel monitor is running “directly” on the “raw (virtual) hardware” of the simulated PC. This means that <strong>you should be able to copy the contents of <code>obj/kern/kernel.img</code> onto the first few sectors of a <em>real</em> hard disk, insert that hard disk into a real PC, turn it on, and see exactly the same thing on the PC’s real screen as you did above in the QEMU window.</strong> </p>
<h3 id="The-PC’s-Physical-Address-Space"><a href="#The-PC’s-Physical-Address-Space" class="headerlink" title="The PC’s Physical Address Space"></a>The PC’s Physical Address Space</h3><p>A PC’s physical address space is hard-wired to have the following general layout:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+------------------+  &lt;- 0xFFFFFFFF (4GB)</span><br><span class="line">|      32-bit      |</span><br><span class="line">|  memory mapped   |</span><br><span class="line">|     devices      |</span><br><span class="line">|                  |</span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line"></span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line">|                  |</span><br><span class="line">|      Unused      |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- depends on amount of RAM</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">| Extended Memory  |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00100000 (1MB)</span><br><span class="line">|     BIOS ROM     |</span><br><span class="line">+------------------+  &lt;- 0x000F0000 (960KB)</span><br><span class="line">|  16-bit devices, |</span><br><span class="line">|  expansion ROMs  |</span><br><span class="line">+------------------+  &lt;- 0x000C0000 (768KB)</span><br><span class="line">|   VGA Display    |</span><br><span class="line">+------------------+  &lt;- 0x000A0000 (640KB)</span><br><span class="line">|                  |</span><br><span class="line">|    Low Memory    |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00000000</span><br></pre></td></tr></table></figure>

<p>The first PCs, which were based on the 16-bit Intel <strong>8088</strong> processor, were only capable of addressing 1MB of physical memory, Like</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+------------------+  &lt;- 0x00100000 (1MB)</span><br><span class="line">|     BIOS ROM     |</span><br><span class="line">+------------------+  &lt;- 0x000F0000 (960KB)</span><br><span class="line">|  16-bit devices, |</span><br><span class="line">|  expansion ROMs  |</span><br><span class="line">+------------------+  &lt;- 0x000C0000 (768KB)</span><br><span class="line">|   VGA Display    |</span><br><span class="line">+------------------+  &lt;- 0x000A0000 (640KB)</span><br><span class="line">|                  |</span><br><span class="line">|    Low Memory    |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00000000</span><br></pre></td></tr></table></figure>

<p>The physical address space of an early PC would therefore start at 0x00000000 and end at 0x000FFFFF(1048575 Bytes) </p>
<p>The 640KB area marked “Low Memory” was the <em>only</em> random-access memory (RAM) that an early PC could use</p>
<p>The 384KB area from 0x000A0000 through 0x000FFFFF was reserved by the hardware for special uses such as video display buffers and firmware held in non-volatile memory. </p>
<h3 id="The-ROM-BIOS"><a href="#The-ROM-BIOS" class="headerlink" title="The ROM BIOS"></a>The ROM BIOS</h3><h4 id="Run-jos-with-GDB"><a href="#Run-jos-with-GDB" class="headerlink" title="Run jos with GDB"></a>Run jos with GDB</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/Volumes/f-Exchange/6.828/lab&gt; make qemu-gdb                                           </span><br><span class="line">***</span><br><span class="line">*** Now run <span class="string">&#x27;make gdb&#x27;</span>.</span><br><span class="line">***</span><br><span class="line">qemu-system-i386 -drive file=obj/kern/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp::25501 -D qemu.log  -S</span><br></pre></td></tr></table></figure>

<p>Now jos is paused and wating for a gdb connection</p>
<h4 id="Run-GDB"><a href="#Run-GDB" class="headerlink" title="Run GDB"></a>Run GDB</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Volumes/f/6/lab&gt; make gdb                     </span><br><span class="line">gdb -n -x .gdbinit</span><br><span class="line">make: gdb: No such file or directory</span><br><span class="line">make: *** [gdb] Error 1</span><br></pre></td></tr></table></figure>

<p>okay..</p>
<p>Let’s look at the <code>GNUMakefile</code> at line <code>150</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb:</span><br><span class="line">	gdb -n -x .gdbinit</span><br></pre></td></tr></table></figure>

<p>So here’s why : I installed gdb using brew and it’s named <code>i386-jos-elf-gdb</code>, which is unknown to this Makefile. So I just run it myself.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> lab</span><br><span class="line">i386-jos-elf-gdb -n -x .gdbinit</span><br><span class="line">GNU gdb (GDB) 7.3.1</span><br><span class="line">This GDB was configured as <span class="string">&quot;--host=x86_64-apple-darwin20.2.0 --target=i386-jos-elf&quot;</span>.</span><br><span class="line">+ target remote localhost:25501</span><br><span class="line">The target architecture is assumed to be i8086</span><br><span class="line">[f000:fff0]    0xffff0:	ljmp   <span class="variable">$0xf000</span>,<span class="variable">$0xe05b</span></span><br><span class="line">0x0000fff0 <span class="keyword">in</span> ?? ()</span><br><span class="line">+ symbol-file obj/kern/kernel</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>

<p>From GDB’s disassembly of the first instruction to be executed you can conclude a few things:</p>
<ul>
<li>The IBM PC starts executing at physical address 0x000ffff0, which is at the very top of the 64KB area reserved for the ROM BIOS.</li>
<li>The PC starts executing with <code>CS = 0xf000</code> and <code>IP = 0xfff0</code>.</li>
<li>The first instruction to be executed is a <code>jmp</code> instruction, which jumps to the segmented address <code>CS = 0xf000</code> and <code>IP = 0xe05b</code>.</li>
</ul>
<p><strong>So What’s CS and IP ?</strong></p>
<p>CS is short for <code>Code segment</code> , a register to store the beginning address of code</p>
<p>IP is <code>Instruction Pointer</code>, a register to store next instruction’s offset</p>
<p>How does the segmented address 0xf000:fff0 turn into a physical address?</p>
<p>To answer that we need to know a bit about real mode addressing. In real mode (the mode that PC starts off in), address translation works according to the formula: </p>
<p><em>physical address</em> &#x3D; 16 * <em>segment</em> + <em>offset</em>. </p>
<p>So, when the PC sets CS to 0xf000 and IP to 0xfff0, the physical address referenced is:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">16 * 0xf000 + 0xfff0   # in hex multiplication by 16 is</span><br><span class="line">= 0xf0000 + 0xfff0     # easy--just append a 0.</span><br><span class="line">= 0xffff0 </span><br></pre></td></tr></table></figure>

<p><code>0xffff0</code> is 16 bytes before the end of the BIOS (<code>0x100000</code>). Therefore we shouldn’t be surprised that the first thing that the BIOS does is <code>jmp</code> backwards to an earlier location in the BIOS; after all how much could it accomplish in just 16 bytes?</p>
<h2 id="Part-2-The-Boot-Loader"><a href="#Part-2-The-Boot-Loader" class="headerlink" title="Part 2: The Boot Loader"></a>Part 2: The Boot Loader</h2><h3 id="Sectors"><a href="#Sectors" class="headerlink" title="Sectors"></a>Sectors</h3><p>Floppy and hard disks for PCs are divided into 512 byte regions called <em>sectors</em>. A sector is the disk’s minimum transfer granularity: each read or write operation must be one or more sectors in size and aligned on a sector boundary.</p>
<p>If the disk is bootable, the first sector is called the <em>boot sector</em>, since this is where the boot loader code resides. When the BIOS finds a bootable floppy or hard disk, it loads the 512-byte boot sector into memory at physical addresses <strong>0x7c00</strong> through 0x7dff, and then uses a <code>jmp</code> instruction to set the CS:IP to <code>0000:7c00</code>, passing control to the boot loader. Like the BIOS load address, these addresses are fairly arbitrary - but they are fixed and standardized for PCs.</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2015/09/0x7c00.html">Why 0x7C00 here?</a></p>
</blockquote>
<p>The ability to boot from a CD-ROM came much later during the evolution of the PC, and as a result the PC architects took the opportunity to rethink the boot process slightly. As a result, the way a modern BIOS boots from a CD-ROM is a bit more complicated (and more powerful). CD-ROMs use a sector size of 2048 bytes instead of 512, and the BIOS can load a much larger boot image from the disk into memory (not just one sector) before transferring control to it. For more information, see the <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/readings/boot-cdrom.pdf">“El Torito” Bootable CD-ROM Format Specification</a>.</p>
<h3 id="Booting"><a href="#Booting" class="headerlink" title="Booting"></a>Booting</h3><p>For 6.828, however, we will use the conventional hard drive boot mechanism, which means that our boot loader must fit into a measly 512 bytes. The boot loader consists of one assembly language source file, <code>boot/boot.S</code>, and one C source file, <code>boot/main.c</code> Look through these source files carefully and make sure you understand what’s going on. The boot loader must perform two main functions:</p>
<ol>
<li>First, the boot loader switches the processor from real mode to <em>32-bit protected mode</em>, because it is only in this mode that software can access all the memory above 1MB in the processor’s physical address space. Protected mode is described briefly in sections 1.2.7 and 1.2.8 of <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/readings/pcasm-book.pdf">PC Assembly Language</a>, and in great detail in the Intel architecture manuals. At this point you only have to understand that translation of segmented addresses (segment:offset pairs) into physical addresses happens differently in protected mode, and that after the transition offsets are 32 bits instead of 16.</li>
<li>Second, the boot loader reads the kernel from the hard disk by directly accessing the IDE disk device registers via the x86’s special I&#x2F;O instructions. If you would like to understand better what the particular I&#x2F;O instructions here mean, check out the “IDE hard drive controller” section on <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/reference.html">the 6.828 reference page</a>. You will not need to learn much about programming specific devices in this class: writing device drivers is in practice a very important part of OS development, but from a conceptual or architectural viewpoint it is also one of the least interesting.</li>
</ol>
<p>After you understand the boot loader source code, look at the file <code>obj/boot/boot.asm</code>. This file is a disassembly of the boot loader that our GNUmakefile creates <em>after</em> compiling the boot loader. This disassembly file makes it easy to see exactly where in physical memory all of the boot loader’s code resides, and makes it easier to track what’s happening while stepping through the boot loader in GDB. Likewise, <code>obj/kern/kernel.asm</code> contains a disassembly of the JOS kernel, which can often be useful for debugging.</p>
<h4 id="GDB-Usage"><a href="#GDB-Usage" class="headerlink" title="GDB Usage"></a>GDB Usage</h4><h5 id="Breakpoint"><a href="#Breakpoint" class="headerlink" title="Breakpoint"></a>Breakpoint</h5><p> <code>b *0x7c00</code>sets a breakpoint at address 0x7C00.</p>
<h5 id="Continue"><a href="#Continue" class="headerlink" title="Continue"></a>Continue</h5><p><code>c</code> causes QEMU to continue execution until the next breakpoint (or until you press Ctrl-C in GDB)</p>
<h5 id="Step-through"><a href="#Step-through" class="headerlink" title="Step through"></a>Step through</h5><p><code>si N</code> steps through the instructions <em><code>N</code></em> at a time. N is 1 by default.</p>
<h5 id="Examine"><a href="#Examine" class="headerlink" title="Examine"></a>Examine</h5><p>To examine instructions in memory (besides the immediate next one to be executed, which GDB prints automatically), you use the x&#x2F;i command. </p>
<p>This command has the syntax x&#x2F;<em>N</em>i <em>ADDR</em>, where <em>N</em> is the number of consecutive instructions to disassemble and <em>ADDR</em> is the memory address at which to start disassembling.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Examine memory: x/FMT ADDRESS.</span><br><span class="line">ADDRESS is an expression for the memory address to examine.</span><br><span class="line">FMT is a repeat count followed by a format letter and a size letter.</span><br><span class="line">Format letters are o(octal), x(hex), d(decimal), u(unsigned decimal),</span><br><span class="line">  t(binary), f(float), a(address), i(instruction), c(char) and s(string).</span><br><span class="line">Size letters are b(byte), h(halfword), w(word), g(giant, 8 bytes).</span><br><span class="line">The specified number of objects of the specified size are printed</span><br><span class="line">according to the format.</span><br></pre></td></tr></table></figure>

<h4 id="Real-mode"><a href="#Real-mode" class="headerlink" title="Real mode"></a>Real mode</h4><p>As the CPU powers on, it’s in the <code>Real mode</code>,  memory is limited to only one megabyte(2^20 bytes).</p>
<p>Address range from 00000 to FFFFF, which requires a 20-bit  number. Obviously, not possible for a 16-bit Intel 8088 Micro CPU. </p>
<p>Intel solved this problem, by using two 16-bit values determine an address. The first 16-bit value is called the selector. Selector values must be stored in segment registers. The second 16-bit value is called the offset. The physical address referenced by a 32-bit selector:offset pair is computed by the formula, which is mentioned above:</p>
<blockquote>
<p>16 ∗ selector + offset</p>
</blockquote>
<p>Multiplying by 16 in hex is easy, just add a 0 to the right of the number.</p>
<p>In binary it’s</p>
<blockquote>
<p>selector&lt;&lt;4 + offset</p>
</blockquote>
<h4 id="Protected-mode"><a href="#Protected-mode" class="headerlink" title="Protected mode"></a>Protected mode</h4><p>In this mode, We can finally use the <code>extended memory</code> above 1MB.</p>
<p>In the <strong>80286’s</strong> 16-bit protected mode, selector values are interpreted completely differently than in real mode. In real mode, a selector value is a paragraph number of physical memory. </p>
<p>In protected mode, a selector value is an index into a <code>descriptor table</code>. In both modes, programs are divided into segments. In real mode, these segments are at <strong>fixed</strong> positions in physical memory and the selector value denotes the paragraph number of the beginning of the segment. In protected mode, the segments are <strong>not at fixed positions</strong> in physical memory. In fact, they do not have to be in memory at all</p>
<h4 id="boot-S"><a href="#boot-S" class="headerlink" title="boot.S"></a>boot.S</h4><p>This asm turn the PC into protected mode to continue to execute C code(main.c)</p>
<p>Many steps in this assembly file are the same with QEMU’s SeaBIOS such as Opening A20 Line, Switching to protected mode.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Start the CPU: switch to 32-bit protected mode, jump into C.</span><br><span class="line"># The BIOS loads this code from the first sector of the hard disk into</span><br><span class="line"># memory at physical address 0x7c00 and starts executing in real mode</span><br><span class="line"># with %cs=0 %ip=7c00.</span><br></pre></td></tr></table></figure>

<h4 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h4><p>This C file act as a boot loader to boot from a ELF kernel image file.</p>
<p>More details in Exercise 3.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment"> * This a dirt simple boot loader, whose sole job is to boot</span></span><br><span class="line"><span class="comment"> * an ELF kernel image from the first IDE hard disk.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DISK LAYOUT</span></span><br><span class="line"><span class="comment"> *  * This program(boot.S and main.c) is the bootloader.  It should</span></span><br><span class="line"><span class="comment"> *    be stored in the first sector of the disk.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * The 2nd sector onward holds the kernel image.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * The kernel image must be in ELF format.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * BOOT UP STEPS</span></span><br><span class="line"><span class="comment"> *  * when the CPU boots it loads the BIOS into memory and executes it</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * the BIOS intializes devices, sets of the interrupt routines, and</span></span><br><span class="line"><span class="comment"> *    reads the first sector of the boot device(e.g., hard-drive)</span></span><br><span class="line"><span class="comment"> *    into memory and jumps to it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * Assuming this boot loader is stored in the first sector of the</span></span><br><span class="line"><span class="comment"> *    hard-drive, this code takes over...</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * control starts in boot.S -- which sets up protected mode,</span></span><br><span class="line"><span class="comment"> *    and a stack so C code then run, then calls bootmain()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * bootmain() in this file takes over, reads in the kernel and jumps to it.</span></span><br><span class="line"><span class="comment"> **********************************************************************/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Loading-the-Kernel"><a href="#Loading-the-Kernel" class="headerlink" title="Loading the Kernel"></a>Loading the Kernel</h3><h4 id="What-ELF-is"><a href="#What-ELF-is" class="headerlink" title="What ELF is"></a>What ELF is</h4><p>To make sense out of <code>boot/main.c</code> you’ll need to know what an ELF binary is.</p>
<p> When you compile and link a C program such as the JOS kernel, the compiler transforms each C source (‘<code>.c</code>‘) file into an <em>object</em> (‘<code>.o</code>‘) file containing assembly language instructions encoded in the binary format expected by the hardware. The linker then combines all of the compiled object files into a single <em>binary image</em> such as <code>obj/kern/kernel</code>, which in this case is a binary in the ELF format, which stands for “Executable and Linkable Format”.</p>
<p>An ELF binary starts with a fixed-length <em>ELF header</em>, followed by a variable-length <em>program header</em> listing each of the program sections to be loaded. The C definitions for these ELF headers are in <code>inc/elf.h</code>. The program sections we’re interested in are:</p>
<ul>
<li><code>.text</code>: The program’s executable instructions.</li>
<li><code>.rodata</code>: Read-only data, such as ASCII string constants produced by the C compiler. (We will not bother setting up the hardware to prohibit writing, however.)</li>
<li><code>.data</code>: The data section holds the program’s initialized data, such as global variables declared with initializers like <code>int x = 5;</code>.</li>
</ul>
<p>When the linker computes the memory layout of a program, it reserves space for <em>uninitialized</em> global variables, such as <code>int x;</code>, in a section called <code>.bss</code> that immediately follows <code>.data</code> in memory. C requires that “uninitialized” global variables start with a value of zero. Thus there is no need to store contents for <code>.bss</code> in the ELF binary; instead, the linker records just the address and size of the <code>.bss</code> section. The loader or the program itself must arrange to zero the <code>.bss</code> section.</p>
<p>Examine the full list of the names, sizes, and link addresses of all the sections in the kernel executable by typing:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;objdump -h obj/kern/kernel</span><br><span class="line">obj/kern/kernel:	file format elf32-i386</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size     VMA      LMA      Type</span><br><span class="line">  0               00000000 00000000 00000000</span><br><span class="line">  1 .text         0000178e f0100000 00100000 TEXT</span><br><span class="line">  2 .rodata       00000704 f01017a0 001017a0 DATA</span><br><span class="line">  3 .stab         000044e9 f0101ea4 00101ea4 DATA</span><br><span class="line">  4 .stabstr      00008c54 f010638d 0010638d</span><br><span class="line">  5 .data         0000a300 f010f000 0010f000 DATA</span><br><span class="line">  6 .bss          00000648 f0119300 00119300 DATA</span><br><span class="line">  7 .comment      00000011 00000000 00000000</span><br><span class="line">  8 .shstrtab     0000004c 00000000 00000000</span><br><span class="line">  9 .symtab       00000650 00000000 00000000</span><br><span class="line"> 10 .strtab       00000369 00000000 00000000</span><br></pre></td></tr></table></figure>

<p>Take particular note of the “VMA” (or <em>link address</em>) and the “LMA” (or <em>load address</em>) of the <code>.text</code> section. The load address of a section is the memory address at which that section should be loaded into memory. Typically, the link and load addresses are the same. </p>
<p>The boot loader uses the ELF <em>program headers</em> to decide how to load the sections. The program headers specify which parts of the ELF object to load into memory and the destination address each should occupy. You can inspect the program headers by typing:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -x obj/kern/kernel</span><br></pre></td></tr></table></figure>

<p>The program headers are then listed under “Program Headers” in the output of objdump. The areas of the ELF object that need to be loaded into memory are those that are marked as “LOAD”. Other information for each program header is given, such as the virtual address (“vaddr”), the physical address (“paddr”), and the size of the loaded area (“memsz” and “filesz”).</p>
<p>Back in boot&#x2F;main.c, the <code>ph-&gt;p_pa</code> field of each program header contains the segment’s destination physical address (in this case, <strong>it really is a physical address</strong>, though the ELF specification is vague on the actual meaning of this field).</p>
<p>The BIOS loads the boot sector into memory starting at address 0x7c00, so this is the boot sector’s load address. This is also where the boot sector executes from, so this is also its link address. We set the link address by passing <code>-Ttext 0x7C00</code> to the linker in <code>boot/Makefrag</code>, so the linker will produce the correct memory addresses in the generated code.</p>
<p>Look back at the load and link addresses for the kernel. Unlike the boot loader, these two addresses aren’t the same: <strong>the kernel is telling the boot loader to load it into memory at a low address (0x00100000), but it expects to execute from a high address.</strong> We’ll dig in to how we make this work in the next section. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;objdump -x obj/kern/kernel</span><br><span class="line"></span><br><span class="line">obj/kern/kernel:	file format elf32-i386</span><br><span class="line"></span><br><span class="line">architecture: i386</span><br><span class="line">start address: 0x0010000c</span><br><span class="line"></span><br><span class="line">Program Header:</span><br><span class="line">    LOAD off    0x00001000 vaddr 0xf0100000 paddr 0x00100000 align 2**12</span><br><span class="line">         filesz 0x0000efe1 memsz 0x0000efe1 flags r-x</span><br><span class="line">    LOAD off    0x00010000 vaddr 0xf010f000 paddr 0x0010f000 align 2**12</span><br><span class="line">         filesz 0x0000a948 memsz 0x0000a948 flags rw-</span><br></pre></td></tr></table></figure>

<p>Besides the section information, there is one more field in the ELF header that is important to us, named <code>e_entry</code>. This field holds the link address of the <em>entry point</em> in the program: the memory address in the program’s text section at which the program should begin executing. You can see the entry point:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;objdump -f obj/kern/kernel  </span><br><span class="line"></span><br><span class="line">obj/kern/kernel:	file format elf32-i386</span><br><span class="line"></span><br><span class="line">architecture: i386</span><br><span class="line">start address: 0x0010000c</span><br></pre></td></tr></table></figure>

<p>You should now be able to understand the minimal ELF loader in <code>boot/main.c</code>. It reads each section of the kernel from disk into memory at the section’s load address and then jumps to the kernel’s entry point.</p>
<h2 id="Part3-The-Kernel"><a href="#Part3-The-Kernel" class="headerlink" title="Part3:The Kernel"></a>Part3:The Kernel</h2><p>Like the boot loader, the kernel begins with some assembly language code that sets things up so that C language code can execute properly.</p>
<h3 id="Using-virtual-memory-to-work-around-position-dependence"><a href="#Using-virtual-memory-to-work-around-position-dependence" class="headerlink" title="Using virtual memory to work around position dependence"></a>Using virtual memory to work around position dependence</h3><p>When you inspected the boot loader’s link and load addresses above, they matched perfectly, but there was a (rather large) disparity between the <em>kernel’s</em> link address (as printed by objdump) and its load address. Go back and check both and make sure you can see what we’re talking about. (Linking the kernel is more complicated than the boot loader, so the link and load addresses are at the top of <code>kern/kernel.ld</code>.)</p>
<p>Operating system kernels often like to be linked and run at very high <em>virtual address</em>, such as 0xf0100000, in order to leave the lower part of the processor’s virtual address space for user programs to use. The reason for this arrangement will become clearer in the next lab.</p>
<p>Many machines don’t have any physical memory at address 0xf0100000, so we can’t count on being able to store the kernel there. Instead, we will use the processor’s memory management hardware to map virtual address 0xf0100000 (the link address at which the kernel code <em>expects</em> to run) to physical address 0x00100000 (where the boot loader loaded the kernel into physical memory). This way, although the kernel’s virtual address is high enough to leave plenty of address space for user processes, it will be loaded in physical memory at the 1MB point in the PC’s RAM, just above the BIOS ROM. This approach requires that the PC have at least a few megabytes of physical memory (so that physical address 0x00100000 works), but this is likely to be true of any PC built after about 1990.</p>
<p>In fact, in the next lab, we will map the <em>entire</em> bottom 256MB of the PC’s physical address space, from physical addresses 0x00000000 through 0x0fffffff, to virtual addresses 0xf0000000 through 0xffffffff respectively. You should now see why JOS can only use the first 256MB of physical memory.</p>
<p>For now, we’ll just map the first <strong>4MB</strong> of physical memory, which will be enough to get us up and running. We do this using the hand-written, statically-initialized page directory and page table in <code>kern/entrypgdir.c</code>. For now, you don’t have to understand the details of how this works, just the effect that it accomplishes. Up until <code>kern/entry.S</code> sets the <code>CR0_PG</code> flag, memory references are treated as physical addresses (<strong>strictly speaking, they’re linear addresses</strong>, but boot&#x2F;boot.S set up an identity mapping from linear addresses to physical addresses and we’re never going to change that). </p>
<p>Once <code>CR0_PG</code> is set, memory references are virtual addresses that get translated by the virtual memory hardware to physical addresses.</p>
<p> <code>entry_pgdir</code> translates virtual addresses in the range 0xf0000000 through 0xf0400000 to physical addresses 0x00000000 through 0x00400000, as well as virtual addresses 0x00000000 through 0x00400000 to physical addresses 0x00000000 through 0x00400000. Any virtual address that is not in one of these two ranges will cause a hardware exception which, since we haven’t set up interrupt handling yet, will cause QEMU to dump the machine state and exit (or endlessly reboot if you aren’t using the 6.828-patched version of QEMU).</p>
<blockquote>
<p>From the beginning to the present, We never turned on the paging(CR0_PG flag). So that’s why we say Linear address &#x3D; Physical address.</p>
</blockquote>
<h3 id="Formatted-Printing-to-the-Console"><a href="#Formatted-Printing-to-the-Console" class="headerlink" title="Formatted Printing to the Console"></a>Formatted Printing to the Console</h3><p>Most people take functions like <code>printf()</code> for granted, sometimes even thinking of them as “primitives” of the C language. But in an OS kernel, we have to implement all I&#x2F;O ourselves.</p>
<p>Read through <code>kern/printf.c</code>, <code>lib/printfmt.c</code>, and <code>kern/console.c</code>, and make sure you understand their relationship. It will become clear in later labs why <code>printfmt.c</code> is located in the separate <code>lib</code> directory.</p>
<blockquote>
<p>It’s time to write a printf function by myself…</p>
</blockquote>
<h3 id="The-Stack"><a href="#The-Stack" class="headerlink" title="The Stack"></a>The Stack</h3><p>In the final exercise of this lab, we will explore in more detail the way the C language uses the stack on the x86, and in the process write a useful new kernel monitor function that prints a <em>backtrace</em> of the stack: a list of the saved Instruction Pointer (IP) values from the nested <code>call</code> instructions that led to the current point of execution.</p>
<p>The x86 stack pointer (<code>esp</code> register) points to the lowest location on the stack that is <strong>currently in use</strong>. Everything <em>below</em> that location in the region reserved for the stack is free. Pushing a value onto the stack involves decreasing the stack pointer and then writing the value to the place the stack pointer points to. Popping a value from the stack involves reading the value the stack pointer points to and then increasing the stack pointer. In 32-bit mode, the stack can only hold 32-bit values, and esp is always divisible by four. Various x86 instructions, such as <code>call</code>, are “hard-wired” to use the stack pointer register.</p>
<p>The <code>ebp</code> (base pointer) register, in contrast, is associated with the stack primarily by software convention. On entry to a C function, the function’s <em>prologue</em> code normally saves the previous function’s base pointer by pushing it onto the stack, and then copies the current <code>esp</code> value into <code>ebp</code> for the duration of the function. If all the functions in a program obey this convention, then at any given point during the program’s execution, it is possible to trace back through the stack by following the chain of saved <code>ebp</code> pointers and determining exactly what nested sequence of function calls caused this particular point in the program to be reached. This capability can be particularly useful, for example, when a particular function causes an <code>assert</code> failure or <code>panic</code> because bad arguments were passed to it, but you aren’t sure <em>who</em> passed the bad arguments. A stack backtrace lets you find the offending function.</p>
<h4 id="Trying-to-write-a-backtrace"><a href="#Trying-to-write-a-backtrace" class="headerlink" title="Trying to write a backtrace"></a>Trying to write a backtrace</h4><p>The above exercise(Exercise 10 ) should give you the information you need to implement a stack backtrace function, which you should call <code>mon_backtrace()</code>. A prototype for this function is already waiting for you in <code>kern/monitor.c</code>. You can do it entirely in C, but you may find the <code>read_ebp()</code> function in <code>inc/x86.h</code> useful. You’ll also have to hook this new function into the kernel monitor’s command list so that it can be invoked interactively by the user.</p>
<p>The backtrace function should display a listing of function call frames in the following format:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stack backtrace:</span><br><span class="line">  ebp f0109e58  eip f0100a62  args 00000001 f0109e80 f0109e98 f0100ed2 00000031</span><br><span class="line">  ebp f0109ed8  eip f01000d6  args 00000000 00000000 f0100058 f0109f28 00000061</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>Each line contains an <code>ebp</code>, <code>eip</code>, and <code>args</code>. The <code>ebp</code> value indicates the base pointer into the stack used by that function: i.e., the position of the stack pointer just after the function was entered and the function prologue code set up the base pointer. The listed <code>eip</code> value is the function’s <em>return instruction pointer</em>: the instruction address to which control will return when the function returns. The return instruction pointer typically points to the instruction after the <code>call</code> instruction (why?). Finally, the five hex values listed after <code>args</code> are the first five arguments to the function in question, which would have been pushed on the stack just before the function was called. If the function was called with fewer than five arguments, of course, then not all five of these values will be useful. (Why can’t the backtrace code detect how many arguments there actually are? How could this limitation be fixed?)</p>
<p>The first line printed reflects the <em>currently executing</em> function, namely <code>mon_backtrace</code> itself, the second line reflects the function that called <code>mon_backtrace</code>, the third line reflects the function that called that one, and so on. You should print <em>all</em> the outstanding stack frames. By studying <code>kern/entry.S</code> you’ll find that there is an easy way to tell when to stop.</p>
<p>Here are a few specific points you read about in K&amp;R Chapter 5 that are worth remembering for the following exercise and for future labs.</p>
<ul>
<li>If <code>int *p = (int*)100</code>, then <code>(int)p + 1</code> and <code>(int)(p + 1)</code> are different numbers: the first is <code>101</code> but the second is <code>104</code>. When adding an integer to a pointer, as in the second case, the integer is implicitly multiplied by the size of the object the pointer points to.</li>
<li><code>p[i]</code> is defined to be the same as <code>*(p+i)</code>, referring to the i’th object in the memory pointed to by p. The above rule for addition helps this definition work when the objects are larger than one byte.</li>
<li><code>&amp;p[i]</code> is the same as <code>(p+i)</code>, yielding the address of the i’th object in the memory pointed to by p.</li>
</ul>
<p>Although most C programs never need to cast between pointers and integers, operating systems frequently do. Whenever you see an addition involving a memory address, ask yourself whether it is an integer addition or pointer addition and make sure the value being added is appropriately multiplied or not.</p>
<h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><blockquote>
<p><strong>Exercise 1.</strong> Familiarize yourself with the assembly language materials available on <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/reference.html">the 6.828 reference page</a>. You don’t have to read them now, but you’ll almost certainly want to refer to some of this material when reading and writing x86 assembly.</p>
<p>We do recommend reading the section “The Syntax” in <a target="_blank" rel="noopener" href="http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html">Brennan’s Guide to Inline Assembly</a>. It gives a good (and quite brief) description of the AT&amp;T assembly syntax we’ll be using with the GNU assembler in JOS.</p>
</blockquote>
<p>So we will be using AT&amp;T assembly syntax, be sure to get familiar with it.</p>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><blockquote>
<p><strong>Exercise 2.</strong> Use GDB’s si (Step Instruction) command to trace into the ROM BIOS for a few more instructions, and try to guess what it might be doing. You might want to look at <a target="_blank" rel="noopener" href="http://web.archive.org/web/20040404164813/members.iweb.net.au/~pstorr/pcbook/book2/book2.htm">Phil Storrs I&#x2F;O Ports Description</a>, as well as other materials on the <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/reference.html">6.828 reference materials page</a>. No need to figure out all the details - just the general idea of what the BIOS is doing first.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 0xffff0: ljmp $0xf000, $0xe05b  </span><br></pre></td></tr></table></figure>

<p>First jump into a lower space cuz there’s only 16Bytes left, not enough for BIOS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 0xfe05b: cmpl $0x0, $cs:0x6ac8   </span><br><span class="line">3 0xfe062: jne 0xfd2e1        </span><br></pre></td></tr></table></figure>

<p>From this post on StackOverflow</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/59479227/why-bios-need-to-compare-a-value-in-seemly-randomized-address-to-zero-in-the-s">assembly - Why BIOS need to compare a value in (seemly) randomized address to zero in the second instruction? - Stack Overflow</a></p>
<p>That magic number seems  to be a flag to check whether the system has been resumed&#x2F;rebooted.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 0xfe066: xor %dx, %dx               </span><br><span class="line">5 0xfe068: mov %dx, %ss    </span><br></pre></td></tr></table></figure>

<p>Clear register %dx and %ss</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">6 0xfe06a: mov $0x7000, %esp</span><br><span class="line">7 0xfe070: mov $0xf34d2,%edx</span><br><span class="line">8 0xfe076: jmp 0xfd15c</span><br><span class="line">9 0xfd15c: mov %eax, %ecx</span><br></pre></td></tr></table></figure>

<p>Set stack segment from 0x0 to 0x7000 (stack top), as well as some other registers.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">10 0xfd15f: cli                        </span><br><span class="line">11 0xfd160: cld            </span><br><span class="line">12 0xfd161: mov $0x8f, %eax</span><br><span class="line"># Here to disable Maskable Hardware interrupts</span><br><span class="line"></span><br><span class="line">13 0xfd167: out %al, $0x70           </span><br><span class="line">14 0xfd169: in $0x71, %al</span><br><span class="line"># And disable Non-maskable Hardware interrupts</span><br><span class="line"></span><br><span class="line">#To prevent from being interrupted</span><br></pre></td></tr></table></figure>

<p>The #10 instruction <code>cli</code> above is to disable interrupts, but how it works?</p>
<p>Interrupt is divided into <code>Hardware</code> and <code>Software</code> ones. For <code>Hardware interrupts</code>, there are <code>maskable</code> and <code>non-maskable</code> ones.</p>
<p>On the FLAGS register of the CPU, bit 9 is IF (Interrupt flag),  who determines whether or not the CPU will respond immediately to <strong>maskable hardware</strong> interrupts.</p>
<p>The instruction <code>cli</code> is to set IF to <code>0</code>  , so we can disable the <strong>maskable hardware</strong> interrupts. Instead, the instruction <code>sti</code> is to set IF to <code>1</code>, namely enable it.</p>
<p>But as you see, non-maskable hardware interrupts <strong>can still be disabled</strong> at #13 , Why?</p>
<blockquote>
<p>From <a target="_blank" rel="noopener" href="https://wiki.osdev.org/Non_Maskable_Interrupt">Non Maskable Interrupt - OSDev Wiki</a>and <a target="_blank" rel="noopener" href="https://bochs.sourceforge.io/techspec/PORTS.LST">https://bochs.sourceforge.io/techspec/PORTS.LST</a></p>
<p>We can know that the MSB of 0x70  is to control the NMI(Non Maskable Interrupt) and it’s shared with CMOS  RAM index</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0070	w	CMOS RAM index register port (ISA, EISA)</span><br><span class="line">		 bit 7	 = 1  NMI disabled</span><br><span class="line">			 = 0  NMI enabled</span><br><span class="line">		 bit 6-0      CMOS RAM index (64 bytes, sometimes 128 bytes)</span><br><span class="line"></span><br><span class="line">		any write to 0070 should be followed by an action to 0071</span><br><span class="line">		or the RTC wil be left in an unknown state.</span><br></pre></td></tr></table></figure>

<p>From OSDev Wiki, you can disable NMI like this</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">NMI_disable</span><span class="params">()</span> &#123;</span><br><span class="line">  outb(<span class="number">0x70</span>, inb(<span class="number">0x70</span>) | <span class="number">0x80</span>);</span><br><span class="line">  inb(<span class="number">0x71</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So you read 0x70  using <code>inb</code> , and you get the binary value of it. Then make a Bool <code>OR</code> calculation:</p>
<table>
<thead>
<tr>
<th>var</th>
<th>MSB</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>LSB</th>
</tr>
</thead>
<tbody><tr>
<td>From inb()</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>0x80</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>Result</td>
<td>1</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
</tr>
</tbody></table>
<p>Then you write the result to 0x70 again, whose MSB must be 1. So the NMI is now disabled.</p>
<p>Vice versa, when enabling</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">NMI_enable</span><span class="params">()</span> &#123;</span><br><span class="line">  outb(<span class="number">0x70</span>, inb(<span class="number">0x70</span>) &amp; <span class="number">0x7F</span>);</span><br><span class="line">  inb(<span class="number">0x71</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The MSB of the result must be 0, so NMI will be enabled.</p>
</blockquote>
<p>Let’s use GDB to set a breakpoint before the <code>out</code> instruction executes</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0xfd167</span><br><span class="line">Breakpoint 1 at 0xfd167</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Program received signal SIGTRAP, Trace/breakpoint trap.</span><br><span class="line">[f000:d167]    0xfd167:	out    %al,$0x70</span><br><span class="line">0x0000d167 in ?? ()</span><br><span class="line">(gdb) info register al</span><br><span class="line">al             0x8f	-113</span><br></pre></td></tr></table></figure>

<p>Now <code>%al</code> is <code>0x8f</code> or<code>1000 1111</code> and its MSB is <code>1</code> so NMI will be disabled after this instruction.</p>
<p>Cuz the reference mentioned:</p>
<blockquote>
<p>any write to 0070 should be followed by an action to 0071<br>or the RTC wil be left in an unknown state</p>
</blockquote>
<p>That’s why next instruction(#14) is <code>0xfd169: in $0x71, %al</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">15 0xfd16b: in $0x92, %al</span><br><span class="line">16 0xfd16d: or $0x2, %al</span><br><span class="line">17 0xfd16f: out %al, $0x92</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0092	r/w	PS/2 system control port A  (port B is at 0061)</span><br><span class="line">		 bit 7-6   any bit set to 1 turns activity light on</span><br><span class="line">		 bit 5	   reserved</span><br><span class="line">		 bit 4 = 1 watchdog timout occurred </span><br><span class="line">		 bit 3 = 0 RTC/CMOS security lock (on password area) unlocked</span><br><span class="line">		       = 1 CMOS locked (done by POST)</span><br><span class="line">		 bit 2	   reserved</span><br><span class="line">		 bit 1 = 1 indicates A20 active</span><br><span class="line">		 bit 0 = 0 system reset or write</span><br><span class="line">			 1 pulse alternate reset pin (alternate CPU reset)</span><br></pre></td></tr></table></figure>

<p>Bit 1 of 0x92 is to control A20 Line, 1 indicates active</p>
</blockquote>
<p>This is to enable A20 Line in BIOS, maybe to test the memory.</p>
<p>Just like disabling NMI, bit #1 of the result must be <code>1</code> . </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">18 0xfd171: lidtw %cs:0x6ab8       </span><br></pre></td></tr></table></figure>

<p>Load <a target="_blank" rel="noopener" href="https://wiki.osdev.org/Interrupt_Descriptor_Table">Interrupt Descriptor Table</a> from <code>0xF000 *16 + 0x6AB8</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">19 0xfd177: lgdtw %cs:0x6a74       </span><br></pre></td></tr></table></figure>

<p>Load the GDTR (<a target="_blank" rel="noopener" href="https://wiki.osdev.org/Global_Descriptor_Table">Global Descriptor Table</a>), a 48-bit register that includes two parts, the base address and the boundary of the global descriptor table.</p>
<ul>
<li>The global descriptor table is used to save descriptors of each segment, such as CS.</li>
<li>Each descriptor takes 64 bits, detailed bits assignment see below:</li>
<li>The <code>lgdt</code> instruction loads 6 bytes starting from <code>%cs:0x6a74</code> to GDTR.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">20 0xfd17d: mov %cr0, %eax</span><br><span class="line">21 0xfd180: or $0x1, %eax</span><br><span class="line">22 0xfd184: mov %eax, %cr0   </span><br></pre></td></tr></table></figure>

<ul>
<li><code>CR0</code> is a 32-bit control register, whose first bit (bit 0) is the <code>Protection Enable</code> bit.</li>
<li>The above three lines set the PE bit to be 1, to enable the protected mode.</li>
<li><strong>BUT WHY ? Enable protected mode in BIOS?</strong> </li>
<li>AND It seems protected mode isn’t activated after #22</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">23 0xfd187: ljmpl $0x8, $0xfd18f</span><br><span class="line">24 0xfd18f: mov $0x10, %eax</span><br><span class="line">25 0xfd194: mov %eax, %ds</span><br><span class="line">26 0xfd196: mov %eax, %es</span><br><span class="line">27 0xfd198: mov %eax, %ss</span><br><span class="line">28 0xfd19a: mov %eax, %fs</span><br><span class="line">29 0xfd19c: mov %eax, %gs</span><br><span class="line">30 0xfd19e: mov %ecx, %eax            </span><br></pre></td></tr></table></figure>

<blockquote>
<p>From <a target="_blank" rel="noopener" href="https://en.wikibooks.org/wiki/X86_Assembly/Global_Descriptor_Table">x86 Assembly&#x2F;Global Descriptor Table - Wikibooks, open books for an open world</a></p>
<p>Note that to complete the process of loading a new GDT, the <strong>segment registers</strong> need to be reloaded. The CS register must be loaded using a far jump</p>
<p>From <a target="_blank" rel="noopener" href="https://docs.oracle.com/cd/E19455-01/806-3773/instructionset-73/index.html">Jump (jmp, ljmp) (IA-32 Assembly Language Reference Manual) (oracle.com)</a></p>
<p>In Real Address Mode or Virtual 8086 mode, the long pointer provides 16 bits for the CS register and 16 or 32 bits for the EIP register. This is how jmp and ljmp work.</p>
</blockquote>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><blockquote>
<p><strong>Exercise 3.</strong> Take a look at the <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/labguide.html">lab tools guide</a>, especially the section on GDB commands. Even if you’re familiar with GDB, this includes some esoteric GDB commands that are useful for OS work.</p>
<p>Set a breakpoint at address 0x7c00, which is where the boot sector will be loaded. Continue execution until that breakpoint. Trace through the code in <code>boot/boot.S</code>, using the source code and the disassembly file <code>obj/boot/boot.asm</code> to keep track of where you are. Also use the <code>x/i</code> command in GDB to disassemble sequences of instructions in the boot loader, and compare the original boot loader source code with both the disassembly in <code>obj/boot/boot.asm</code> and GDB.</p>
<p>Trace into <code>bootmain()</code> in <code>boot/main.c</code>, and then into <code>readsect()</code>. Identify the exact assembly instructions that correspond to each of the statements in <code>readsect()</code>. Trace through the rest of <code>readsect()</code> and back out into <code>bootmain()</code>, and identify the begin and end of the <code>for</code> loop that reads the remaining sectors of the kernel from the disk. Find out what code will run when the loop is finished, set a breakpoint there, and continue to that breakpoint. Then step through the remainder of the boot loader.</p>
</blockquote>
<p>Be able to answer the following questions:</p>
<ul>
<li><p>At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode?</p>
<blockquote>
<p>In <code>boot.S</code>, the <code>ljmp $PROT_MODE_CSEG, $protcseg</code> causes the switch from 16- to 32-bit mode</p>
</blockquote>
</li>
<li><p>What is the <em>last</em> instruction of the boot loader executed, and what is the <em>first</em> instruction of the kernel it just loaded?</p>
<blockquote>
<p>From gdb</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0x7d63</span><br><span class="line">Breakpoint 2 at 0x7d63</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">The target architecture is assumed to be i386</span><br><span class="line">=&gt; 0x7d63:	call   *0x10018</span><br><span class="line"></span><br><span class="line">Breakpoint 2, 0x00007d63 in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0x10000c:	movw   $0x1234,0x472</span><br><span class="line">0x0010000c in ?? ()</span><br></pre></td></tr></table></figure>

<p>The last instruction is </p>
<p>​	call   *0x10018</p>
<p>The first instruction of the kernel is</p>
<p>​    movw    $0x1234,0x472         </p>
</blockquote>
</li>
<li><p><em>Where</em> is the first instruction of the kernel?</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/1x 0x10018</span><br><span class="line">0x10018:	0x0010000c</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?</p>
<blockquote>
<p>TLDR</p>
<p>Boot loader will read from <code>ph-&gt;p_pa</code> to <code>ph-&gt;p_memsz</code>  for every Program Header(or Segment) between which is sectors to be read.</p>
</blockquote>
<blockquote>
<p>Let’s talk about relation between <code>Sections</code> and <code>Segments</code>  first :</p>
<p>References From <code>inc/elf.h</code> and </p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">Executable and Linkable Format - Wikipedia</a> </p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/14361248/whats-the-difference-of-section-and-segment-in-elf-file-format">linux - What’s the difference of section and segment in ELF file format - Stack Overflow</a></p>
<p><a target="_blank" rel="noopener" href="https://dvdhrm.github.io/2020/04/26/inside-specs-elf-segments-and-sections/">Inside Specs: ELF Segments and Sections (dvdhrm.github.io)</a></p>
<p>In simple terms, The difference between segments and sections is thus not what data they contain, but how they index the <em>same data</em>. </p>
<p>A program header table tells the system how to create a process image. Files used to build a process image (execute a program) must have a program header table; relocatable files do not need one.</p>
<p>A section header table contains information describing the file’s sections. Every section has an entry in the table; each entry gives information such as the section name, the section size, and so on. Files used during linking must have a section header table; other object files may or may not have one.</p>
<p>Keep in mind that <strong>the <em>program header table</em> is effectively a <em>segment header table</em></strong>. Therefore, the specification explicitly says that these two data views do not have to be present in a specific file. Depending on the use case, the format allows for <em>only segments</em> or <em>only sections</em>.</p>
<p><img src="https://i.stack.imgur.com/RMV0g.png" alt="enter image description here"></p>
<p>You can use <code>readelf</code> to check the Segment-Sections Mapping relation</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;i386-jos-elf-readelf -l obj/kern/kernel                                                               </span><br><span class="line">Elf file <span class="built_in">type</span> is EXEC (Executable file)</span><br><span class="line">Entry point 0x10000c</span><br><span class="line">There are 2 program headers, starting at offset 52</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align</span><br><span class="line">LOAD           0x001000 0xf0100000 0x00100000 0x0efe1 0x0efe1 R E 0x1000</span><br><span class="line">LOAD           0x010000 0xf010f000 0x0010f000 0x0a948 0x0a948 RW  0x1000</span><br><span class="line"></span><br><span class="line">Section to Segment mapping:</span><br><span class="line">Segment Sections...</span><br><span class="line">00     .text .rodata .stab .stabstr</span><br><span class="line">01     .data .bss</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>Then let’s see how the boot loader load the kernel into memory in <code>boot/main.c</code>:</p>
<p>First load each Segment (or Program Header) and read it using <code>readseg()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// load each program segment (ignores ph flags)</span></span><br><span class="line">ph = (<span class="keyword">struct</span> Proghdr *) ((<span class="type">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line"><span class="keyword">for</span> (; ph &lt; eph; ph++)</span><br><span class="line"><span class="comment">// p_pa is the load address of this segment (as well</span></span><br><span class="line"><span class="comment">// as the physical address)</span></span><br><span class="line">readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br></pre></td></tr></table></figure>

<p>Then for every Segment, load into it into the memory</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read &#x27;count&#x27; bytes at &#x27;offset&#x27; from kernel into physical address &#x27;pa&#x27;.</span></span><br><span class="line"><span class="comment">// Might copy more than asked</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">readseg</span><span class="params">(<span class="type">uint32_t</span> pa, <span class="type">uint32_t</span> count, <span class="type">uint32_t</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> end_pa;</span><br><span class="line">	end_pa = pa + count;</span><br><span class="line">	<span class="comment">// round down to sector boundary</span></span><br><span class="line">	pa &amp;= ~(SECTSIZE - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// translate from bytes to sectors, and kernel starts at sector 1</span></span><br><span class="line">	offset = (offset / SECTSIZE) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If this is too slow, we could read lots of sectors at a time.</span></span><br><span class="line">	<span class="comment">// We&#x27;d write more to memory than asked, but it doesn&#x27;t matter --</span></span><br><span class="line">	<span class="comment">// we load in increasing order.</span></span><br><span class="line">	<span class="keyword">while</span> (pa &lt; end_pa) &#123;</span><br><span class="line">		<span class="comment">// Since we haven&#x27;t enabled paging yet and we&#x27;re using</span></span><br><span class="line">		<span class="comment">// an identity segment mapping (see boot.S), we can</span></span><br><span class="line">		<span class="comment">// use physical addresses directly.  This won&#x27;t be the</span></span><br><span class="line">		<span class="comment">// case once JOS enables the MMU.</span></span><br><span class="line">		readsect((<span class="type">uint8_t</span>*) pa, offset);</span><br><span class="line">		pa += SECTSIZE;</span><br><span class="line">		offset++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>readsect()</code> is a function to read data from sectors on disk to memory</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">readsect</span><span class="params">(<span class="type">void</span> *dst, <span class="type">uint32_t</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// wait for disk to be ready</span></span><br><span class="line">	waitdisk();</span><br><span class="line"></span><br><span class="line">	outb(<span class="number">0x1F2</span>, <span class="number">1</span>);		<span class="comment">// count = 1</span></span><br><span class="line">	outb(<span class="number">0x1F3</span>, offset);</span><br><span class="line">	outb(<span class="number">0x1F4</span>, offset &gt;&gt; <span class="number">8</span>);</span><br><span class="line">	outb(<span class="number">0x1F5</span>, offset &gt;&gt; <span class="number">16</span>);</span><br><span class="line">	outb(<span class="number">0x1F6</span>, (offset &gt;&gt; <span class="number">24</span>) | <span class="number">0xE0</span>);</span><br><span class="line">	outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>);	<span class="comment">// cmd 0x20 - read sectors</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// wait for disk to be ready</span></span><br><span class="line">	waitdisk();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// read a sector</span></span><br><span class="line">	insl(<span class="number">0x1F0</span>, dst, SECTSIZE/<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>insl(uint32_t port, void *dest, int count)</code></p>
<p> will read <code>count</code> <code>dwords</code> from the input port specified by <code>port</code> into the supplied output array <code>dest</code></p>
<p>Note that in GNU Assembly <code>l</code> suffix to denote instructions operating on <code>dword</code> (32-bit sized) data.</p>
<p>So what’s <code>0x1F0</code> stands for? </p>
<p>From <a target="_blank" rel="noopener" href="https://bochs.sourceforge.io/techspec/PORTS.LST">https://bochs.sourceforge.io/techspec/PORTS.LST</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">01F0-01F7 ----	HDC 1	(1st Fixed Disk Controller)   same as 017x (ISA, EISA)</span><br><span class="line"></span><br><span class="line">01F0	r/w	data register</span><br></pre></td></tr></table></figure>

<p>It’s the 1st boot device in the BIOS, you’ve probably seen it before.a</p>
</blockquote>
<h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><blockquote>
<p><strong>Exercise 4.</strong> Read about programming with pointers in C. The best reference for the C language is <em>The C Programming Language</em> by Brian Kernighan and Dennis Ritchie (known as ‘K&amp;R’). We recommend that students purchase this book (here is an <a target="_blank" rel="noopener" href="http://www.amazon.com/C-Programming-Language-2nd/dp/0131103628/sr=8-1/qid=1157812738/ref=pd_bbs_1/104-1502762-1803102?ie=UTF8&s=books">Amazon Link</a>) or find one of <a target="_blank" rel="noopener" href="http://library.mit.edu/F/AI9Y4SJ2L5ELEE2TAQUAAR44XV5RTTQHE47P9MKP5GQDLR9A8X-10422?func=item-global&doc_library=MIT01&doc_number=000355242&year=&volume=&sub_library=">MIT’s 7 copies</a>.</p>
<p>Read 5.1 (Pointers and Addresses) through 5.5 (Character Pointers and Functions) in K&amp;R. Then download the code for <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/labs/lab1/pointers.c">pointers.c</a>, run it, and make sure you understand where all of the printed values come from. In particular, make sure you understand where the pointer addresses in printed lines 1 and 6 come from, how all the values in printed lines 2 through 4 get there, and why the values printed in line 5 are seemingly corrupted.</p>
<p>There are other references on pointers in C (e.g., <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/readings/pointers.pdf">A tutorial by Ted Jensen</a> that cites K&amp;R heavily), though not as strongly recommended.</p>
<p><em>Warning:</em> Unless you are already thoroughly versed in C, do not skip or even skim this reading exercise. If you do not really understand pointers in C, you will suffer untold pain and misery in subsequent labs, and then eventually come to understand them the hard way. Trust us; you don’t want to find out what “the hard way” is.</p>
</blockquote>
<p>Okay, skip.</p>
</li>
</ul>
<h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><blockquote>
<p><strong>Exercise 5.</strong> Trace through the first few instructions of the boot loader again and identify the first instruction that would “break” or otherwise do the wrong thing if you were to get the boot loader’s link address wrong. Then change the link address in <code>boot/Makefrag</code> to something wrong, run make clean, recompile the lab with make, and trace into the boot loader again to see what happens. Don’t forget to change the link address back and make clean again afterward!</p>
</blockquote>
<p>I changed the link address to <code>0x8c00</code> and remade. All address <code>0x7c**</code> in <code>boot.asm</code> are now <code>0x8c**</code> .</p>
<p>It’s very strange that when I set a breakpoint at <code>0x8c00</code>  in gdb and continue , It didn’t work at all. If continue, it will cause a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Triple_fault">Triple fault</a>.</p>
<p>And I set a breakpoint at <code>0x7c00</code>,  it works. Even more ridiculous when I step through, it’s like I haven’t changed anything, the Boot loader is still running at <code>0x7c00</code>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0x7c00</span><br><span class="line">Breakpoint 1 at 0x7c00</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">[   0:7c00] =&gt; 0x7c00:	cli</span><br><span class="line">Breakpoint 1, 0x00007c00 <span class="keyword">in</span> ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">[   0:7c01] =&gt; 0x7c01:	cld</span><br><span class="line">0x00007c01 <span class="keyword">in</span> ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">[   0:7c02] =&gt; 0x7c02:	xor    %ax,%ax</span><br><span class="line">0x00007c02 <span class="keyword">in</span> ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">[   0:7c04] =&gt; 0x7c04:	mov    %ax,%ds</span><br><span class="line">0x00007c04 <span class="keyword">in</span> ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">[   0:7c06] =&gt; 0x7c06:	mov    %ax,%es</span><br><span class="line">0x00007c06 <span class="keyword">in</span> ?? ()</span><br><span class="line">(gdb)</span><br><span class="line">...</span><br><span class="line">(gdb) si</span><br><span class="line">[   0:7c1e] =&gt; 0x7c1e:	lgdtw  -0x739c</span><br><span class="line">0x00007c1e <span class="keyword">in</span> ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">[   0:7c23] =&gt; 0x7c23:	mov    %cr0,%eax</span><br><span class="line">0x00007c23 <span class="keyword">in</span> ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">[   0:7c26] =&gt; 0x7c26:	or     <span class="variable">$0x1</span>,%eax</span><br><span class="line">0x00007c26 <span class="keyword">in</span> ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">[   0:7c2a] =&gt; 0x7c2a:	mov    %eax,%cr0</span><br><span class="line">0x00007c2a <span class="keyword">in</span> ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">[   0:7c2d] =&gt; 0x7c2d:	ljmp   <span class="variable">$0x8</span>,<span class="variable">$0x8c32</span></span><br><span class="line">0x00007c2d <span class="keyword">in</span> ?? ()</span><br></pre></td></tr></table></figure>

<p><strong>I don’t know how the negative address is processed by CPU…it’s wired.</strong></p>
<p>But the GDT is still at <code>0x7c64</code>, Both <code>0x739c</code> and<code>-0x739c</code>are wrong. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb)  x/6xb -0x739c</span><br><span class="line">0xffff8c64:	0x04	0x26	0x67	0x66	0x89	0x07</span><br><span class="line">(gdb)  x/6xb 0x7c64</span><br><span class="line">0x7c64:	0x17	0x00	0x4c	0x8c	0x00	0x00</span><br><span class="line">(gdb)  x/6xb 0x739c</span><br><span class="line">0x739c:	0x00	0x00	0x00	0x00	0x00	0x00</span><br></pre></td></tr></table></figure>

<p>In protected mode, the translation from logical address to physical address is more that <code>CS:IP</code> way, where GDT is a necessary part. GDT also described whether the segment is writeable, that’s how it “protect” memory. <a target="_blank" rel="noopener" href="https://cs.nyu.edu/~mwalfish/classes/ut/s13-cs439/lectures/l12-handout.pdf">More details Here</a></p>
<p>Address translation methods have changed after <code>0x7c2a</code>, but GDT is not ready, so boot loader crashed.</p>
<h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><blockquote>
<p><strong>Exercise 6.</strong> We can examine memory using GDB’s x command. The <a target="_blank" rel="noopener" href="https://sourceware.org/gdb/current/onlinedocs/gdb/Memory.html">GDB manual</a> has full details, but for now, it is enough to know that the command x&#x2F;<em>N</em>x <em>ADDR</em> prints <em><code>N</code></em> words of memory at <em><code>ADDR</code></em>. (Note that both ‘<code>x</code>‘s in the command are lowercase.) <em>Warning</em>: The size of a word is not a universal standard. <strong>In GNU assembly, a word is two bytes</strong> (the ‘w’ in xorw, which stands for word, means 2 bytes).</p>
<p>Reset the machine (exit QEMU&#x2F;GDB and start them again). Examine the 8 words of memory at 0x00100000 at the point the BIOS enters the boot loader, and then again at the point the boot loader enters the kernel. Why are they different? What is there at the second breakpoint? (You do not really need to use QEMU to answer this question. Just think.)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0x7c00</span><br><span class="line">Breakpoint 1 at 0x7c00</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">[   0:7c00] =&gt; 0x7c00:	cli</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x00007c00 in ?? ()</span><br><span class="line">(gdb) x/8x 0x00100000</span><br><span class="line">0x100000:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0x100010:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">(gdb) b *0x10000c</span><br><span class="line">Breakpoint 2 at 0x10000c</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">The target architecture is assumed to be i386</span><br><span class="line">=&gt; 0x10000c:	movw   $0x1234,0x472</span><br><span class="line"></span><br><span class="line">Breakpoint 2, 0x0010000c in ?? ()</span><br><span class="line">(gdb) x/8x 0x00100000</span><br><span class="line">0x100000:	0x1badb002	0x00000000	0xe4524ffe	0x7205c766</span><br><span class="line">0x100010:	0x34000004	0x7000b812	0x220f0011	0xc0200fd8</span><br></pre></td></tr></table></figure>

<p>At breakpoint 1 , it’s null because  nothing hasn’t been done here yet.</p>
<p>At breakpoint 2,  it’s filled with data because kernel was loaded just here from 0x100000.</p>
<p> This is consistent with the disassembly file(X86 is little-endian it’s LSB first in the memory)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># /obj/kern/kernel.asm</span><br><span class="line">.globl entry</span><br><span class="line">entry:</span><br><span class="line">	movw	$0x1234,0x472			# warm boot</span><br><span class="line">f0100000:	02 b0 ad 1b 00 00    	add    0x1bad(%eax),%dh</span><br><span class="line">f0100006:	00 00                	add    %al,(%eax)</span><br><span class="line">f0100008:	fe 4f 52             	decb   0x52(%edi)</span><br><span class="line">f010000b:	e4 66                	in     $0x66,%al</span><br><span class="line"></span><br><span class="line">f010000c &lt;entry&gt;:</span><br><span class="line">f010000c:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472</span><br><span class="line">f0100013:	34 12 </span><br></pre></td></tr></table></figure>

<p>And it’s worth noting that the address growth direction has changed into High→Low in GDB</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint 2, 0x0010000c in ?? ()</span><br><span class="line">(gdb) x/8x 0x00100000</span><br><span class="line">0x100000:	0x1badb002	0x00000000	0xe4524ffe	0x7205c766</span><br><span class="line">0x100010:	0x34000004	0x7000b812	0x220f0011	0xc0200fd8</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0x100015:	mov    $0x117000,%eax</span><br><span class="line">0x00100015 in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0x10001a:	mov    %eax,%cr3</span><br><span class="line">0x0010001a in ?? ()</span><br></pre></td></tr></table></figure>

<h3 id="7"><a href="#7" class="headerlink" title="7"></a>7</h3><blockquote>
<p><strong>Exercise 7.</strong> Use QEMU and GDB to trace into the JOS kernel and stop at the <code>movl %eax, %cr0</code>. Examine memory at 0x00100000 and at 0xf0100000. Now, single step over that instruction using the stepi GDB command. Again, examine memory at 0x00100000 and at 0xf0100000. Make sure you understand what just happened.</p>
<p>What is the first instruction <em>after</em> the new mapping is established that would fail to work properly if the mapping weren’t in place? Comment out the <code>movl %eax, %cr0</code> in <code>kern/entry.S</code>, trace into it, and see if you were right.</p>
</blockquote>
<p>  The instruction mention above is at <code>0x100025</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0x100025</span><br><span class="line">Breakpoint 2 at 0x100025</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">=&gt; 0x100025:	mov    %eax,%cr0</span><br><span class="line"></span><br><span class="line">Breakpoint 2, 0x00100025 in ?? ()</span><br><span class="line">(gdb) x/8x 0x00100000</span><br><span class="line">0x100000:	0x1badb002	0x00000000	0xe4524ffe	0x7205c766</span><br><span class="line">0x100010:	0x34000004	0x7000b812	0x220f0011	0xc0200fd8</span><br><span class="line">(gdb) x/8x 0xf0100000</span><br><span class="line">0xf0100000:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0xf0100010:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0x100028:	mov    $0xf010002f,%eax</span><br><span class="line">0x00100028 in ?? ()</span><br><span class="line">(gdb) x/8x 0x00100000</span><br><span class="line">0x100000:	0x1badb002	0x00000000	0xe4524ffe	0x7205c766</span><br><span class="line">0x100010:	0x34000004	0x7000b812	0x220f0011	0xc0200fd8</span><br><span class="line">(gdb) x/8x 0xf0100000</span><br><span class="line">0xf0100000:	0x1badb002	0x00000000	0xe4524ffe	0x7205c766</span><br><span class="line">0xf0100010:	0x34000004	0x7000b812	0x220f0011	0xc0200fd8</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>

<p>Obviously the memory near <code>0xf0100000</code> was all zero and after turning on paging it’s the same with data near <code>0x00100000</code></p>
<p>Use step through to see what’s next</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0x100020</span><br><span class="line">Breakpoint 1 at 0x100020</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">The target architecture is assumed to be i386</span><br><span class="line">=&gt; 0x100020:	or     $0x80010001,%eax</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x00100020 in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0x100025:	mov    $0xf010002c,%eax</span><br><span class="line">0x00100025 in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0x10002a:	jmp    *%eax</span><br><span class="line">0x0010002a in ?? ()</span><br><span class="line">(gdb) info reg eax</span><br><span class="line">eax            0xf010002c	-267386836</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0xf010002c:	add    %al,(%eax)</span><br><span class="line">74		movl	$0x0,%ebp			# nuke frame pointer</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>

<p>As you see, after turning on paging, the kernel first jump to the address<code>0xf010002c</code>  from <code>%eax</code> register and it’s just in the mapping range. We have known before that <code>jmp</code> is to change the value of <code>%eip</code> , so it won’t crash the kernel.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info reg eip</span><br><span class="line">eip            0x10002a	0x10002a</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0xf010002c:	add    %al,(%eax)</span><br><span class="line">74		movl	$0x0,%ebp			# nuke frame pointer</span><br><span class="line">(gdb) info reg eip</span><br><span class="line">eip            0xf010002c	0xf010002c</span><br></pre></td></tr></table></figure>

<p>But when you about to execute the instruction on that address, which is illegal, the kernel will crash, even the QEMU crashed too.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">qemu: fatal: Trying to execute code outside RAM or ROM at 0xf010002c</span><br><span class="line">EAX=f010002c EBX=00010074 ECX=00000000 EDX=000000d5</span><br><span class="line">ESI=00010074 EDI=00000000 EBP=00007bf8 ESP=00007bec</span><br><span class="line">EIP=f010002c EFL=00000086 [--S--P-] CPL=0 II=0 A20=1 SMM=0 HLT=0</span><br><span class="line">ES =0010 00000000 ffffffff 00cf9300 DPL=0 DS   [-WA]</span><br><span class="line">CS =0008 00000000 ffffffff 00cf9a00 DPL=0 CS32 [-R-]</span><br><span class="line">SS =0010 00000000 ffffffff 00cf9300 DPL=0 DS   [-WA]</span><br><span class="line">DS =0010 00000000 ffffffff 00cf9300 DPL=0 DS   [-WA]</span><br><span class="line">FS =0010 00000000 ffffffff 00cf9300 DPL=0 DS   [-WA]</span><br><span class="line">GS =0010 00000000 ffffffff 00cf9300 DPL=0 DS   [-WA]</span><br><span class="line">LDT=0000 00000000 0000ffff 00008200 DPL=0 LDT</span><br><span class="line">TR =0000 00000000 0000ffff 00008b00 DPL=0 TSS32-busy</span><br><span class="line">GDT=     00007c4c 00000017</span><br><span class="line">IDT=     00000000 000003ff</span><br><span class="line">CR0=00000011 CR2=00000000 CR3=00117000 CR4=00000000</span><br><span class="line">DR0=00000000 DR1=00000000 DR2=00000000 DR3=00000000</span><br><span class="line">DR6=ffff0ff0 DR7=00000400</span><br><span class="line">CCS=00000084 CCD=80010011 CCO=EFLAGS</span><br><span class="line">EFER=0000000000000000</span><br><span class="line">FCW=037f FSW=0000 [ST=0] FTW=00 MXCSR=00001f80</span><br><span class="line">FPR0=0000000000000000 0000 FPR1=0000000000000000 0000</span><br><span class="line">FPR2=0000000000000000 0000 FPR3=0000000000000000 0000</span><br><span class="line">FPR4=0000000000000000 0000 FPR5=0000000000000000 0000</span><br><span class="line">FPR6=0000000000000000 0000 FPR7=0000000000000000 0000</span><br><span class="line">XMM00=00000000000000000000000000000000 XMM01=00000000000000000000000000000000</span><br><span class="line">XMM02=00000000000000000000000000000000 XMM03=00000000000000000000000000000000</span><br><span class="line">XMM04=00000000000000000000000000000000 XMM05=00000000000000000000000000000000</span><br><span class="line">XMM06=00000000000000000000000000000000 XMM07=00000000000000000000000000000000</span><br><span class="line">make: *** [qemu-gdb] Abort trap: 6</span><br></pre></td></tr></table></figure>

<h3 id="8"><a href="#8" class="headerlink" title="8"></a>8</h3><blockquote>
<p><strong>Exercise 8.</strong> We have omitted a small fragment of code - the code necessary to print octal numbers using patterns of the form “%o”. Find and fill in this code fragment.</p>
<p>In <code>lib/printfmt.c</code> , Line 207</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">	<span class="comment">// Replace this with your code.</span></span><br><span class="line">	putch(<span class="string">&#x27;X&#x27;</span>, putdat);</span><br><span class="line">	putch(<span class="string">&#x27;X&#x27;</span>, putdat);</span><br><span class="line">	putch(<span class="string">&#x27;X&#x27;</span>, putdat);</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>to</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">    num = getuint(&amp;ap, lflag);</span><br><span class="line">    base = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">goto</span> number;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Be able to answer the following questions:</p>
<ol>
<li><p>Explain the interface between <code>printf.c</code> and <code>console.c</code>. Specifically, what function does <code>console.c</code> export? How is this function used by <code>printf.c</code>?</p>
<blockquote>
<p>The implementation of cprintf (in printf.c)  is based on the cputchar() function (in console.c), which outputs a character to the console.</p>
</blockquote>
</li>
<li><p>Explain the following from <code>console.c</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">memmove</span><span class="params">(<span class="type">void</span> *dst, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CRT should be Cathode Ray Tube. A material used in early displays</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// if display is full</span></span><br><span class="line"><span class="title function_">if</span> <span class="params">(crt_pos &gt;= CRT_SIZE)</span>&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">// removes the first row </span></span><br><span class="line">  memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="type">uint16_t</span>));</span><br><span class="line">  <span class="comment">// make the last line empty</span></span><br><span class="line">  <span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">    <span class="comment">// BUT WHAT IS THIS MAGIC NUMBER?</span></span><br><span class="line">    crt_buf[i] = <span class="number">0x0700</span> | <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  <span class="comment">// updates the cursor postion</span></span><br><span class="line">  crt_pos -= CRT_COLS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>For the following questions you might wish to consult the notes for Lecture 2. These notes cover GCC’s calling convention on the x86.</p>
</li>
</ol>
<p>  Trace the execution of the following code step-by-step:</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">3</span>, z = <span class="number">4</span>;</span><br><span class="line">cprintf(<span class="string">&quot;x %d, y %x, z %d\n&quot;</span>, x, y, z);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>In the call to <code>cprintf()</code>, to what does <code>fmt</code> point? To what does <code>ap</code> point?</p>
<blockquote>
<p><code>fmt</code> is string literal “x %d, y %x, z %d\n”</p>
<p><code>ap</code> is pointing the first var, namely <code>x</code></p>
</blockquote>
</li>
<li><p>List (in order of execution) each call to <code>cons_putc</code>, <code>va_arg</code>, and <code>vcprintf</code>. For <code>cons_putc</code>, list its argument as well. For <code>va_arg</code>, list what <code>ap</code> points to before and after the call. For <code>vcprintf</code> list the values of its two arguments.</p>
<blockquote>
<p>SKIP</p>
</blockquote>
</li>
</ul>
<ol start="4">
<li><p>Run the following code.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0x00646c72</span>;</span><br><span class="line">cprintf(<span class="string">&quot;H%x Wo%s&quot;</span>, <span class="number">57616</span>, &amp;i);</span><br></pre></td></tr></table></figure>

<p>What is the output? Explain how this output is arrived at in the step-by-step manner of the previous exercise. <a target="_blank" rel="noopener" href="http://web.cs.mun.ca/~michael/c/ascii-table.html">Here’s an ASCII table</a> that maps bytes to characters.</p>
<blockquote>
<p>Output</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">He110 World</span><br></pre></td></tr></table></figure>

<p>From kernel.asm, we can know that <code>I</code> was stored in memory by <code>LSB-First</code> or <code>Little-endian</code> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unsigned int i = 0x00646c72;</span><br><span class="line">f0100046:	c7 45 f4 72 6c 64 00 	movl   $0x646c72,-0xc(%ebp)</span><br><span class="line">...</span><br><span class="line">f0100063:	e8 a6 08 00 00       	call   f010090e &lt;cprintf&gt;</span><br></pre></td></tr></table></figure>

<p>Let’s set a breakpoint at <code>0xf0100063</code> and check the value in memory</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0xf0100063</span><br><span class="line">Breakpoint 1 at 0xf0100063: file kern/init.c, line 14.</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">The target architecture is assumed to be i386</span><br><span class="line">=&gt; 0xf0100063 &lt;exercise8+35&gt;:	call   0xf010090e &lt;cprintf&gt;</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0xf0100063 in exercise8 () at kern/init.c:14</span><br><span class="line">14	cprintf(&quot;H%x Wo%s&quot;, 57616, &amp;i);</span><br><span class="line"></span><br><span class="line">(gdb) x/b 0xf0100049</span><br><span class="line">0xf0100049 &lt;exercise8+9&gt;:	114 &#x27;r&#x27;</span><br><span class="line">(gdb) x/b 0xf010004a</span><br><span class="line">0xf010004a &lt;exercise8+10&gt;:	108 &#x27;l&#x27;</span><br><span class="line">(gdb) x/b 0xf010004b</span><br><span class="line">0xf010004b &lt;exercise8+11&gt;:	100 &#x27;d&#x27;</span><br></pre></td></tr></table></figure>

<p>Just as expected.</p>
<p><code>57616</code> in decimal is <code>e110</code> in hex, which is easy to understand.</p>
</blockquote>
<p>The output depends on that fact that the x86 is little-endian. If the x86 were instead big-endian what would you set <code>i</code> to in order to yield the same output? Would you need to change <code>57616</code> to a different value?</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unsigned int little = 0x646c72;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> big = <span class="number">0x726c64</span>;</span><br><span class="line"><span class="comment">// Now the output should be</span></span><br><span class="line"><span class="comment">// He110 Wodlr        on Little-endian PCs</span></span><br></pre></td></tr></table></figure>

<p>No need to change 57616</p>
<p><a target="_blank" rel="noopener" href="http://www.webopedia.com/TERM/b/big_endian.html">Here’s a description of little- and big-endian</a> and <a target="_blank" rel="noopener" href="http://www.networksorcery.com/enp/ien/ien137.txt">a more whimsical description</a>.</p>
</blockquote>
</li>
<li><p>In the following code, what is going to be printed after <code>&#39;y=&#39;</code>? (note: the answer is not a specific value.) Why does this happen?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cprintf(<span class="string">&quot;x=%d y=%d&quot;</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>See the kernel.asm</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">f0100040:	55                   	push   %ebp</span><br><span class="line">f0100041:	89 e5                	mov    %esp,%ebp</span><br><span class="line">f0100043:	83 ec 18             	sub    $0x18,%esp</span><br><span class="line"> cprintf(&quot;x=%d y=%d&quot;, 3);</span><br><span class="line">f0100046:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)</span><br><span class="line">f010004d:	00 </span><br><span class="line">f010004e:	c7 04 24 c0 17 10 f0 	movl   $0xf01017c0,(%esp)</span><br><span class="line">f0100055:	e8 a8 08 00 00       	call   f0100902 &lt;cprintf&gt;</span><br></pre></td></tr></table></figure>

<p><code>0x4(%esp)</code> means<code>ESP+4</code></p>
<p>Move to GDB</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0xf0100055</span><br><span class="line">Breakpoint 1 at 0xf0100055: file kern/init.c, line 13.</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">The target architecture is assumed to be i386</span><br><span class="line">=&gt; 0xf0100055 &lt;exercise8+21&gt;:	call   0xf0100902 &lt;cprintf&gt;</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0xf0100055 in exercise8 () at kern/init.c:13</span><br><span class="line">13	 cprintf(&quot;x=%d y=%d&quot;, 3);</span><br><span class="line"></span><br><span class="line">(gdb) info reg esp</span><br><span class="line">esp            0xf0117fc0	0xf0117fc0</span><br><span class="line">(gdb) x/8d 0xf0117fc0</span><br><span class="line">0xf0117fc0:	6080	-4080	3	0	0	0	116	1</span><br></pre></td></tr></table></figure>

<p>And output is <code>x=3 y=0</code> . It’s obviously that although only 1 argument pushed, <code>cprintf()</code> will continue to find the next value in memory</p>
</li>
<li><p>Let’s say that GCC changed its calling convention so that it pushed arguments on the stack in declaration order, so that the last argument is pushed last. How would you have to change <code>cprintf</code> or its interface so that it would still be possible to pass it a variable number of arguments?</p>
<blockquote>
<p>SKIP.</p>
</blockquote>
</li>
</ol>
<p><em>Challenge</em></p>
<p> Enhance the console to allow text to be printed in different colors. The traditional way to do this is to make it interpret <a target="_blank" rel="noopener" href="http://rrbrandt.dee.ufcg.edu.br/en/docs/ansi/">ANSI escape sequences</a> embedded in the text strings printed to the console, but you may use any mechanism you like. There is plenty of information on <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/reference.html">the 6.828 reference page</a> and elsewhere on the web on programming the VGA display hardware. If you’re feeling really adventurous, you could try switching the VGA hardware into a graphics mode and making the console draw text onto the graphical frame buffer.</p>
<h3 id="9"><a href="#9" class="headerlink" title="9"></a>9</h3><blockquote>
<p><strong>Exercise 9.</strong> Determine where the kernel initializes its stack, and exactly where in memory its stack is located. How does the kernel reserve space for its stack? And at which “end” of this reserved area is the stack pointer initialized to point to?</p>
</blockquote>
<p>The two lines in <code>entry.S</code> below initialize the kernel’s stack:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movl    $0x0,%ebp           </span><br><span class="line">movl    $(bootstacktop),%esp</span><br></pre></td></tr></table></figure>

<p>According to the disassembled file <code>kernel.asm</code>, the stack locates at <code>0xf0117000</code>. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	movl	$0x0,%ebp			# nuke frame pointer</span><br><span class="line">f010002f:	bd 00 00 00 00       	mov    $0x0,%ebp</span><br><span class="line">	movl	$(bootstacktop),%esp</span><br><span class="line">f0100034:	bc 00 70 11 f0       	mov    $0xf0117000,%esp</span><br></pre></td></tr></table></figure>

<p>The stack space is given by <code>.space KSTKSIZE</code> in <code>entry.S</code>.</p>
<p>According to <code>/inc/memlayout.h</code> and <code>inc/mmu.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KSTKSIZE	(8*PGSIZE)   		<span class="comment">// size of a kernel stack</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGSIZE		4096		<span class="comment">// bytes mapped by a page</span></span></span><br></pre></td></tr></table></figure>

<p>We can know that <code>KSTKSIZE</code> &#x3D; 8*4096 &#x3D; 32768 &#x3D; <code>0x8000</code></p>
<p>So stack range from <code>0xf0117000</code> to <code>0xF011F000</code> in Virtual Memory, or <code>0x117000</code> to<code>0x11F000</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EBP ---------------- 0xF011F000  (Bottom)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	       Stack(Virtual Memory Address)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ESP ---------------- 0xf0117000  (Top)</span><br></pre></td></tr></table></figure>

<h3 id="10"><a href="#10" class="headerlink" title="10"></a>10</h3><blockquote>
<p><strong>Exercise 10.</strong> To become familiar with the C calling conventions on the x86, find the address of the <code>test_backtrace</code> function in <code>obj/kern/kernel.asm</code>, set a breakpoint there, and examine what happens each time it gets called after the kernel starts. How many 32-bit words does each recursive nesting level of <code>test_backtrace</code> push on the stack, and what are those words?</p>
</blockquote>
<p>To understand how a stack frame is set up and taken down when a C function call is made, refer to <a target="_blank" rel="noopener" href="https://www.csee.umbc.edu/~chang/cs313.s02/stack.shtml">C Function Call Conventions and the Stack</a>. Each recursive nesting level of <code>test_backtrace</code> pushes 8 32-bit words on the stack. The are the function’s return address, arguments, stack base pointer <code>EBP</code>, etc.</p>
<p>Set a breakpoint at <code>0xf0100040</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0xf0100040</span><br><span class="line">Breakpoint 1 at 0xf0100040: file kern/init.c, line 13.</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">The target architecture is assumed to be i386</span><br><span class="line">=&gt; 0xf0100040 &lt;test_backtrace&gt;:	push   %ebp</span><br><span class="line"></span><br><span class="line">Breakpoint 1, test_backtrace (x=5) at kern/init.c:13</span><br><span class="line">13	&#123;</span><br><span class="line">(gdb) x/8x $esp</span><br><span class="line">//            Return add      (ESP+8)</span><br><span class="line">0xf0116fdc:	0xf01000ea	0x00000005	0x00001aac	0x00000640</span><br><span class="line">0xf0116fec:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">=&gt; 0xf0100040 &lt;test_backtrace&gt;:	push   %ebp</span><br><span class="line"></span><br><span class="line">Breakpoint 1, test_backtrace (x=4) at kern/init.c:13</span><br><span class="line">13	&#123;</span><br><span class="line">(gdb) x/8x $esp   </span><br><span class="line">//            Return add      (ESP+8)</span><br><span class="line">0xf0116fbc:	0xf0100069	0x00000004	0x00000005	0x00000000</span><br><span class="line">0xf0116fcc:	0x00010074	0x00010074	0x00010074	0xf0116ff8(Caller&#x27;s EBP)</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">=&gt; 0xf0100040 &lt;test_backtrace&gt;:	push   %ebp</span><br><span class="line"></span><br><span class="line">Breakpoint 1, test_backtrace (x=3) at kern/init.c:13</span><br><span class="line">13	&#123;</span><br><span class="line">(gdb) x/8x $esp</span><br><span class="line">//            Return add      (ESP+8)</span><br><span class="line">0xf0116f9c:	0xf0100069	0x00000003	0x00000004	0x00000000</span><br><span class="line">0xf0116fac:	0x00000000	0x00000000	0x00000005	0xf0116fd8(Caller&#x27;s EBP)</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">=&gt; 0xf0100040 &lt;test_backtrace&gt;:	push   %ebp</span><br><span class="line"></span><br><span class="line">Breakpoint 1, test_backtrace (x=2) at kern/init.c:13</span><br><span class="line">13	&#123;</span><br><span class="line">(gdb) x/8x $esp</span><br><span class="line">//          Return add      (ESP+8)</span><br><span class="line">0xf0116f7c:	0xf0100069	0x00000002	0x00000003	0xf0116fb8</span><br><span class="line">0xf0116f8c:	0x00000000	0xf0100898	0x00000004	0xf0116fb8(Caller&#x27;s EBP)</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">=&gt; 0xf0100040 &lt;test_backtrace&gt;:	push   %ebp</span><br><span class="line"></span><br><span class="line">Breakpoint 1, test_backtrace (x=1) at kern/init.c:13</span><br><span class="line">13	&#123;</span><br><span class="line">(gdb) x/8x $esp</span><br><span class="line">//           Return add      (ESP+8)</span><br><span class="line">0xf0116f5c:	0xf0100069	0x00000001	0x00000002	0xf0116f98</span><br><span class="line">0xf0116f6c:	0x00000000	0xf0100898	0x00000003	0xf0116f98(Caller&#x27;s EBP)</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">=&gt; 0xf0100040 &lt;test_backtrace&gt;:	push   %ebp</span><br><span class="line"></span><br><span class="line">Breakpoint 1, test_backtrace (x=0) at kern/init.c:13</span><br><span class="line">13	&#123;</span><br><span class="line">(gdb) x/8x $esp</span><br><span class="line">//          Return add   (ESP+8)    (ESP+12)</span><br><span class="line">0xf0116f3c:	0xf0100069	0x00000000	0x00000001	0xf0116f78</span><br><span class="line">0xf0116f4c:	0x00000000	0xf0100898	0x00000002	0xf0116f78(Caller&#x27;s EBP)</span><br></pre></td></tr></table></figure>

<h3 id="11"><a href="#11" class="headerlink" title="11"></a>11</h3><blockquote>
<p><strong>Exercise 11.</strong> Implement the backtrace function as specified above. Use the same format as in the example, since otherwise the grading script will be confused. When you think you have it working right, run make grade to see if its output conforms to what our grading script expects, and fix it if it doesn’t. <em>After</em> you have handed in your Lab 1 code, you are welcome to change the output format of the backtrace function any way you like.</p>
<p>If you use <code>read_ebp()</code>, note that GCC may generate “optimized” code that calls <code>read_ebp()</code> <em>before</em> <code>mon_backtrace()</code>‘s function prologue, which results in an incomplete stack trace (the stack frame of the most recent function call is missing). While we have tried to disable optimizations that cause this reordering, you may want to examine the assembly of <code>mon_backtrace()</code> and make sure the call to <code>read_ebp()</code> is happening after the function prologue.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mon_backtrace</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> ebp = read_ebp();</span><br><span class="line">    cprintf(<span class="string">&quot;Stack backtraces:\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* ebp&#x27;s initial value is set to 0 in kern/entry.S */</span></span><br><span class="line">    <span class="keyword">while</span> (ebp != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* eip and arguments&#x27; addresses can be inferred from ebp */</span></span><br><span class="line">        cprintf(<span class="string">&quot;  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n&quot;</span>, </span><br><span class="line">                ebp, *(<span class="type">uint32_t</span> *)(ebp + <span class="number">4</span>), *(<span class="type">uint32_t</span> *)(ebp + <span class="number">8</span>), *(<span class="type">uint32_t</span> *)(ebp + <span class="number">12</span>),</span><br><span class="line">                *(<span class="type">uint32_t</span> *)(ebp + <span class="number">16</span>), *(<span class="type">uint32_t</span> *)(ebp + <span class="number">20</span>), *(<span class="type">uint32_t</span> *)(ebp + <span class="number">24</span>));</span><br><span class="line">        <span class="comment">/* obtain caller&#x27;s ebp  */</span></span><br><span class="line">        ebp = *(<span class="type">uint32_t</span> *)ebp;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12"><a href="#12" class="headerlink" title="12"></a>12</h3><p>At this point, your backtrace function should give you the addresses of the function callers on the stack that lead to <code>mon_backtrace()</code> being executed. However, in practice you often want to know the function names corresponding to those addresses. For instance, you may want to know which functions could contain a bug that’s causing your kernel to crash.</p>
<p>To help you implement this functionality, we have provided the function <code>debuginfo_eip()</code>, which looks up <code>eip</code> in the symbol table and returns the debugging information for that address. This function is defined in <code>kern/kdebug.c</code>.</p>
<blockquote>
<p><strong>Exercise 12.</strong> Modify your stack backtrace function to display, for each <code>eip</code>, the function name, source file name, and line number corresponding to that <code>eip</code>.</p>
<p>In <code>debuginfo_eip</code>, where do <code>__STAB_*</code> come from? This question has a long answer; to help you to discover the answer, here are some things you might want to do:</p>
<ul>
<li>look in the file <code>kern/kernel.ld</code> for <code>__STAB_*</code></li>
<li>run objdump -h obj&#x2F;kern&#x2F;kernel</li>
<li>run objdump -G obj&#x2F;kern&#x2F;kernel</li>
<li>run gcc -pipe -nostdinc -O2 -fno-builtin -I. -MD -Wall -Wno-format -DJOS_KERNEL -gstabs -c -S kern&#x2F;init.c, and look at init.s.</li>
<li>see if the bootloader loads the symbol table in memory as part of loading the kernel binary</li>
</ul>
<p>Complete the implementation of <code>debuginfo_eip</code> by inserting the call to <code>stab_binsearch</code> to find the line number for an address.</p>
<p>Add a <code>backtrace</code> command to the kernel monitor, and extend your implementation of <code>mon_backtrace</code> to call <code>debuginfo_eip</code> and print a line for each stack frame of the form:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">K&gt; backtrace</span><br><span class="line">Stack backtrace:</span><br><span class="line">  ebp f010ff78  eip f01008ae  args 00000001 f010ff8c 00000000 f0110580 00000000</span><br><span class="line">         kern/monitor.c:143: monitor+106</span><br><span class="line">  ebp f010ffd8  eip f0100193  args 00000000 00001aac 00000660 00000000 00000000</span><br><span class="line">         kern/init.c:49: i386_init+59</span><br><span class="line">  ebp f010fff8  eip f010003d  args 00000000 00000000 0000ffff 10cf9a00 0000ffff</span><br><span class="line">         kern/entry.S:70: &lt;unknown&gt;+0</span><br><span class="line">K&gt; </span><br></pre></td></tr></table></figure>

<p>Each line gives the file name and line within that file of the stack frame’s <code>eip</code>, followed by the name of the function and the offset of the <code>eip</code> from the first instruction of the function (e.g., <code>monitor+106</code> means the return <code>eip</code> is 106 bytes past the beginning of <code>monitor</code>).</p>
<p>Be sure to print the file and function names on a separate line, to avoid confusing the grading script.</p>
<p>Tip: printf format strings provide an easy, albeit obscure, way to print non-null-terminated strings like those in STABS tables. <code>printf(&quot;%.*s&quot;, length, string)</code> prints at most <code>length</code> characters of <code>string</code>. Take a look at the printf man page to find out why this works.</p>
<p>You may find that some functions are missing from the backtrace. For example, you will probably see a call to <code>monitor()</code> but not to <code>runcmd()</code>. This is because the compiler in-lines some function calls. Other optimizations may cause you to see unexpected line numbers. If you get rid of the <code>-O2</code> from <code>GNUMakefile</code>, the backtraces may make more sense (but your kernel will run more slowly).</p>
</blockquote>
<p><code>kdebug.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);</span><br><span class="line"><span class="keyword">if</span> (lline &lt;= rline) &#123;</span><br><span class="line">    info-&gt;eip_line = stabs[lline].n_desc;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Couldn&#x27;t find a line number.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>monitor.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mon_backtrace</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> ebp = read_ebp();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> <span class="title">info</span>;</span></span><br><span class="line">    cprintf(<span class="string">&quot;Stack backtraces:\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* ebp&#x27;s initial value is set to 0 in kern/entry.S */</span></span><br><span class="line">    <span class="keyword">while</span> (ebp != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* eip and arguments&#x27; addresses can be inferred from ebp */</span></span><br><span class="line">        cprintf(<span class="string">&quot;  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n&quot;</span>, </span><br><span class="line">                ebp, *(<span class="type">uint32_t</span> *)(ebp + <span class="number">4</span>), *(<span class="type">uint32_t</span> *)(ebp + <span class="number">8</span>), *(<span class="type">uint32_t</span> *)(ebp + <span class="number">12</span>),</span><br><span class="line">                *(<span class="type">uint32_t</span> *)(ebp + <span class="number">16</span>), *(<span class="type">uint32_t</span> *)(ebp + <span class="number">20</span>), *(<span class="type">uint32_t</span> *)(ebp + <span class="number">24</span>));</span><br><span class="line">        <span class="comment">/* look up eip in the symbol table and obtain more debugging info */</span></span><br><span class="line">        <span class="keyword">if</span> (debuginfo_eip(*(<span class="type">uint32_t</span> *)(ebp + <span class="number">4</span>), &amp;info) == <span class="number">0</span>) &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;         %s:%d: %.*s+%d\n&quot;</span>,</span><br><span class="line">                    info.eip_file, info.eip_line, info.eip_fn_namelen, info.eip_fn_name,</span><br><span class="line">                    *(<span class="type">uint32_t</span> *)(ebp + <span class="number">4</span>) - info.eip_fn_addr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* obtain caller&#x27;s ebp  */</span></span><br><span class="line">        ebp = *(<span class="type">uint32_t</span> *)ebp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Done.</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>6.828-Lab1(old)</p><p><a href="https://bakaft.github.io/2021/10/29/6-828-Lab1/">https://bakaft.github.io/2021/10/29/6-828-Lab1/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>BakaFT</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2021-10-29</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2023-12-28</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/OS/">OS</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/10/29/Disabling-interrupts/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Disabling interrupts</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/10/24/A20-%E5%8E%86%E5%8F%B2%E7%9A%84%E5%A6%A5%E5%8D%8F/"><span class="level-item">A20:历史的妥协</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Lab-1-Booting-a-PC"><span class="level-left"><span class="level-item">1</span><span class="level-item">Lab 1: Booting a PC</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Introduction"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">Introduction</span></span></a></li><li><a class="level is-mobile" href="#Part-1-PC-Bootstrap"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">Part 1: PC Bootstrap</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Getting-Started-with-x86-assembly"><span class="level-left"><span class="level-item">1.2.1</span><span class="level-item">Getting Started with x86 assembly</span></span></a></li><li><a class="level is-mobile" href="#Simulating-the-x86"><span class="level-left"><span class="level-item">1.2.2</span><span class="level-item">Simulating the x86</span></span></a></li><li><a class="level is-mobile" href="#The-PC’s-Physical-Address-Space"><span class="level-left"><span class="level-item">1.2.3</span><span class="level-item">The PC’s Physical Address Space</span></span></a></li><li><a class="level is-mobile" href="#The-ROM-BIOS"><span class="level-left"><span class="level-item">1.2.4</span><span class="level-item">The ROM BIOS</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Part-2-The-Boot-Loader"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">Part 2: The Boot Loader</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Sectors"><span class="level-left"><span class="level-item">1.3.1</span><span class="level-item">Sectors</span></span></a></li><li><a class="level is-mobile" href="#Booting"><span class="level-left"><span class="level-item">1.3.2</span><span class="level-item">Booting</span></span></a></li><li><a class="level is-mobile" href="#Loading-the-Kernel"><span class="level-left"><span class="level-item">1.3.3</span><span class="level-item">Loading the Kernel</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Part3-The-Kernel"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">Part3:The Kernel</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Using-virtual-memory-to-work-around-position-dependence"><span class="level-left"><span class="level-item">1.4.1</span><span class="level-item">Using virtual memory to work around position dependence</span></span></a></li><li><a class="level is-mobile" href="#Formatted-Printing-to-the-Console"><span class="level-left"><span class="level-item">1.4.2</span><span class="level-item">Formatted Printing to the Console</span></span></a></li><li><a class="level is-mobile" href="#The-Stack"><span class="level-left"><span class="level-item">1.4.3</span><span class="level-item">The Stack</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Exercises"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">Exercises</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1"><span class="level-left"><span class="level-item">1.5.1</span><span class="level-item">1</span></span></a></li><li><a class="level is-mobile" href="#2"><span class="level-left"><span class="level-item">1.5.2</span><span class="level-item">2</span></span></a></li><li><a class="level is-mobile" href="#3"><span class="level-left"><span class="level-item">1.5.3</span><span class="level-item">3</span></span></a></li><li><a class="level is-mobile" href="#4"><span class="level-left"><span class="level-item">1.5.4</span><span class="level-item">4</span></span></a></li><li><a class="level is-mobile" href="#5"><span class="level-left"><span class="level-item">1.5.5</span><span class="level-item">5</span></span></a></li><li><a class="level is-mobile" href="#6"><span class="level-left"><span class="level-item">1.5.6</span><span class="level-item">6</span></span></a></li><li><a class="level is-mobile" href="#7"><span class="level-left"><span class="level-item">1.5.7</span><span class="level-item">7</span></span></a></li><li><a class="level is-mobile" href="#8"><span class="level-left"><span class="level-item">1.5.8</span><span class="level-item">8</span></span></a></li><li><a class="level is-mobile" href="#9"><span class="level-left"><span class="level-item">1.5.9</span><span class="level-item">9</span></span></a></li><li><a class="level is-mobile" href="#10"><span class="level-left"><span class="level-item">1.5.10</span><span class="level-item">10</span></span></a></li><li><a class="level is-mobile" href="#11"><span class="level-left"><span class="level-item">1.5.11</span><span class="level-item">11</span></span></a></li><li><a class="level is-mobile" href="#12"><span class="level-left"><span class="level-item">1.5.12</span><span class="level-item">12</span></span></a></li></ul></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">BakaFT&#039;s blog</a><p class="is-size-7"><span>&copy; 2023 BakaFT</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://fastly.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://fastly.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://fastly.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://fastly.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://fastly.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://fastly.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>