<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>6.828-Lab1 - BakaFT&#039;s blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="BakaFT&#039;s blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="BakaFT&#039;s blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="6.828 的 Lab1 之前用英文洋洋洒洒写了七万多字，稍显冗杂。这次使用 Linux 环境重新走一遍，并且改用中文记录。"><meta property="og:type" content="blog"><meta property="og:title" content="6.828-Lab1"><meta property="og:url" content="https://bakaft.github.io/2022/11/10/6-828-Lab1-cn/"><meta property="og:site_name" content="BakaFT&#039;s blog"><meta property="og:description" content="6.828 的 Lab1 之前用英文洋洋洒洒写了七万多字，稍显冗杂。这次使用 Linux 环境重新走一遍，并且改用中文记录。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://bakaft.github.io/img/og_image.png"><meta property="article:published_time" content="2022-11-10T10:45:23.000Z"><meta property="article:modified_time" content="2023-12-28T08:42:40.251Z"><meta property="article:author" content="BakaFT"><meta property="article:tag" content="OS"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://bakaft.github.io/2022/11/10/6-828-Lab1-cn/"},"headline":"6.828-Lab1","image":["https://bakaft.github.io/img/og_image.png"],"datePublished":"2022-11-10T10:45:23.000Z","dateModified":"2023-12-28T08:42:40.251Z","author":{"@type":"Person","name":"BakaFT"},"publisher":{"@type":"Organization","name":"BakaFT's blog","logo":{"@type":"ImageObject","url":{"text":"BakaFT's blog"}}},"description":"6.828 的 Lab1 之前用英文洋洋洒洒写了七万多字，稍显冗杂。这次使用 Linux 环境重新走一遍，并且改用中文记录。"}</script><link rel="canonical" href="https://bakaft.github.io/2022/11/10/6-828-Lab1-cn/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/highlight.js@9.12.0/styles/idea.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://fastly.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 6.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">BakaFT&#039;s blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-11-10T10:45:23.000Z" title="11/10/2022, 10:45:23 AM">2022-11-10</time></span></div></div><h1 class="title is-3 is-size-4-mobile">6.828-Lab1</h1><div class="content"><p>6.828 的 Lab1 之前用<a href="https://bakaft.github.io/2021/10/29/6-828-Lab1/">英文</a>洋洋洒洒写了七万多字，稍显冗杂。这次使用 Linux 环境重新走一遍，并且改用中文记录。</p>
<span id="more"></span>

<h1 id="Lab-1-Booting-a-PC"><a href="#Lab-1-Booting-a-PC" class="headerlink" title="Lab 1:Booting a PC"></a>Lab 1:Booting a PC</h1><h2 id="Part-1-PC-Bootstrap"><a href="#Part-1-PC-Bootstrap" class="headerlink" title="Part 1: PC Bootstrap"></a>Part 1: PC Bootstrap</h2><h3 id="Getting-Started-with-x86-assembly"><a href="#Getting-Started-with-x86-assembly" class="headerlink" title="Getting Started with x86 assembly"></a>Getting Started with x86 assembly</h3><p>本课程的汇编代码使用<strong>Intel 语法</strong>，请同学们自行阅读该小节给出的资料。</p>
<h3 id="Simulating-the-x86"><a href="#Simulating-the-x86" class="headerlink" title="Simulating the x86"></a>Simulating the x86</h3><p>在这个课程中，我们使用 QEMU 作为模拟器。首先，编译 Boot Loader 和 Kernel：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~/6.828/lab lab1 &gt; make</span><br><span class="line">+ as kern/entry.S</span><br><span class="line">+ cc kern/entrypgdir.c</span><br><span class="line"><span class="comment"># .. lots of outputs</span></span><br><span class="line">+ mk obj/kern/kernel.img</span><br></pre></td></tr></table></figure>

<p>使用<code>make qemu</code>启动编译好的 Boot Loader 和 Kernel，如果实验机器没有 GUI，请使用<code>make qemu-nox</code>以串口方式连接虚拟机：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">~/6.828/lab lab1 &gt; make qemu-nox</span><br><span class="line">sed <span class="string">&quot;s/localhost:1234/localhost:26000/&quot;</span> &lt; .gdbinit.tmpl &gt; .gdbinit</span><br><span class="line">***</span><br><span class="line">*** Use Ctrl-a x to <span class="built_in">exit</span> qemu</span><br><span class="line">***</span><br><span class="line">qemu-system-i386 -nographic -drive file=obj/kern/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp::26000 -D qemu.log</span><br><span class="line">6828 decimal is XXX octal!</span><br><span class="line">entering test_backtrace 5</span><br><span class="line">entering test_backtrace 4</span><br><span class="line">entering test_backtrace 3</span><br><span class="line">entering test_backtrace 2</span><br><span class="line">entering test_backtrace 1</span><br><span class="line">entering test_backtrace 0</span><br><span class="line">leaving test_backtrace 0</span><br><span class="line">leaving test_backtrace 1</span><br><span class="line">leaving test_backtrace 2</span><br><span class="line">leaving test_backtrace 3</span><br><span class="line">leaving test_backtrace 4</span><br><span class="line">leaving test_backtrace 5</span><br><span class="line">Welcome to the JOS kernel monitor!</span><br><span class="line">Type <span class="string">&#x27;help&#x27;</span> <span class="keyword">for</span> a list of commands.</span><br><span class="line">K&gt;</span><br></pre></td></tr></table></figure>

<p>我们已经成功启动了编译好的 Kernel，现在你可以使用<code>Ctrl+a x</code>退出 QEMU。</p>
<h3 id="The-PC’s-Physical-Address-Space"><a href="#The-PC’s-Physical-Address-Space" class="headerlink" title="The PC’s Physical Address Space"></a>The PC’s Physical Address Space</h3><p>最初的 PC 是基于 16 位的 8088 处理器，它有 1MB 的物理内存寻址空间，但是用户可以用的只有 640KB 的 Low Memory。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+------------------+  &lt;- 0x00100000 (1MB)</span><br><span class="line">|     BIOS ROM     |</span><br><span class="line">+------------------+  &lt;- 0x000F0000 (960KB)</span><br><span class="line">|  16-bit devices, |</span><br><span class="line">|  expansion ROMs  |</span><br><span class="line">+------------------+  &lt;- 0x000C0000 (768KB)</span><br><span class="line">|   VGA Display    |</span><br><span class="line">+------------------+  &lt;- 0x000A0000 (640KB)</span><br><span class="line">|                  |</span><br><span class="line">|    Low Memory    |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00000000</span><br></pre></td></tr></table></figure>

<p>一个 32 位 PC 的内存寻址空间如下所示，它保留了 1MB 以下的内存空间布局来确保兼容性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+------------------+  &lt;- 0xFFFFFFFF (4GB)</span><br><span class="line">|      32-bit      |</span><br><span class="line">|  memory mapped   |</span><br><span class="line">|     devices      |</span><br><span class="line">|                  |</span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line"></span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line">|                  |</span><br><span class="line">|      Unused      |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- depends on amount of RAM</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">| Extended Memory  |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00100000 (1MB)</span><br><span class="line">|     BIOS ROM     |</span><br><span class="line">+------------------+  &lt;- 0x000F0000 (960KB)</span><br><span class="line">|  16-bit devices, |</span><br><span class="line">|  expansion ROMs  |</span><br><span class="line">+------------------+  &lt;- 0x000C0000 (768KB)</span><br><span class="line">|   VGA Display    |</span><br><span class="line">+------------------+  &lt;- 0x000A0000 (640KB)</span><br><span class="line">|                  |</span><br><span class="line">|    Low Memory    |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00000000</span><br></pre></td></tr></table></figure>

<p>出于简化设计的考虑，JOS 仅使用内存空间的前 256MB。</p>
<blockquote>
<p>课外话：在 Windows NT 和 Linux Kernel 5.13 的 x86 版本中，前 1MB 内存将无条件保留，以确保内存安全。</p>
</blockquote>
<h3 id="The-ROM-BIOS"><a href="#The-ROM-BIOS" class="headerlink" title="The ROM BIOS"></a>The ROM BIOS</h3><p>接下来尝试使用 GDB 调试：</p>
<ol>
<li>使用<code>make qemu-nox-gdb</code>启动虚拟机，这表明接下来需要 GDB 附加到 QEMU。</li>
<li>使用<code>make gdb</code>启动 GDB，并自动附加到启动的 QEMU 上。</li>
</ol>
<p>我们可以看到接下来要执行的指令，这是 BIOS 的第一条指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[f000:fff0] 0xffff0:	ljmp   $0xf000,$0xe05b</span><br></pre></td></tr></table></figure>

<p>我们可以通过这条提示得到以下几点：</p>
<ul>
<li>IBM PC 从 0x000ffff0 开始执行，该地址位于 ROM BIOS 保留的 64KB 区域的最顶部。</li>
<li>PC 从 CS &#x3D; 0xf000 和 IP &#x3D; 0xfff0 开始执行。</li>
<li>第一条指令是长跳转指令，它通过设置寄存器 CS &#x3D; 0xf000 和 IP &#x3D; 0xe05b 来实现跳转。</li>
</ul>
<blockquote>
<p><strong>问题来了，什么是 CS 和 IP?</strong></p>
<p>这是两个寄存器的名字，CS 是<code>Code Segment</code>，存放某个程序的开始地址，而 IP 是<code>Instruction Pointer</code>，存放下一条指令的偏移。这两个寄存器的值通过如下的公式，即可转换为一个真实的物理内存地址：</p>
<p><em>physical address</em> &#x3D; 16 * <em>segment</em> + <em>offset</em></p>
<p>使用这种方式表达内存地址是因为，单个寄存器不足以表达 1MB 大小的寻址空间，具体可以参考我<a href="https://bakaft.github.io/2021/10/24/A20-%E5%8E%86%E5%8F%B2%E7%9A%84%E5%A6%A5%E5%8D%8F/">另一篇文章</a>里的详解部分。</p>
</blockquote>
<p><code>0xffff0</code>距离 BIOS 内存空间结束只有 16 字节，所以 BIOS 启动后第一件事情是向前跳跃并不奇怪，毕竟 16 个字节也做不了什么。</p>
<p>早期的 PC 设计中，BIOS 是硬连线到 0x000f0000-0x000fffff 这段空间的，这确保 BIOS 在每次加电后能够获得 PC 的控制权。</p>
<p>BIOS 的工作是进行一系列的初始化，如设置中断向量表和初始化 VGA 显示器等一系列设备。在初始化完毕后，BIOS 就会开始寻找可启动设备并转交控制权，在本节课中，他寻找到的正是下一小节中的 Boot Loader。</p>
<h2 id="Part-2-The-Boot-Loader"><a href="#Part-2-The-Boot-Loader" class="headerlink" title="Part 2: The Boot Loader"></a>Part 2: The Boot Loader</h2><p>PC 的软硬盘被分为了 512 字节为单位的区域，这种区域叫做<strong>扇区</strong>。扇区是磁盘的最小传输粒度，每次读写操作都是一个或多个扇区为界限的。</p>
<p>如果说一个磁盘是可启动的，那他的第一个扇区被称为<strong>启动扇区</strong>，这里存放了 Boot Loader 的代码。当 BIOS 找到启动扇区后，它会把这 512 字节载入内存的<code>0x7c00</code>到<code>0x7dff</code>这段空间，并通过<code>jmp</code>设置 CS:IP 为<code>0000:7c00</code>，这样就把 PC 控制权转交给了 Boot Loader。</p>
<p><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2015/09/0x7c00.html">Why 0x7C00 here?</a></p>
<p>对于这节课，我们的 Boot Loader 由两部分组成：<code>boot/boot.S</code>与<code>boot/main.c</code>。仔细阅读这两个文件，确保你知道他们在做什么。</p>
<ol>
<li>首先，Boot Loader 将处理器从实模式切换到 32 位保护模式，因为我们需要突破 1MB 的寻址空间限制。</li>
<li>其次，Boot Loader 通过特定的 x86 指令，从硬盘中读取 Kernel 并加载到内存。</li>
</ol>
<p>在你理解了 Boot Loader 源码之后，看一下<code>obj/boot/boot/asm</code>，这是汇编后的代码，它储存了一些重要的地址信息，方便你进行调试，相似地，<code>obj/kern/kernel.asm</code>储存了 Kernel 相关的信息。</p>
<h3 id="Loading-the-Kernel"><a href="#Loading-the-Kernel" class="headerlink" title="Loading the Kernel"></a>Loading the Kernel</h3><p>想要搞明白<code>boot/main.c</code>，你得知道什么是 ELF 二进制文件。</p>
<p>如需深入了解，请查阅给出资料。对于本节课程，你可以认为 ELF 文件是如下结构：</p>
<ul>
<li>一个定长的文件头 ELF header。</li>
<li>一个变长的 Program header table ，指明了所有 Program sections 的长度与要加载到的对应地址。</li>
</ul>
<p>有一些段是需要我们关注的：</p>
<ul>
<li><code>.text</code>: 程序的可执行命令</li>
<li><code>.rodata</code>: 只读数据，如字符串常量等</li>
<li><code>.data</code>: 所有初始化的数据，如全局初始化变量(<code>int x = 5</code>)</li>
<li><code>.bss</code>: 储存未初始化全局量(<code>int x</code>)，位于<code>.data</code>之后，仅保存大小和地址，由装载器或者程序本身赋值</li>
</ul>
<p>你可以使用<code>objdump</code>来查看 Kernel 所有段的名字大小和链接地址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> ~/6.828/lab │ lab1  objdump -h ./obj/kern/kernel    </span><br><span class="line"> </span><br><span class="line">./obj/kern/kernel:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line">  0 .text         000019e1  f0100000  00100000  00001000  2**4</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  1 .rodata       000006bc  f0101a00  00101a00  00002a00  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"><span class="comment"># ..</span></span><br></pre></td></tr></table></figure>

<p>注意<code>.text</code>段的<code>VMA</code>(链接地址)和<code>LMA</code>(装载地址)时不一样的，装载地址是这个段加载到内存后所在的物理内存地址，链接地址是这个段执行时的期望内存地址。</p>
<p>一般来说，链接地址和装载地址是一样的，比如 Boot Loader 的 ELF 文件中的<code>.text</code>段：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">~/6.828/lab lab1 &gt; objdump -h obj/boot/boot.out</span><br><span class="line"></span><br><span class="line">obj/boot/boot.out:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line">  0 .text         0000018c  00007c00  00007c00  00000074  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, CODE</span><br></pre></td></tr></table></figure>

<p>Boot loader 会根据 ELF 中的 Program Headers 来决定如何载入以及载入到何处。</p>
<p>可以通过下面的指令获取 kernel 的 Program Headers Table 的信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">~/6.828/lab lab1 &gt; objdump -x obj/kern/kernel</span><br><span class="line"></span><br><span class="line">obj/kern/kernel:     file format elf32-i386</span><br><span class="line">obj/kern/kernel</span><br><span class="line">architecture: i386, flags 0x00000112:</span><br><span class="line">EXEC_P, HAS_SYMS, D_PAGED</span><br><span class="line">start address 0x0010000c</span><br><span class="line"></span><br><span class="line">Program Header:</span><br><span class="line">    LOAD off    0x00001000 vaddr 0xf0100000 paddr 0x00100000 align 2**12</span><br><span class="line">         filesz 0x00006d1e memsz 0x00006d1e flags r-x</span><br><span class="line">    LOAD off    0x00008000 vaddr 0xf0107000 paddr 0x00107000 align 2**12</span><br><span class="line">         filesz 0x0000b6c1 memsz 0x0000b6c1 flags rw-</span><br><span class="line">   STACK off    0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**4</span><br><span class="line">         filesz 0x00000000 memsz 0x00000000 flags rwx</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>回到<code>boot/main.c</code>，它做的事情简单来说就是读取 Kernel 到内存，然后转交控制权。</p>
<p>它首先把 Kernel 的前 8 个扇区读取到内存中，这次读取的内容被认为足以包含 ELF 头（注意阅读函数体，虽然这里参数 sector 是 0，但是计算后操作的扇区其实是 1）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read 1st page off disk</span></span><br><span class="line"><span class="comment">// 其实到这里为止，page 这个概念还不存在。可能作者只是这么表达，4KB的空间，也就是8个扇区。</span></span><br><span class="line">readseg((<span class="type">uint32_t</span>) ELFHDR, SECTSIZE*<span class="number">8</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>随后开始读取 ELF header 中的每一个 Program header，并且根据其中信息加载所有的 Segment 到内存中，最后调用 ELF 文件的入口，进入 Kernel。</p>
<p>回看 Kernel 的装载地址和链接地址，不像 Boot Loader， 这两个地址是不一样的：Kernel 告诉 Boot Loader 把它装载到内存的低位地址(0x10000)，但是它希望运行在一个高位地址，在下一节中我们将深入讨论。</p>
<h2 id="Part-3-The-Kernel"><a href="#Part-3-The-Kernel" class="headerlink" title="Part 3: The Kernel"></a>Part 3: The Kernel</h2><p>现在我们将开始稍微深入地讨论 JOS kernel。</p>
<h3 id="Using-virtual-memory-to-work-around-position-dependence"><a href="#Using-virtual-memory-to-work-around-position-dependence" class="headerlink" title="Using virtual memory to work around position dependence"></a>Using virtual memory to work around position dependence</h3><p>当你观察 Boot Loader 的链接地址和装载地址时，你会发现它们一模一样，然而对于 Kernel 来说却完全不同。</p>
<p>操作系统更加偏好于被链接和运行到非常高的虚拟地址，比如 0xf0100000，这样是为了腾出低位空间给用户使用。下一次的 Lab 中将会详细说明。</p>
<p>0xf0100000 ? 许多机器都没有这么大的内存，所以我们不可能指望把 Kernel 真的放在这么高的位置。作为替代，我们使用处理器的内存管理单元去映射虚拟地址 0xf0100000 (Kernel 希望运行在的地方) 到物理地址 0x00100000 (Boot Loader 将 Kernel 加载到物理内存中的地址)。这样的话，虽然看样子 Kernel 腾出了足够多的空间给用户使用，但是它仍然处在低位，就正好在 BIOS 的空间上面。</p>
<p>实际上，下一次的 Lab 中我们将映射整整 256MB 内存：</p>
<ul>
<li>物理地址：0x00000000 through 0x0fffffff</li>
<li>虚拟地址：0xf0000000 through 0xffffffff</li>
</ul>
<p>这就是为什么 JOS 只能使用 256MB 内存，因为它就映射了这么点。</p>
<p>不过现在，我们只映射了前 4MB 物理内存，这足够我们运行起来 Kernel 了。</p>
<p>我们通过在<code>kern/entrypgdir.c</code>中手动编写页目录和页表实现。现在你不用理解其中的细节，只需要了解它的效果。在<code>kern/entry.S</code>设置<code>CRO_PG</code>标志之前，所有内存引用都会被视作物理地址，设置之后则为虚拟地址，会被硬件翻译为物理地址。</p>
<p> <code>entry_pgdir</code>将：</p>
<ul>
<li>虚拟地址 0xf0000000 through 0xf0400000 翻译到 物理地址 0x00000000 through 0x00400000</li>
<li>虚拟地址 0x00000000 through 0x00400000 翻译到 物理地址 0x00000000 through 0x00400000</li>
</ul>
<p>任何不处在上述范围内的虚拟地址将硬件异常，因为我们还没有做中断处理，所以它会直接导致 QEMU 异常并 dump 后退出。</p>
<h3 id="Formatted-Printing-to-the-Console"><a href="#Formatted-Printing-to-the-Console" class="headerlink" title="Formatted Printing to the Console"></a>Formatted Printing to the Console</h3><p>许多人把<code>printf()</code>当作理所当然的事情，甚至认为这是 C 的原语。但是在 Kernel 中，我们必须自己实现所有的 IO。</p>
<p>阅读 <code>kern/printf.c</code>, <code>lib/printfmt.c</code>, and <code>kern/console.c</code>，确保你了解他们之间的关系。在后续的 Lab 中，你会清楚为什么<code>printfmt.c</code>放在单独的<code>lib</code>文件夹。</p>
<h3 id="The-Stack"><a href="#The-Stack" class="headerlink" title="The Stack"></a>The Stack</h3><p>几乎只有题目</p>
<h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><blockquote>
<p><strong>Exercise 2.</strong> Use GDB’s si (Step Instruction) command to trace into the ROM BIOS for a few more instructions, and try to guess what it might be doing. You might want to look at <a target="_blank" rel="noopener" href="http://web.archive.org/web/20040404164813/members.iweb.net.au/~pstorr/pcbook/book2/book2.htm">Phil Storrs I&#x2F;O Ports Description</a>, as well as other materials on the <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/reference.html">6.828 reference materials page</a>. No need to figure out all the details - just the general idea of what the BIOS is doing first.</p>
</blockquote>
<p>参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/gnuemacs/p/14287120.html">SeaBIOS 实现简单分析 - gnuemacs - 博客园 (cnblogs.com)</a></p>
<p>首先，通过<code>ljmp</code>重新设置 CS:IP 寄存器，跳跃到低位空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 0xffff0: ljmp $0xf000, $0xe05b  </span><br></pre></td></tr></table></figure>

<p>随后的两句指令是 QEMU 用于检查系统是否是被恢复&#x2F;重启的，详见这个<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/59479227/why-bios-need-to-compare-a-value-in-seemly-randomized-address-to-zero-in-the-s">StackOverflow 问答</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 0xfe05b: cmpl $0x0, $cs:0x6ac8   </span><br><span class="line">3 0xfe062: jne 0xfd2e1        </span><br></pre></td></tr></table></figure>

<p>由于这是正常启动，所以接下来会跳转到正常的处理流程。</p>
<ol>
<li><p>设置<code>ss</code>为 0，设置<code>esp</code>为 0x7000（其实就是设置<code>sp</code>为 0x7000，正好是<code>esp</code>的低 16 位)</p>
<p>这里的设计就像 CS:IP 一样，表明当前栈顶位于 0*16+7000&#x3D;0x7000</p>
</li>
<li><p>把要执行的 32 位 C 函数存到<code>edx</code></p>
</li>
<li><p>跳转到下一个函数，切换到 32 位保护模式</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 0xfe066: xor %dx, %dx               </span><br><span class="line">5 0xfe068: mov %dx, %ss  </span><br><span class="line">6 0xfe06a: mov $0x7000, %esp</span><br><span class="line">7 0xfe070: mov $0xf34d2,%edx</span><br><span class="line">8 0xfe076: jmp 0xfd15c # 跳转到切换模式的函数</span><br></pre></td></tr></table></figure>

<p>后续的切换过程中，暂时屏蔽了中断</p>
<ul>
<li><p><code>cli</code>将 FLAG 寄存器的第 9 位，IF (Interrupt flag)，设置为 0，用于屏蔽可屏蔽中断</p>
</li>
<li><p>通过对 0x70 号端口的操作，<strong>屏蔽了</strong>不可屏蔽中断。。。</p>
<p>详细说明可以看我之前的<a href="https://bakaft.github.io/2021/10/29/6-828-Lab1/">英文笔记</a></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">9 0xfd15c: mov %eax, %ecx</span><br><span class="line">10 0xfd15f: cli                        </span><br><span class="line">11 0xfd160: cld            </span><br><span class="line"># Here to disable Maskable Hardware interrupts</span><br><span class="line"></span><br><span class="line">12 0xfd161: mov $0x8f, %eax</span><br><span class="line">13 0xfd167: out %al, $0x70           </span><br><span class="line">14 0xfd169: in $0x71, %al</span><br><span class="line"># And disable Non-maskable Hardware interrupts</span><br></pre></td></tr></table></figure>

<p>接着开启 A20 总线，关于 A20 的介绍可以参考<a href="https://bakaft.github.io/2021/10/24/A20-%E5%8E%86%E5%8F%B2%E7%9A%84%E5%A6%A5%E5%8D%8F/">A20:历史的妥协 - BakaFT’s blog</a></p>
<p>在 BIOS 开启 A20 总线的原因，似乎是为了计算内存大小，并且对内存进行测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">15 0xfd16b: in $0x92, %al</span><br><span class="line">16 0xfd16d: or $0x2, %al</span><br><span class="line">17 0xfd16f: out %al, $0x92</span><br></pre></td></tr></table></figure>

<p>接下来加载中断描述符表 IDT</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">18 0xfd171: lidtw %cs:0x6ab8       </span><br></pre></td></tr></table></figure>

<p>加载全局描述符表 GDT</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">19 0xfd177: lgdtw %cs:0x6a74       </span><br></pre></td></tr></table></figure>

<p>开启保护模式</p>
<ul>
<li><code>CR0</code> is a 32-bit control register, whose first bit (bit 0) is the <code>Protection Enable</code> bit.</li>
<li>这里开启保护模式是因为<code>edx</code>中储存的 32 位 C 函数需要运行在保护模式，由于 Boot Loader 还会再开启一次保护模式，所以 SeaBIOS 应该在后续某处关闭了保护模式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">20 0xfd17d: mov %cr0, %eax</span><br><span class="line">21 0xfd180: or $0x1, %eax</span><br><span class="line">22 0xfd184: mov %eax, %cr0   </span><br></pre></td></tr></table></figure>

<p>后续开始执行 32 位初始化</p>
<blockquote>
<p>From <a target="_blank" rel="noopener" href="https://en.wikibooks.org/wiki/X86_Assembly/Global_Descriptor_Table">x86 Assembly&#x2F;Global Descriptor Table - Wikibooks, open books for an open world</a></p>
<p>Note that to complete the process of loading a new GDT, the <strong>segment registers</strong> need to be reloaded. The CS register must be loaded using a far jump</p>
<p>这是原地 ljmp 的原因</p>
<p>From <a target="_blank" rel="noopener" href="https://docs.oracle.com/cd/E19455-01/806-3773/instructionset-73/index.html">Jump (jmp, ljmp) (IA-32 Assembly Language Reference Manual) (oracle.com)</a></p>
<p>In Real Address Mode or Virtual 8086 mode, the long pointer provides 16 bits for the CS register and 16 or 32 bits for the EIP register. This is how jmp and ljmp work.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">23 0xfd187: ljmpl $0x8, $0xfd18f</span><br><span class="line">24 0xfd18f: mov $0x10, %eax</span><br><span class="line">25 0xfd194: mov %eax, %ds</span><br><span class="line">26 0xfd196: mov %eax, %es</span><br><span class="line">27 0xfd198: mov %eax, %ss</span><br><span class="line">28 0xfd19a: mov %eax, %fs</span><br><span class="line">29 0xfd19c: mov %eax, %gs</span><br><span class="line">30 0xfd19e: mov %ecx, %eax            </span><br></pre></td></tr></table></figure>

<p>最后跳转到之前储存的函数地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">31 0xfd1a0: jmp *%edx</span><br></pre></td></tr></table></figure>

<p>后续将在这个函数内进行 POST 初始化，后续还要初始化中断向量表，初始化设备等，到最后寻找 Boot Loader 并转交控制权。</p>
<p>感觉写的够多了，有兴趣深入可以看看答案开头的参考文章。</p>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><blockquote>
<p>At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode?</p>
</blockquote>
<p>在 <code>boot.S</code>中, the <code>ljmp $PROT_MODE_CSEG, $protcseg</code>导致了模式的切换</p>
<blockquote>
<p>What is the <em>last</em> instruction of the boot loader executed, and what is the <em>first</em> instruction of the kernel it just loaded?</p>
</blockquote>
<p>Boot Loader 的最后一句是在<code>main.c</code>中的，这句将控制权转交给了 Kernel</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="type">void</span> (*)(<span class="type">void</span>)) (ELFHDR-&gt;e_entry))();</span><br></pre></td></tr></table></figure>

<p>Kernel 的第一句是在<code>entry.S</code>中的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movw    $0x1234,0x472           # warm boot</span><br></pre></td></tr></table></figure>

<blockquote>
<p><em>Where</em> is the first instruction of the kernel?</p>
</blockquote>
<p>这道题的意思是，解引用指针 0x10018，获取入口点真正的地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0x7d71</span><br><span class="line">Breakpoint 1 at 0x7d71</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">The target architecture is set to &quot;i386&quot;.</span><br><span class="line">=&gt; 0x7d71:      call   *0x10018</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x00007d71 in ?? ()</span><br><span class="line">(gdb)  x/1x 0x10018</span><br><span class="line">0x10018:        0x0010000c</span><br></pre></td></tr></table></figure>

<blockquote>
<p>How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?</p>
</blockquote>
<p>Boot Loader 会从 ELF 头中获取所有的 Program Header，每个 Header 都指明了要加载的段，并挨个加载到内存中，等加载完了，内核也就全部载入了。</p>
<h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><blockquote>
<p><strong>Exercise 5.</strong> Trace through the first few instructions of the boot loader again and identify the first instruction that would “break” or otherwise do the wrong thing if you were to get the boot loader’s link address wrong. Then change the link address in <code>boot/Makefrag</code> to something wrong, run make clean, recompile the lab with make, and trace into the boot loader again to see what happens. Don’t forget to change the link address back and make clean again afterward!</p>
</blockquote>
<p>这里很诡异，我把 0x7c00 改成 0x8c00，重新 make 之后，好像一切都没改过。</p>
<p>Boot Loader 的代码甚至还在 0x7c00</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0x7c00</span><br><span class="line">Breakpoint 1 at 0x7c00</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">[   0:7c00] =&gt; 0x7c00:	cli</span><br><span class="line">Breakpoint 1, 0x00007c00 in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">[   0:7c01] =&gt; 0x7c01:	cld</span><br><span class="line">0x00007c01 in ?? ()</span><br></pre></td></tr></table></figure>

<p>但是不久之后你会察觉到不对劲，怎么 GDT 内存地址都变负数了？到最后甚至引发了 QEMU 的 Triple fault</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">(gdb) si</span><br><span class="line">[   0:7c1e] =&gt; 0x7c1e:	lgdtw  -0x739c</span><br><span class="line">0x00007c1e in ?? ()</span><br><span class="line">...</span><br><span class="line">(gdb) si</span><br><span class="line">[   0:7c2a] =&gt; 0x7c2a:	mov    %eax,%cr0</span><br><span class="line">0x00007c2a in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">[   0:7c2d] =&gt; 0x7c2d:	ljmp   $0x8,$0x8c32</span><br><span class="line">0x00007c2d in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">Program received signal SIGTRAP, Trace/breakpoint trap.</span><br><span class="line">[   0:7c2d] =&gt; 0x7c2d:  ljmp   $0x8,$0x8c32</span><br><span class="line">0x00007c2d in ?? ()</span><br></pre></td></tr></table></figure>

<p>GDT 仍然在原来的 0x7c64，而-0x739c 更是不知道飞到哪里了(应该是溢出了)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb)  x/6xb -0x739c</span><br><span class="line">0xffff8c64:	0x04	0x26	0x67	0x66	0x89	0x07</span><br><span class="line">(gdb)  x/6xb 0x7c64</span><br><span class="line">0x7c64:	0x17	0x00	0x4c	0x8c	0x00	0x00</span><br></pre></td></tr></table></figure>

</div><div class="article-licensing box"><div class="licensing-title"><p>6.828-Lab1</p><p><a href="https://bakaft.github.io/2022/11/10/6-828-Lab1-cn/">https://bakaft.github.io/2022/11/10/6-828-Lab1-cn/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>BakaFT</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2022-11-10</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2023-12-28</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/OS/">OS</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/11/11/%E5%A6%82%E4%BD%95%E5%90%91%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8F%90%E4%BA%A4PR/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">如何向开源项目提交PR</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/11/04/%E4%B8%80%E6%AC%A1rm-rf-%E6%8A%A2%E6%95%91%E7%BB%8F%E5%8E%86/"><span class="level-item">一次rm -rf /* 抢救经历</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Lab-1-Booting-a-PC"><span class="level-left"><span class="level-item">1</span><span class="level-item">Lab 1:Booting a PC</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Part-1-PC-Bootstrap"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">Part 1: PC Bootstrap</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Getting-Started-with-x86-assembly"><span class="level-left"><span class="level-item">1.1.1</span><span class="level-item">Getting Started with x86 assembly</span></span></a></li><li><a class="level is-mobile" href="#Simulating-the-x86"><span class="level-left"><span class="level-item">1.1.2</span><span class="level-item">Simulating the x86</span></span></a></li><li><a class="level is-mobile" href="#The-PC’s-Physical-Address-Space"><span class="level-left"><span class="level-item">1.1.3</span><span class="level-item">The PC’s Physical Address Space</span></span></a></li><li><a class="level is-mobile" href="#The-ROM-BIOS"><span class="level-left"><span class="level-item">1.1.4</span><span class="level-item">The ROM BIOS</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Part-2-The-Boot-Loader"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">Part 2: The Boot Loader</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Loading-the-Kernel"><span class="level-left"><span class="level-item">1.2.1</span><span class="level-item">Loading the Kernel</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Part-3-The-Kernel"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">Part 3: The Kernel</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Using-virtual-memory-to-work-around-position-dependence"><span class="level-left"><span class="level-item">1.3.1</span><span class="level-item">Using virtual memory to work around position dependence</span></span></a></li><li><a class="level is-mobile" href="#Formatted-Printing-to-the-Console"><span class="level-left"><span class="level-item">1.3.2</span><span class="level-item">Formatted Printing to the Console</span></span></a></li><li><a class="level is-mobile" href="#The-Stack"><span class="level-left"><span class="level-item">1.3.3</span><span class="level-item">The Stack</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Exercises"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">Exercises</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2"><span class="level-left"><span class="level-item">1.4.1</span><span class="level-item">2</span></span></a></li><li><a class="level is-mobile" href="#3"><span class="level-left"><span class="level-item">1.4.2</span><span class="level-item">3</span></span></a></li><li><a class="level is-mobile" href="#5"><span class="level-left"><span class="level-item">1.4.3</span><span class="level-item">5</span></span></a></li></ul></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">BakaFT&#039;s blog</a><p class="is-size-7"><span>&copy; 2023 BakaFT</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://fastly.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://fastly.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://fastly.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://fastly.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://fastly.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://fastly.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>